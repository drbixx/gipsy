PROGRAM SHLANS

      LOGICAL      FOPERR
      CHARACTER*80 INPUT, TARGET, LIST, INCDIR
      INTEGER      LO, LPP

      CALL GETCOM(INPUT,TARGET,LIST,INCDIR,LO,LPP )
N     WARNING:: READONLY is not ANSI F77
C
      FOPERR=.FALSE.
      OPEN(UNIT=1,FILE=INPUT,STATUS='OLD',ERR=FILERR)
      IF FOPERR
      THEN
      WRITE(*,*) 'Cannot open source'
      CALL EXITF(1)
      ENDIF
      IF TARGET.EQ.'0'
      THEN
      OPEN(UNIT=2,STATUS='SCRATCH')
      ELSE
      FOPERR=.FALSE.
      OPEN(UNIT=2,FILE=TARGET,STATUS='NEW',ERR=FILERR)
      IF (FOPERR)
      THEN
      OPEN(UNIT=2,FILE=TARGET,STATUS='OLD')
      CIF
      CIF
      IF LIST.EQ.'0'
      THEN
      OPEN(UNIT=3,STATUS='SCRATCH')
      ELSE
      FOPERR=.FALSE.
      OPEN(UNIT=3,FILE=LIST,STATUS='NEW',ERR=FILERR)
      IF (FOPERR)
      THEN
      OPEN(UNIT=3,FILE=LIST,STATUS='OLD')
      CIF
      CIF
      REWIND 2
      CALL SHELTR(LO,LPP,1,2,3,NERR,4,10,INCDIR)
      IF NERR.EQ.0
      THEN
      REWIND 2
      ELSE
      CLOSE(UNIT=2,STATUS='DELETE')
      CIF
N     WARNING: CALL EXIT NOT ANSI F77
      IF (NERR.EQ.0)
      THEN
         CALL EXITF(0)
      ELSE
         WRITE(*,*) NERR, ' ERROR(S)'
         CALL EXITF(1)
      CIF
      STOP
      PROC FILERR
      FOPERR=.TRUE.
      CPROC
      END
N     GET COMMAND LINE ARGUMENTS
      SUBROUTINE GETCOM(SOURCE,TARGET,LISTER,INCDIR,LO,LPP)
      CHARACTER*(*) SOURCE,TARGET,LISTER,INCDIR
      INTEGER       LO,LPP

#!IF  UNIX
      CHARACTER*80  ARGV,NAME
      INTEGER       IARGC,IARG

      NARG=IARGC( )

      IARG=0
      SOURCE='0'
      TARGET='1'
      LISTER='0'
      INCDIR='0'
      LO=1
      LPP=57
      WHILE (IARG.LE.NARG)
#!IF  HPUX
         CALL IGETARG(IARG,ARGV,LEN(ARGV) )
#!ELSE
         CALL GETARG(IARG,ARGV )
#!ENDIF
         IF (IARG.EQ.0)
         THEN
            NAME=ARGV
         ELSE
            IF (ARGV(1:3).EQ.'-ln')
            THEN
               LPP=0
               I=4
               WHILE (ARGV(I:I).GE.'0'.AND.ARGV(I:I).LE.'9')
                  LPP=10*LPP+ICHAR(ARGV(I:I))-ICHAR('0')
                  I=I+1
               CWHILE
            ELSEIF (ARGV(1:2).EQ.'-l')
            THEN
               LISTER='1'
               IF (ARGV(3:3).GE.'0'.AND.ARGV(3:3).LE.'3')
               THEN
                  LO=ICHAR(ARGV(3:3))-ICHAR('0')
               ENDIF
            ELSEIF (ARGV.EQ.'-f')
            THEN
               TARGET='0'
            ELSEIF (ARGV(1:2).EQ.'-I')
            THEN
               INCDIR=ARGV(3:)
            ELSEIF (INDEX(ARGV,'.shl').NE.0)
            THEN
               SOURCE=ARGV
            ELSE
               WRITE(*,*) 'Unknown option on command line'
               CALL EXITF(1)
            ENDIF
         ENDIF
         IARG=IARG+1
      CWHILE
      IF (NARG.EQ.0)
      THEN
         N=INDEX(NAME,' ')
         WRITE(*,*) NAME(:N),
     #'source [-I<dir>] [-f] [-l[<lo>] [-ln<lpp>]]'
         CALL EXITF(1)
      ENDIF
      N=INDEX(SOURCE,'.shl')
      IF (N.EQ.0)
      THEN
         WRITE(*,*) 'No Source file specified!'
         CALL EXITF(1)
      ELSE
         IF (LISTER.NE.'0')
         THEN
            LISTER=SOURCE(:N)//'sls'
         ENDIF
         IF (TARGET.NE.'0')
         THEN
            TARGET=SOURCE(:N)//'f'
         ENDIF
      ENDIF
#!ELIF	VMS
      CHARACTER*256 ARGS
      CALL LIB$GET_FOREIGN(ARGS)
      LENC=INDEX(ARGS,' ')
      IF (ARGS.EQ.' ')
      THEN
         WRITE(*,*) 'SHELTRAN SOURCE.SHL[/LIST][/INCLUDE=<DIR>'//
     #'[/LPP=<N>][/LO=<M>]][/NOFOR]'
         CALL EXITF(1)
      ELSE
         TARGET='1'
         LISTER='0'
         LO=1
         LPP=57
         NL=INDEX(ARGS,'/LIST')
         IF (NL.NE.0)
         THEN
            LISTER='1'
            ARGS(NL:NL+4)=' '
         ENDIF
         NL=INDEX(ARGS,'/NOFOR')
         IF (NL.NE.0)
         THEN
            TARGET='0'
            ARGS(NL:NL+5)=' '
         ENDIF
         NL=INDEX(ARGS,'/INCLUDE=')
         IF (NL.NE.0)
         THEN
            ARGS(NL:NL+8)=' '
            NL=NL+9
            I=0
            WHILE (ARGS(NL:NL).NE.'/'.AND.ARGS(NL:NL).NE.' ')
               I=I+1
               INCDIR(I:I)=ARGS(NL:NL)
               ARGS(NL:NL)=' '
               NL=NL+1
            CWHILE
         ENDIF
         NL=INDEX(ARGS,'/LO=')
         IF (NL.NE.0)
         THEN
            ARGS(NL:NL+3)=' '
            NL=NL+4
            IF (ARGS(NL:NL).GE.'0'.AND.ARGS(NL:NL).LE.'3')
            THEN
               LO=ICHAR(ARGS(NL:NL))-ICHAR('0')
               ARGS(NL:NL)=' '
            ENDIF
         ENDIF
         NL=INDEX(ARGS,'/LPP=')
         IF (NL.NE.0)
         THEN
            ARGS(NL:NL+4)=' '
            NL=NL+5
            LPP=0
            WHILE (ARGS(NL:NL).GE.'0'.AND.ARGS(NL:NL).LE.'9')
               LPP=10*LPP+ICHAR(ARGS(NL:NL))-ICHAR('0')
               ARGS(NL:NL)=' '
               NL=NL+1
            CWHILE
         ENDIF
         NL=INDEX(ARGS,'.SHL')
         IF (NL.NE.0)
         THEN
            NE=NL+3
            NL=NL-1
            WHILE (NL.GT.0.AND.ARGS(NL:NL).NE.' ')
               NL=NL-1
            CWHILE
            SOURCE=ARGS(NL+1:NE)
            ARGS(NL+1:NE)=' '
         ENDIF
         IF (ARGS.NE.' ')
         THEN
            WRITE(*,*) 'Unknown option(s) on command line'
            CALL EXITF(1)
         ENDIF
      ENDIF
      N=INDEX(SOURCE,'.SHL')
      IF (N.EQ.0)
      THEN
         WRITE(*,*) 'No Source file specified!'
         CALL EXITF(1)
      ELSE
         IF (LISTER.NE.'0')
         THEN
            LISTER=SOURCE(:N)//'SLS'
         ENDIF
         IF (TARGET.NE.'0')
         THEN
            TARGET=SOURCE(:N)//'F'
         ENDIF
      ENDIF
#!ENDIF
      RETURN
      END
N
N     CONVERT SHELTRAN INTO FORTRAN 77
      SUBROUTINE SHELTR(N1,N2,N3,N4,N5,N6,INCBEG,INCMAX,INCDIR)
N
N N1 LIST OPTION
N N2 LINES PER PAGE
N N3 INPUT FILE LOGICAL UNIT
N N4 FORTRAN OUTPUT FILE LOGICAL UNIT
N N5 LIST FILE LOGICAL UNIT
N N6 NUMBER OF ERRORS FOUND
N INCBEG FIRST FORTRAN UNIT FOR INCLUDE FILES
N INCMAX LAST  FORTRAN UNIT FOR INCLUDE FILES
N INCDIR DIRECTORY WHERE TO FIND INCLUDE FILES
N
      LOGICAL LNRPRT,CONPRT
N      PRINT LINE-, CONT. LINE NUMBERS
      PARAMETER(LNRPRT=.TRUE.,CONPRT=.TRUE.)
      CHARACTER*80 INCDIR
      CHARACTER*160 INCNAM
      LOGICAL NEXIT,ENDINP
      CHARACTER*1 LINE(80),CPARM(66)
      CHARACTER*80 CLINE
N     CHARACTER LAST USED
      INTEGER POS
      COMMON /BLINE/LINE
      COMMON /BLIST/POS,LSTOPT,LINEPP,NPRINT
      COMMON /BPARM/NPARM(66)
      COMMON/CHPARM/ CPARM
      COMMON /BPARS/NTYPE,NTARGT,NEXIT,NOUT,LUOUT
N
       COMMON /ERR/ NERROR,NWARN
      INTEGER SOURC
N     INDENTATION LEVEL AND STEP
      INTEGER LEVEL,STEP
      CHARACTER*1 BLANK,ZERO
N     LEGAL CHARACTERS IN LINE-COLUMN 1 (STMT NTYPE 1)
      CHARACTER*1 SPCHAR(6),FORMT(7)
N     CHARACTER TYPE IN LINE-COLUMN 1
      INTEGER SUBTYP
N  LOWER TO UPPER FUNCTION ( 1 CHAR )
      CHARACTER*1  LTU

      EQUIVALENCE (LINE,CLINE)
      DATA ENDINP/.FALSE./
N     CONTROLS PRINTING OF ISN
      DATA LEVEL/0/,STEP/3/
      DATA BLANK/' '/,ZERO/'0'/
      DATA SPCHAR/'C','E','N','*','F','I'/
      DATA FORMT/'F','O','R','M','A','T','('/
N LIST FILE OPTIONS(0,1,2,3)
      LSTOPT=N1
N LINES PER PAGE OF LISTING
      LINEPP=N2
N LUN FOR INPUT SOURCE TEXT FILE
      SOURC=N3
N LUN FOR LISTING OUTPUT FILE
      NPRINT=N5
N LUN FOR FINAL FORTRAN OUTPUT TEXT
      NTARGT=N4
N
N     INITIALIZE SOURCE LISTER
      CALL LISTER
N      INITIALIZE PARSER
      CALL PARSER
E
N      MAIN LOOP
N
      WHILE .TRUE.
N     READ SOURCE LINE
 100    FORMAT(80A1)
      READ (SOURC,100,END=ENDSRC) LINE
      IF ENDINP
      THEN
      XWHILE
      CIF
N TRANSLATE TAB CHARACTERS
N .   (CALL CAN BE REMOVED IF THERE WILL BE NO TABS)
       CALL RTAB(LINE,80)
N      FIND FIRST NON-BLANK
      PERFORM NBLPOS
      SELECT POS
      CASE 1
      PERFORM SUBTPE
      SELECT SUBTYP
N     COMMENT LINE
      CASE 1,4
      NTYPE=110
N     EJECT LINE
      CASE 2
      NTYPE=100
      CALL HEADER
N     NOTE LINE
      CASE 3
      NTYPE=100
      CALL PNOTE
N      COMPILER DIRECTIVE LINE;
      CASE 5
N      LIST AS COMMENT
      NTYPE=110
      CALL FCARD
      CASE 6
      NTYPE=110
      IF SOURC.EQ.N3
      THEN
      SOURC=INCBEG
      ELSEIF SOURC.LT.INCMAX
      THEN
      SOURC=SOURC+1
      ELSE
      NTYPE=105
      CIF
      IF NTYPE.EQ.110
      THEN
      PERFORM MAKNAM
N     WARNING:: READONLY is not ANSI F77
C
      OPEN(UNIT=SOURC,FILE=INCNAM,STATUS='OLD',ERR=OPERI)
      CIF
      OTHER
      NTYPE=102
      PERFORM FMTSCN
      IF NTYPE.EQ.29
N     FORMAT STATEMENT
      THEN
      PERFORM BLKPOS
N      FORMAT LABEL TOO LARGE?
      IF POS.EQ.6
      THEN
      NTYPE=103
      CIF
      CIF
      CSELECT
      CASE 2,3,4,5
      NTYPE=102
      PERFORM FMTSCN
      CASE 6
N      CONTINUATION LINE?
      IF LINE(6).NE.ZERO
      THEN
      NTYPE=3
      ELSE
      CALL CLASS(NTYPE,POS)
      CIF
      OTHER
N     CLASSIFY STATEMENT,RETURN TYPE AND CHAR. LAST USED
      CALL CLASS(NTYPE,POS)
      CSELECT
E
      IF NTYPE.LT.100
      THEN
N                                 PRINT OF VALID TYPES OTHER THAN 1
      SELECT NTYPE
      CASE 1
N     CONTINUATION LINE
      CASE 3
      IF LEVEL.EQ.0
      THEN
      CALL PRINTC(CONPRT)
      ELSE
      CALL PRINT(LEVEL,CONPRT)
      CIF
N     IF,WHILE,FOR,SELECT,REPEAT,PROC
      CASE 4,8,11,14,20,23
      CALL PRINT(LEVEL,LNRPRT)
      LEVEL=LEVEL+STEP
N     THEN,ELSE,CASE,OTHER,ELSEIF
      CASE 5,6,15,16,31
      LEVEL=LEVEL-STEP
      CALL PRINT(LEVEL,LNRPRT)
      LEVEL=LEVEL+STEP
N     CIF,CWHILE,CFOR,CSELECT,UNTIL,CPROC
      CASE 7,10,13,17,18,24
      LEVEL=LEVEL-STEP
      CALL PRINT(LEVEL,LNRPRT)
N     ENTRY,END : RESET LEVEL TO BEGIN-VALUE
      CASE 27,28
      LEVEL=0
      CALL PRINT(LEVEL,LNRPRT)
N     FORMAT
      CASE 29
N     PRINT ISN
      CALL PRINTC(LNRPRT)
N     FORTRAN,XWHILE,XFOR,XREPEAT,PERFORM
      OTHER
      CALL PRINT(LEVEL,LNRPRT)
      CSELECT
      CALL PARSE
      ELSEIF NTYPE.GT.100
      THEN
      CALL PRINTC(.FALSE.)
      SELECT NTYPE-100
      CASE 1
      CALL ERRMSG('INVALID CASE OR RETURN STATEMENT                  ')
      CASE 2
      CALL ERRMSG('INVALID CHARACTER OR ILLEGAL STATEMENT NUMBER     ')
      CASE 3
      CALL ERRMSG('FORMAT LABEL GREATER THAN 9999                    ')
      CASE 4
      CALL ERRMSG('MORE THAN 7 *-PARAMETERS                          ')
N      NTYPE=110: COMMENT
      CASE 5
      CALL ERRMSG('INCLUDE FILE MAXIMUM NESTING DEPTH EXCEEDED       ')
      CASE 6
      CALL ERRMSG('INCLUDE FILE OPEN ERROR                           ')
      OTHER
      CSELECT
      CIF
N                                        NEXT SOURCE STATEMENT,PLEASE
      CWHILE
N                              PRINT FINAL MESSAGES
      CALL FINAL
       N6=NERROR
      RETURN
E
N      TYPE PRE-SELECTION
      PROC SUBTPE
      SUBTYP=0
      FOR I=1,6
        IF ( LTU( LINE(1) ) .EQ. SPCHAR(I) )
        THEN
          SUBTYP=I
          XFOR
        CIF
      CFOR
      CPROC
N
N      END OF CURRENT SOURCE FILE
      PROC ENDSRC
      ENDINP=SOURC.EQ.N3
      CLOSE(UNIT=SOURC)
      IF SOURC.EQ.INCBEG
      THEN
      SOURC=N3
      ELSE
      SOURC=SOURC-1
      CIF
      CLINE='* END OF INCLUDE <<<<<<<<<<<<<<<<<'
      CPROC
N
N    INCLUDE FILE OPEN ERROR
      PROC OPERI
      IF SOURC.EQ.INCBEG
      THEN
      SOURC=N3
      ELSE
      SOURC=SOURC-1
      CIF
      NTYPE=106
      CPROC
N
N      FIND FIRST NON-BLANK IN LABEL FIELD
      PROC NBLPOS
      POS=0
      REPEAT
      POS=POS+1
      UNTIL LINE(POS).NE.BLANK.OR.POS.EQ.7
      CPROC
N
N
N      FIRST BLANK AFTER START OF LABEL
      PROC BLKPOS
      POS=1
      REPEAT
      POS=POS+1
      UNTIL LINE(POS).EQ.BLANK.OR.POS.EQ.6
      CPROC
N
N
N      VERIFY 'FORMAT'
      PROC FMTSCN
      J=1
      I=7
      WHILE I.LE.72
      IF LINE(I).EQ.BLANK
      THEN
      I=I+1
      ELSE
      IF ( LTU( LINE(I) ) .EQ. FORMT(J)  )
      THEN
      I=I+1
      J=J+1
      IF J.EQ.8
      THEN
      NTYPE=29
      XWHILE
      CIF
      ELSE
      XWHILE
      CIF
      CIF
      CWHILE
      CPROC
N     CONCATENATES INCLUDE FILENAME 
N
      PROC MAKNAM
        INCNAM=' '
        LNAM = 0
        IF INCDIR.NE.'0'
        THEN
          FOR I=1,80
            IF INCDIR(I:I).NE.' '
            THEN
              LNAM=LNAM+1
              INCNAM(LNAM:LNAM)=INCDIR(I:I)
            CIF
          CFOR
        CIF
        FOR I=2,80
          IF CLINE(I:I).NE.' '
          THEN
            LNAM=LNAM+1
            INCNAM(LNAM:LNAM)=CLINE(I:I)
          CIF
        CFOR
      CPROC
      END
N        HANDLES EVERY THING CONCERNING THE SOURCE LISTING.
N
      SUBROUTINE LISTER
N
      SAVE
N      DEFAULTS: LIST OPTION - LINES PER PAGE
      PARAMETER (LODEF=1,LPPDEF=50)
      CHARACTER*1 LINE(80)
      COMMON /BLINE/LINE
      COMMON /BLIST/IPOS(1),LSTOPT,LINEPP,NPRINT
       COMMON /ERR/ ERROR,NWARN
      INTEGER CHARPL
N                                        LINE COUNT START
      INTEGER START
N                                        SOURCE LINE COUNT
      INTEGER COMCON
      INTEGER PAGENO,LINENO
      INTEGER SEQNO,LINTOT,ERROR,ERRTOT,WRNTOT
      INTEGER POS
      INTEGER I
      INTEGER NEL, NELC
      CHARACTER*1 BLLINE(72),POINTR,BLANK
      INTEGER LEV,LEVEL,INIT,LAST,LENG
N                                        BLANK LINE
      LOGICAL NOTE
      LOGICAL LNRPRT,LNOPRT
      CHARACTER*1 TITLSV(66),TITLE(66)
      CHARACTER*10 FORSEQ(4),NBRING
      CHARACTER*5 SOURCE
      CHARACTER*1 OUT(124)
      CHARACTER*(*) TEXT
      CHARACTER*1 TEXT2(6)
      DATA SEQNO,LINTOT/0,0/
      DATA ERRTOT,WRNTOT/0,0/
       DATA TITLE/66*' '/
      DATA OUT/124*' '/
      DATA BLANK/' '/
      DATA NOTE/.FALSE./
       DATA START/1/
      DATA BLLINE/72*' '/
      DATA POINTR/'^'/
      DATA FORSEQ/
     - 'FORT + SEQ',
     - '   FORTRAN',
     - '   FORTRAN',
     - 'SEQUENTIAL'/
E
  200 FORMAT(' ***ERROR***',10X,A)
  201 FORMAT(1X)
  202 FORMAT(' ..WARNING..',10X,6A1,1X,A)
  203 FORMAT(7X,'*ERROR IN FOLLOWING LINE WITH SOURCE SEQ.NO :',I4,'*')
  400 FORMAT('0END OF SEGMENT')
  401 FORMAT('0  OPTIONS IN EFFECT - LINECOUNT=',I2,', LINEWIDTH=',I3,
     - ', ',A,'URCE, ',A,' NUMBERING')
  406 FORMAT('0',I4,' ERROR(S)',11X,I4,' TARGET STATEMENTS')
  500 FORMAT('0END OF PROGRAM')
  600 FORMAT(I4,'  SHELTRAN ERROR(S)')
  601 FORMAT(I4,' WARNING MESSAGE(S)')
N                              ><  SET INITIAL VALUES
      IF LSTOPT.LT.0.OR.LSTOPT.GT.3
      THEN
      LSTOPT=LODEF
      CIF
      IF LINEPP.LE.0
      THEN
      LINEPP=LPPDEF
      CIF
      SOURCE='   SO'
      CHARPL=79
      NBRING=FORSEQ(LSTOPT+1)
      SELECT LSTOPT
      CASE 1
      CHARPL=131
      CASE 2,3
      OTHER
      SOURCE='NO SO'
      CSELECT
      FOR I=1,66
      TITLSV(I)=TITLE(I)
      CFOR
         PERFORM BEGIN
      RETURN
E
N      ><  ISSUE WARNING MESSAGES
      ENTRY WARN(TEXT2,TEXT)
N                                        CHECK FOR END OF PAGE
         PERFORM CHECK
         PERFORM TXTLEN
         WRITE (NPRINT,202) TEXT2,TEXT(:NEL)
C      WRITE(*,202) TEXT2,TEXT(:NEL)
N      COUNT WARNINGS
         NWARN=NWARN+1
      RETURN
N     ><  ISSUE ERROR MESSAGES
N      (    ALSO COUNTS ERRORS)
      ENTRY ERRMSG(TEXT)
      POS = IPOS(1)
      IF POS.GE.73
      THEN
      POS=72
      CIF
      ERROR = ERROR + 1
      IF LSTOPT.EQ.0
      THEN
      COMCON=COMCON+4
N                                        CHECK FOR END OF PAGE
      PERFORM CHECK
      WRITE (NPRINT,203) SEQNO
N                              WRITE SOURCE LINE
      NEL=NELC(LINE,80)
      WRITE (NPRINT,'(1X,I4,3X,80(A1:))') LINENO,(LINE(KGB),KGB=1,NEL)
      ELSE
      COMCON = COMCON + 2
      PERFORM CHECK
      CIF
      IF LSTOPT.NE.1
      THEN
N                                        SET POINTER
      BLLINE(POS) = POINTR
N                                        WRITE POINTER LINE
      NEL=NELC(BLLINE,72)
      WRITE(NPRINT,'(8X,72(A1:))') (BLLINE(KGB),KGB=1,NEL)
N                                        CLEAR POINTER
      BLLINE(POS) = BLANK
      ELSE
      WRITE (NPRINT,201)
      CIF
N                              WRITE ERROR MESSAGE
      PERFORM TXTLEN
      WRITE(NPRINT,200) TEXT(:NEL)
C     WRITE(*,200) TEXT(:NEL)
      WRITE(NPRINT,201)
      RETURN
N
N          ><  INCREMENT SOURCE LINE NUMBER
      ENTRY ICRISN(INCR)
         LINENO = LINENO + INCR
      RETURN
N
N      ><  PRINT SRC LINE; ALIGN & INDENT
      ENTRY PRINT(LEV,LNRPRT)
      LNOPRT=LNRPRT
      SELECT LSTOPT
      CASE 1
      IF LEV.LE.30.AND.LEV.GE.0
      THEN
      LEVEL=LEV+7
      ELSE
      IF LEV.LT.0
      THEN
      LEVEL=7
      ELSE
      LEVEL=37
      CIF
      CIF
      PERFORM FSTLST
      IF LEVEL+LENG.GT.73.AND.NOTE
      THEN
      COMCON=COMCON+1
      PERFORM CHECK
      NEL=NELC(OUT,124)
      WRITE(NPRINT,'(8X,124(A1:))') (OUT(KGB),KGB=1,NEL)
      PERFORM BLKOUT
                              ELSE
      PERFORM CHECK
      CIF
      OUT(6)=LINE(6)
      PERFORM LONGPR
      CASE 2
      PERFORM SHRTPR
      CASE 3
      PERFORM SEQPRT
      OTHER
      SEQNO=SEQNO+1
      CSELECT
      RETURN
N
N      ><  PRINT WITHOUT ALIGN OR INDENT
      ENTRY PRINTC(LNRPRT)
      LNOPRT=LNRPRT
      SELECT LSTOPT
      CASE 1
      LEVEL=1
      INIT=1
      LAST=72
      PERFORM CHECK
      PERFORM LONGPR
      CASE 2
      PERFORM SHRTPR
      CASE 3
      PERFORM SEQPRT
      OTHER
      SEQNO=SEQNO+1
      CSELECT
      RETURN
N
N      ><  PROCESS NOTE
      ENTRY PNOTE
      SELECT LSTOPT
      CASE 1
      IF NOTE
      THEN
      PERFORM CHECK
      NEL=NELC(OUT,124)
      WRITE(NPRINT,'(8X,124(A1:))') (OUT(KGB),KGB=1,NEL)
      PERFORM BLKOUT
      CIF
      PERFORM FSTLST
      PERFORM CC26
      IF LENG.GT.50
      THEN
      LAST=INIT+49
      CIF
      LEVEL=75
      PERFORM FILOUT
      NOTE=.TRUE.
      CASE 2
      PERFORM CHECK
      NEL=NELC(LINE,80)
      WRITE(NPRINT,'(8X,80(A1:))') (LINE(KGB),KGB=1,NEL)
      CASE 3
      PERFORM SEQPRT
      OTHER
      SEQNO=SEQNO+1
      CSELECT
      RETURN
N
N      ><  PROCESS EJECT LINE
      ENTRY HEADER
      PERFORM FSTLST
      PERFORM CC26
      IF LENG.NE.0.AND.LSTOPT.NE.0
      THEN
      FOR I=1,66
      TITLSV(I)=LINE(I+6)
      CFOR
      CIF
      SELECT LSTOPT
      CASE 1,2
N                              WRITE PAGE HEADER
      PERFORM NWPAGE
      CASE 3
      COMCON=COMCON-1
      PERFORM SEQPRT
      PERFORM NWPAGE
      OTHER
      SEQNO=SEQNO+1
      CSELECT
      RETURN
N
N      ><  WRITE TRAILER
      ENTRY TRAIL
      COMCON=COMCON+5+MIN(1,NWARN)
      PERFORM CHECK
         WRITE(NPRINT,400)
         PERFORM STAT
         LINTOT = LINTOT + LINENO - START
         ERRTOT = ERRTOT + ERROR
      WRNTOT = WRNTOT + NWARN
         PERFORM BEGIN
      RETURN
N
N                              ><  FINAL ENTRY POINT
      ENTRY FINAL
      PERFORM CHECK
N                              PRINT TRAILER
         WRITE(NPRINT,500)
N                              CHECK LAST STATEMENT IS <END>
         IF LINENO .GT. START
         THEN
      WRITE (NPRINT,201)
N                              WRITE ERROR
      WRITE (NPRINT,200) 'END STATEMENT IS MISSING'
C     WRITE(*,200) 'END STATEMENT IS MISSING'
      LINTOT=LINTOT+LINENO+1-START
            ERRTOT = ERRTOT + ERROR + 1
      CIF
      LINENO=LINTOT+START-1
         ERROR = ERRTOT
      NWARN = WRNTOT
N                                        WRITE SOURCE LIST TRAILER
         PERFORM STAT
      SEQNO=0
      LINTOT=0
      ERRTOT=0
      NOTE=.FALSE.
      RETURN
E
N                              RESET COUNTERS
      PROC BEGIN
         PAGENO = 0
         ERROR = 0
      NWARN=0
         LINENO = START
      COMCON=LINEPP
      FOR I=1,66
      TITLSV(I)=TITLE(I)
      CFOR
      CPROC
N
N
N      DETERMINE ALIGNMENT POINTERS
      PROC FSTLST
      INIT=6
            REPEAT
      INIT=INIT+1
      UNTIL LINE(INIT).NE.BLANK.OR.INIT.EQ.73
      IF INIT.NE.73
      THEN
      LAST=73
           REPEAT
      LAST=LAST-1
      UNTIL LINE(LAST).NE.BLANK
      LENG=LAST-INIT+1
      ELSE
      INIT=7
      LAST=7
      LENG=0
      CIF
      CPROC
N
N      PRINT LONG LINE
      PROC LONGPR
      PERFORM FILOUT
      IF LNOPRT
      THEN
      NEL=NELC(OUT,124)
      WRITE (NPRINT,'(1X,I4,3X,124(A1:))') LINENO,(OUT(KGB),KGB=1,NEL)
      ELSE
      NEL=NELC(OUT,124)
      WRITE(NPRINT,'(8X,124(A1:))') (OUT(KGB),KGB=1,NEL)
      CIF
      PERFORM BLKOUT
      NOTE =.FALSE.
      CPROC
N
N      PRINT SHORT LINE
      PROC SHRTPR
      PERFORM CHECK
      IF LNOPRT
      THEN
      NEL=NELC(LINE,80)
      WRITE (NPRINT,'(1X,I4,3X,80(A1:))') LINENO,(LINE(KGB),KGB=1,NEL)
      ELSE
      NEL=NELC(LINE,80)
      WRITE(NPRINT,'(8X,80(A1:))') (LINE(KGB),KGB=1,NEL)
      CIF
      CPROC
N
N      SEQUENCED PRINT
      PROC SEQPRT
      SEQNO=SEQNO+1
      PERFORM CHECK
      NEL=NELC(LINE,80)
      WRITE (NPRINT,'(1X,I4,3X,80(A1:))') SEQNO,(LINE(KGB),KGB=1,NEL)
      CPROC
N
N                                        CHECK FOR END OF PAGE
      PROC CHECK
         COMCON = COMCON + 1
N                              CHECK FOR PAGE OVERFLOW
         IF COMCON .GE. LINEPP
         THEN
N                              WRITE PAGE HEADER
            PERFORM NWPAGE
         CIF
      CPROC
N
N     Length of TEXT string
      PROC TXTLEN
      NEL=LEN(TEXT)
      WHILE (NEL.GT.0)
      IF (TEXT(NEL:NEL).EQ.' ')
      THEN
      NEL=NEL-1
      ELSE
      XWHILE
      CIF
      CWHILE
      CPROC      
N
N      NEW PAGE
      PROC NWPAGE
      COMCON = 0
      PAGENO = PAGENO + 1
      WRITE(NPRINT,'(''1VERSION 5.5 (OCT. 88)'',T58,''SHELTRAN-77'',
     :T122,''PAGE'',I4)') PAGENO
      NEL=NELC(TITLSV,66)
      IF LSTOPT.LE.2
      THEN
      WRITE(NPRINT,'(''0TARGET'',7X,66(A1:))') (TITLSV(KGB),KGB=1,NEL)
      WRITE(NPRINT,'(/'' STM.NO''/)')
      ELSE
      WRITE(NPRINT,'(''0SOURCE'',7X,66(A1:))') (TITLSV(KGB),KGB=1,NEL)
      WRITE(NPRINT,'(/'' SEQ.NO''/)')
      CIF
      CPROC
N
N                                        WRITE SOURCE LIST TRAILER
      PROC STAT
N                              WRITE OPTIONS
      WRITE (NPRINT,401) LINEPP,CHARPL,SOURCE,NBRING
      LINENO=LINENO+1-START
      WRITE (NPRINT,406) ERROR,LINENO -1
      IF NWARN.GT.0
      THEN
      WRITE(NPRINT,601) NWARN
      CIF
      CPROC
N
N      FILL OUTPUT BUFFER
      PROC FILOUT
      FOR I=INIT,LAST
      OUT(LEVEL)=LINE(I)
      LEVEL=LEVEL+1
      CFOR
      CPROC
N
N      CLEAR OUTPUT BUFFER
      PROC BLKOUT
      FOR I=1,124
      OUT(I)=BLANK
      CFOR
      CPROC
N
N      COLUMNS 2 ... 6
      PROC CC26
      FOR I=6,2,-1
      IF LINE(I).NE.BLANK
      THEN
      INIT=I
      CIF
      CFOR
      LENG=LAST-INIT+1
      CPROC
      END
N        CLASSIFIES SHELTRAN  STATEMENTS BY THEIR FIRST
N     SOURCE LINE.
N
      SUBROUTINE CLASS
N
      SAVE
      CHARACTER*1 NCHAR(80) ,CPARM(66)
      COMMON /BLINE/NCHAR
      COMMON /BPARM/NPARM(66)
      COMMON/CHPARM/ CPARM
      COMMON /BLIST/NPOS,LSTOPT,LINEPP,NPRINT
       LOGICAL NEXIT
      COMMON /BPARS/NTYPE,NTARGT,NEXIT,NOUT,LUOUT
N
      INTEGER SUM, KGB
N                                        TEMPORARY CHARACTER STORE
      CHARACTER*1 CHARI
      CHARACTER*1 BLANK,OPBRT,CLBRT
      CHARACTER*1 COMMA,AMPST,EQUAL
      INTEGER POSIT(8),DELIM
      CHARACTER*1 KW(4,2)
N LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU
      LOGICAL COMFLG
      DATA BLANK/' '/,OPBRT/'('/,CLBRT/')'/
      DATA COMMA/','/
      DATA AMPST/'*'/,EQUAL/'='/
      DATA KW/'E','R','R','=','E','N','D','='/
E
      NPOS = 7
      NTYPE = KEYWD1(NPOS)
N                                        SET PARAMETERS TO ZERO
      FOR I=1,66
         NPARM(I) = 0
      CFOR
N                 SUPLEMENTARY CHECKS
      SELECT NTYPE
N                                       FIND CASE PARAMETER
      CASE 15
         SUM = 0
         J = 1
         FOR N = NPOS,72
N                                        OBTAIN WORKING CHARACTER
            IN = DELIM (NCHAR(N))
N                                        CLASSIFY CHARACTER
            SELECT IN
N      SKIP IF BLANK
            CASE 1
N                                        COMMA
            CASE 4
      IF SUM.EQ.0
                                 THEN
N                                        SET ERROR AND EXIT
      NTYPE=101
      XFOR
      ELSE
N                                        STORE PARAMETER
               NPARM(J) = SUM
N                                        START ON NEXT PARAMETER
               J = J + 1
               SUM = 0
      CIF
N                                        DIGIT
            CASE 8,9,10,11,12,13,14,15,16,17
               SUM = 10 * SUM + IN - 8
            OTHER
N                                        WRONG CHARACTER: ERROR
               NTYPE = 101
      XFOR
      CSELECT
      CFOR
N     STORE LAST PARAMETER
      NPARM(J)=SUM
         NPOS = N
N     FOR; MUST BE FOLLOWED BY '=' AND AT LEAST 1 COMMA
      CASE 11
      REPEAT
      NPOS=NPOS+1
      CHARI=NCHAR(NPOS)
      UNTIL CHARI.EQ.EQUAL.OR.CHARI.EQ.OPBRT.OR.NPOS.GE.70
      IF CHARI.EQ.EQUAL.AND.NPOS.LE.70
      THEN
      KGB=0
      REPEAT
      NPOS=NPOS+1
      CHARI=NCHAR(NPOS)
      IF CHARI.EQ.OPBRT
      THEN
      KGB=KGB+1
      ELSEIF CHARI.EQ.CLBRT
      THEN
      KGB=KGB-1
      CIF
      UNTIL (CHARI.EQ.COMMA.AND.KGB.EQ.0).OR.(NPOS.GE.72)
      IF CHARI.NE.COMMA.OR.KGB.NE.0
      THEN
      NTYPE=2
      CIF
      ELSE
      NTYPE=2
      CIF
N      SCAN I/O PARAMETERS
      CASE 22
      N1=0
      NKW=0
      REPEAT
      NKW=NKW+1
      PERFORM ENDERR
      IF KWIND.EQ.5
      THEN
      N1=N1+1
      POSIT(N1)=NPER
      CIF
      UNTIL NKW.EQ.2
N      END= AND ERR= ABSENT?
      IF N1.EQ.0
      THEN
N      --> FORTRAN
      NTYPE=2
      ELSE
N      END= AND ERR= KEYWDS OUT OF ORDER?
      IF N1.EQ.2 .AND. POSIT(1).GT.POSIT(2)
      THEN
      POSIT(3)=POSIT(1)
      POSIT(1)=POSIT(2)
      POSIT(2)=POSIT(3)
      CIF
N     --> FILL ARRAY NPARM TO BE USED BY THE PARSER
      PERFORM PRMFIL
      CIF
N     CALL;IS THERE A '*' ,OTHERWISE FORTRAN
      CASE 30
      N1=0
      COMFLG=.TRUE.
      REPEAT
      NPOS=NPOS+1
      CHARI = NCHAR(NPOS)
      UNTIL CHARI.EQ.OPBRT.OR.NPOS.GE.70
N     SCAN FOR SUCCESSIVE '*'S
      REPEAT
      NPOS=NPOS+1
      CHARI = NCHAR(NPOS)
      IF CHARI.EQ.AMPST.AND.NPOS.LE.70
      THEN
N     IS '*' PRECEDED BY '(' OR ','
      IF COMFLG
      THEN
N     SET LOOP COUNTER FOR PROCEDURE PRMFIL
      N1=N1+1
N     STORE POSITION OF '*'
      POSIT(N1)=NPOS
      COMFLG=.FALSE.
      CIF
      ELSE
      IF CHARI.NE.BLANK.AND.COMFLG
      THEN
      COMFLG=.FALSE.
      ELSE
      IF CHARI.EQ.COMMA
      THEN
N     SET COMMA-FLAG
      COMFLG=.TRUE.
      CIF
      CIF
      CIF
      UNTIL N1.EQ.8.OR.NPOS.GE.70
      SELECT N1
N     CALL WITH '*'
      CASE 1,2,3,4,5,6,7
      PERFORM PRMFIL
N     IN FURTHER PROCESSING THERE IS NO DIFFERENCE
N     BETWEEN READ AND CALL WITH SHELTRAN PARAMETERS
      NTYPE=22
N     ONLY 7 '*' PARAMETERS ARE ALLOWED
      CASE 8
N     SET ERROR-TYPE FOR ERROR-MESSAGE
      NTYPE=104
      OTHER
      NTYPE=2
      CSELECT
      OTHER
      CSELECT
N                                        STATEMENT CLASSIFIED
      RETURN
N
N     DETERMINE POSITION OF END= AND ERR=
      PROC ENDERR
      KWIND=1
      NPER=NPOS
      REPEAT
      NPER=NPER+1
      IF NCHAR(NPER).EQ.OPBRT
N     SKIP PARENTHESIZED CONTRUCTS
      THEN
      KWIND=1
      REPEAT
      NPER=NPER+1
      UNTIL NCHAR(NPER).EQ.CLBRT.OR.NPER.GE.70
      ELSE
N      BLANKS ARE INSIGNIFICANT
      IF NCHAR(NPER).NE.BLANK
      THEN
      IF ( LTU( NCHAR(NPER) ) .EQ. KW(KWIND,NKW) )
      THEN
      KWIND=KWIND+1
      ELSE
      KWIND=1
      CIF
      CIF
      CIF
      UNTIL KWIND.EQ.5.OR.NPER.GE.70
      CPROC
N
N      FILL ARRAY NPARM, TO BE USED BY THE PARSER
      PROC PRMFIL
         I = 8
      FOR N=1,N1
      J=(N-1)*9
      I=I-1
N                                        SET BEGIN POINTER
      NPARM(J+2)=I
N                                        SET END POINTER
      NPARM(J+3)=POSIT(N)
      I=POSIT(N)+1
N                                        SAVE POINTER FOR PROC NAME COPY
            L = I - 4
N                                        LOOKUP KIND
            M = KEYWD2(I)
N                                        SET KIND
      NPARM(J+1)=M
      IF M.EQ.6
N     PROCEDURE NAME
            THEN
N                                        COPY PROC NAME
               K = 4
               WHILE K .LE. 34
                  IF K .LT. I - L - 1
                  THEN
N                                        DO NOT COPY BLANKS
      CHARI = LTU( NCHAR(K+L) )
      IF CHARI.NE.BLANK
                     THEN
      CPARM(J+K)=CHARI
                     ELSE
                        K = K - 1
                        L = L + 1
      CIF
                  ELSE
N                                        TRAIL WITH BLANKS
      CPARM(J+K)=BLANK
      CIF
                  K = K + 1
      CWHILE
      CIF
      CFOR
      J=J+9
      NPARM(J+1)=0
      NPARM(J+2)=I-1
N                                        SET END POINTER
      NPARM(J+3)=72
         NPOS = I
      CPROC
      END
N          CLASSIFY STRING OF CHARACTERS AS ONE OF A SET OF
N     KEYWORDS
N
      FUNCTION KEYWD1(POS)
N
      CHARACTER*1 NCHAR(80)
      COMMON /BLINE/NCHAR
      CHARACTER*1 CHARI
      CHARACTER*1 BLANK,OPBRT,CLBRT,EQUAL,COMMA
      INTEGER POS
      CHARACTER*1 TREE(156)
      INTEGER MATCH(156),FAIL(156)
N LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU
      DATA BLANK/' '/,OPBRT/'('/,CLBRT/')'/,EQUAL/'='/,COMMA/','/
E                     1   2   3   4   5   6   7   8   9  10
N                                        TREE
     0DATA  TREE  / 'I','F','T','H','E','N','E','L','S','E',
     1              'N','T','R','Y','D',' ','A','L','L','S',
     2              'E','I','F','W','H','I','L','E','P','R',
     3              'O','C','F','O','R','S','E','L','E','C',
     4              'T','P','E','R','F','O','R','M','R','O',
     5              'C','W','H','I','L','E','F','O','R',' ',
     6              ' ',' ','(','S','E','L','E','C','T','T',
     7              'O','P','R','E','P','E','A','T','T','U',
     8              'R','N','A','D','X','W','H','I','L','E',
     9              'F','O','R','R','E','P','E','A','T','U',
     A              'N','T','I','L','O','T','H','E','R',' ',
     B              'B','A','C','K','S','P','A','C','E','(',
     C              'C','L','O','S','E','(','P','E','N','(',
     D              'F','I','L','E','(','N','Q','U','I','R',
     E              'E','(','R','I','T','E','(','W','I','N',
     F              'D','(','I','F','I','F'/
N                                        MATCH POINTERS
     0DATA  MATCH /   2,110,  4,  5,  6, -5,  8,  9, 10,155,
     1               12, 13, 14,-27,131,000, 18, 19,-30, 21,
     2              -15, 23, -7, 25, 26, 27, 28,-10, 30, 31,
     3               32,-24, 34, 35,-13, 37, 38, 39, 40, 41,
     4              -17, 43, 44, 45, 46, 47, 48,-21, 50, 51,
     5              -23, 53, 54, 55, 56, 60, 58, 59,-11, -8,
     6              -14,-18,-22, 65, 66, 67, 68, 69, 61, 71,
     7               72,-26, 74, 75, 76, 77, 78,-20, 80, 81,
     8               82,-25, 84, 63, 86, 87, 88, 89, 90, -9,
     9               92, 93,-12, 95, 96, 97, 98, 99,-19,101,
     A              102,103,104, 62,106,107,108,109,-16, -4,
     B              112,113,114,115,116,117,118,119,120,-22,
     C              122,123,124,125,126,-22,128,129,130,-22,
     D              132,133,134,135,-22,137,138,139,140,141,
     E              142,-22,144,145,146,147,-22,149,150,151,
     F              152,-22,154, -7,156,-31/
N                                        FAIL POINTERS
     0DATA  FAIL  /   3,136,  7, -2, -2, -2,121, 11, -2, -2,
     1               -2, 15, -2, -2, -2,000, 22, 20, -2, -2,
     2               -2, 24, -2, 29, -2, -2, -2, -2, 33, -2,
     3               -2, -2, 36, -2, -2, -2, -2, -2, -2, -2,
     4               -2, 52, 49, -2, -2, -2, -2, -2, -2, -2,
     5               -2, 57,143, -2, -2, -2, 64, -2, -2, -2,
     6               -2, -2, -2, 73, 70, -2, -2, -2, -2, -2,
     7               -2, -2, 85, -2, 79, -2, -2, -2, 83, -2,
     8               -2, -2,148, -2,100, 91, -2, -2, -2, -2,
     9               94, -2, -2, -2, -2, -2, -2, -2, -2,105,
     A               -2, -2, -2, -2,111,127, -2, -2, -2, -2,
     B               -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
     C               42, 17, -2, -2, -2, -2, -2, -2, -2, -2,
     D              153, -2, -2, -2, -2, -2, -2, -2, -2, -2,
     E               -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
     F               -2, -2,-28, -2, -6, -2/
E
N
N
N.....................................................................
N
N                                        SHELTRAN KEYWORDS
N***********************************************************************
N*                                                                     *
N*    SORTS STATEMENTS INTO  31 CLASSES                                *
N*                                                                     *
N*    TYPE CODES -                                                     *
N*                                                                     *
N     01 COMMENT  2 FORTRAN    3 CONTINUATION  4 IF
N     05 THEN     6 ELSE       7 CIF           8 WHILE
N     09 XWHILE  10 CWHILE    11 FOR          12 XFOR
N     13 CFOR    14 SELECT    15 CASE         16 OTHER
N     17 CSELECT 18 UNTIL     19 XREPEAT      20 REPEAT
N     21 PERFORM 22 READ      23 PROC         24 CPROC
N     25 RETURN  26 STOP      27 ENTRY        28 END
N     29 FORMAT  30 CALL      22 OPEN(        22 ENDFILE(
N     22 INQUIRE 22 WRITE     22 CLOSE(       22 BACKSPACE(
N     22 REWIND(  7 ENDIF     31 ELSEIF
N    >=101 ERROR
N*                                                                     *
E
N      K E Y W O R D        CLASS   ENTRY
N
N      I F                    4       1
N      . N Q U I R E (       22     136
N      T H E N                5       3
N      E L S E                6       7
N      . . . . I F           31     153
N      . N T R Y             27      11
N      . . D                 28      15
N      . . . F I L E (       22     131
N      . . . I F              7     155
N      C L O S E (           22     121
N      . A L L               30      17
N      . . S E               15      20
N      . I F                  7      22
N      . W H I L E           10      24
N      . P R O C             24      29
N      . F O R               13      33
N      . S E L E C T         17      36
N      P E R F O R M         21      42
N      . R O C               23      49
N      W H I L E              8      52
N      . R I T E (           22     143
N      F O R                 11      57
N      S E L E C T           14      64
N      . T O P               26      70
N      R E P E A T           20      73
N      . . T U R N           25      79
N      . . W I N D (         22     148
N      . . A D (             22      83
N      X W H I L E            9      85
N      . F O R               12      91
N      . R E P E A T         19      94
N      U N T I L             18     100
N      O T H E R             16     105
N      . P E N (             22     127
N      B A C K S P A C E (   22     111
N
E
      J = 1
      I = POS
N                                        SCAN UNTIL END OF LINE
      WHILE  I .LE. 72
           CHARI = LTU( NCHAR(I) )
N                                        CLASSIFY CHARACTER,
      IF CHARI.EQ.TREE(J)
           THEN
N                                        MATCH, TAKE NEXT CHARACTER,
                     J = MATCH(J)
                I = I + 1
           ELSE
N                                        SKIP BLANKS
      IF CHARI.EQ.BLANK
                THEN
                     I = I + 1
                ELSE
N                                        NO MATCH,  TRY AGAIN
                     J = FAIL(J)
      CIF
      CIF
N                                        IF END OF TREE,
                IF  J .LE. 0
                THEN
N                                        RETURN CLASS VALUE AND STOP
      KEYWD1=-J
      XWHILE
      CIF
      CWHILE
N                                        IF AT END OF LINE WHILE END OF
N                                        TREE NOT YET BEEN REACHED,
      IF  J .GE. 0
      THEN
      IF J.EQ.1.AND.NCHAR(6).EQ.BLANK
      THEN
N      BLANK LINE; TREAT AS COMMENT
      KEYWD1=110
      ELSE
N      SCAN REMAINDER OF FAIL POINTERS
      WHILE J.GT.0
N      UNTIL STMT CLASSIFIED
      J=FAIL(J)
      CWHILE
      KEYWD1=-J
      CIF
      CIF
N
N
      SELECT KEYWD1
N     THEN,ELSE,CIF,XWHILE,CWHILE,XFOR,CFOR,OTHER,
      CASE 5,6,7,9,10,12,13,16,17,19,20,24,25,28
N     CSELECT,XREPEAT,REPEAT,CPROC,RETURN,END,
      WHILE I.LE.72
N      ENDIF.
      CHARI = NCHAR(I)
      IF CHARI.EQ.BLANK
      THEN
      I=I+1
      ELSE
      IF KEYWD1.EQ.25.AND.CHARI.NE.OPBRT.AND.CHARI.NE.EQUAL
      THEN
N      RETURN NOT FOLLOWED BY'='OR'(': ILLEGAL STMT
      KEYWD1=101
      ELSE
N     ASSUME FORTRAN STMT IF NOT FOLLOWED BY BLANKS
      KEYWD1=2
      CIF
      XWHILE
      CIF
      CWHILE
N     CASE,PERFORM,PROC,STOP,ENTRY
      CASE 15,21,23,26,27
      IF I.LE.72
      THEN
      FOR J=I,72
      CHARI=NCHAR(J)
      IF CHARI.EQ.EQUAL
      THEN
      KEYWD1=2
      XFOR
      CIF
      CFOR
      ELSE
N     CASE,PERFORM AND PROC MUST BE FOLLOWED BY AT LEAST
      IF KEYWD1.LE.23
N     ONE CHARACTER
      THEN
      KEYWD1=2
      CIF
      CIF
N     2       4  8     14     18    22    30   11
N     FORTRAN,IF,WHILE,SELECT,UNTIL,READ(,CALL,FOR
N     22      22      22     22     22    22
N     INQUIRE,ENDFILE,CLOSE(,WRITE(,OPEN(,BACKSPACE(
N      31
N      ELSEIF
      OTHER
      CSELECT
N
N                                        RETURN NEXT SCAN POSITION
      POS = I
      RETURN
      END
N          CLASSIFY STRING OF CHARACTERS AS ONE OF A SET OF
N     KEYWORDS AFTER END=,ERR= (I/O) OR * (CALL)
      FUNCTION KEYWD2(POS)
N
      CHARACTER*1 NCHAR(80)
      COMMON /BLINE/NCHAR
      CHARACTER*1 CHARI
      CHARACTER*1 BLANK,OPBRT,CLBRT,EQUAL,COMMA
      INTEGER POS
      CHARACTER*1 TREE(35)
      INTEGER MATCH(35),FAIL(35)
N LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU
      DATA BLANK/' '/,OPBRT/'('/,CLBRT/')'/,EQUAL/'='/,COMMA/','/
E                     1   2   3   4   5   6   7   8   9  10
N                                        TREE
      DATA  TREE  / 'X','F','O','R',',',')','W','H','I','L',
     *              'E',',',')','R','E','T','U','R','N',',',
     *              ')','S','T','O','P',',',')','R','E','P',
     *              'E','A','T',',',')'/
N                                        MATCH POINTERS
      DATA  MATCH /   2,  3,  4,  5, -3, -3,  8,  9, 10, 11,
     *               12, -4, -4, 15, 16, 17, 18, 19, 20, -1,
     *               -1, 23, 24, 25, 26, -2, -2, 29, 30, 31,
     *               32, 33, 34, -5, -5/
N                                        FAIL POINTERS
      DATA  FAIL  /  14,  7, -6, -6,  6, -6, 28, -6, -6, -6,
     *               -6, 13, -6, 22, -6, -6, -6, -6, -6, 21,
     *               -6, -6, -6, -6, -6, 27, -6, -6, -6, -6,
     *               -6, -6, -6, 35, -6/
N      IN THE FOLLOWING TABLE * STANDS FOR ',' OR ')'
N
N      K E Y W O R D    CLASS  ENTRY
N
N      X F O R *         3       1
N      . W H I L E *     4       7
N      . R E P E A T *   5      28
N      R E T U R N *     1      14
N      S T O P *         2      22
N
E
      J = 1
      I = POS
N                                        SCAN UNTIL END OF LINE
      WHILE  I .LE. 72
           CHARI = LTU( NCHAR(I) )
N                                        SKIP BLANKS
      IF CHARI.EQ.BLANK
           THEN
                I = I + 1
           ELSE
N                                        CLASSIFY CHARACTER,
      IF CHARI.EQ.TREE(J)
                THEN
N                                        MATCH, TAKE NEXT CHARACTER,
                     J = MATCH(J)
                     I = I + 1
                ELSE
N                                        NO MATCH,  TRY AGAIN
                     J = FAIL(J)
      CIF
N                                        IF END OF TREE,
                IF  J .LE. 0
                THEN
N                                        RETURN CLASS VALUE AND STOP
      KEYWD2=-J
      XWHILE
      CIF
      CIF
      CWHILE
N                                        IF AT END OF LINE WHILE END OF
N                                        TREE NOT YET BEEN REACHED,
      IF  J .GE. 0
      THEN
N     ASSUME PROCEDURE NAME
      KEYWD2=6
      CIF
N
N
N                                        IF NO KEYWORD FOUND, CONTINUE
      IF  J .EQ. -6
      THEN
N                                        SCAN UNTIL , OR )
           WHILE  I .LE. 72
                CHARI = NCHAR(I)
                     I = I + 1
      IF CHARI.EQ.COMMA .OR. CHARI.EQ.CLBRT
                THEN
      XWHILE
      CIF
      CWHILE
      CIF
N
N                                        RETURN NEXT SCAN POSITION
      POS = I
      RETURN
      END
N          DELIM
N          CLASSIFY CHARACTER AS ONE OF A SET OF DELIMITERS
N
      INTEGER FUNCTION  DELIM (CHARI)
N
N
      CHARACTER*1 IDELIM(17),CHARI
      DATA       IDELIM  / ' ','(',')',',','=','/',' ',
     1                     '0','1','2','3','4','5','6','7','8','9' /
      DELIM = 0
N                                        LOOP OVER ARRAY OF DELIMITERS
      FOR  I = 1,17
      IF CHARI.EQ.IDELIM(I)
           THEN
N                                        RETURN INDEX AS FUNCTION VALUE
                DELIM = I
      XFOR
      CIF
      CFOR
      RETURN
      END
N        PARSER
N          CHECKS THE SYNTAX OF SHELTRAN SOURCE,AND GENERATES
N     FORTRAN 77 STATEMENTS FOR IT.
N     THE PARSER IS A FINITE STATE MACHINE
N
      SUBROUTINE PARSER
      SAVE
N
N      NUMBER OF TYPES -- NUMBER OF POSSIBLE STATES
N      -- STACK DEPTH
      PARAMETER (NTYPES=30,NSTATE=17,NSTACK=32)
      LOGICAL NEXIT
      CHARACTER*1 LINE(80),CPARM(66)
      COMMON /BLINE/LINE
      COMMON /BPARM/NPARM(66)
      COMMON/CHPARM/ CPARM
      INTEGER TYPE
      COMMON /BPARS/TYPE,NTARGT,NEXIT,NOUT,LUOUT
N                                        EXIT FLAG
      LOGICAL RETFL
      LOGICAL STPFL
N
      INTEGER LAB(7)
N                                        STATE INDICATOR
      INTEGER   STATE
N                                        STATE STACK POINTER
      INTEGER   STPTR
N                                        STATE STACK
      INTEGER   STSTK(NSTACK)
N                                        STATE ACTION TABLE
      INTEGER ACTAB(NSTATE,NTYPES)
      INTEGER PART1(NSTATE,15),PART2(NSTATE,NTYPES-15)

      EQUIVALENCE (ACTAB(1,1),PART1(1,1))
      EQUIVALENCE (ACTAB(1,16),PART2(1,1))
      DATA RETFL/.TRUE./,STPFL/.TRUE./
      DATA STATE/1/,STPTR/0/
N
N
      DATA PART1/
C         1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
C
N      FORTRAN LINE
     1    7,48,48, 7,48, 7,33, 7,37, 7, 7, 7,28,39, 7, 7,34,
N      CONTINUATION LINE
     2    9,48,48, 9,48, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
N     IF
     3   29,48,48,29,48,29,33,29,37,29,29,29,28,39,29,29,34,
N     THEN
     4    0,48,48, 0,48, 0,33, 0,37, 0, 0, 0,28,30, 0, 0,34,
N     ELSE
     5    0,48,20, 0,48, 0,33, 0,37, 0, 0, 0,28,39,31, 0,34,
N     CIF
     6    0,48,20, 0,48, 0,33, 0,37, 0, 0, 0,28,39,32,32,34,
N     WHILE
     7   19,48,48,19,48,19,33,19,37,19,19,19,28,39,19,19,34,
N     XWHILE
     8    3,48,48, 0,48, 3,33, 3,37, 3, 3, 3,28,39, 3, 3,34,
N     CWHILE
     9    0,48,20, 0,48, 0,33,21,37, 0, 0, 0,28,39, 0, 0,34,
N     FOR
     A   17,48,48,17,48,17,33,17,37,17,17,17,28,39,17,17,34,
N     XFOR
     1    4,48,48, 0,48, 4,33, 4,37, 4, 4, 4,28,39, 4, 4,34,
N     CFOR
     2    0,48,20, 0,48,18,33, 0,37, 0, 0, 0,28,39, 0, 0,34,
N     SELECT
     3   22,48,48,22,48,22,33,22,37,22,22,22,28,39,22,22,34,
N     CASE
     4    0,48,20, 0,48, 0,33, 0,13,23, 0, 0,28,39, 0, 0,34,
N     OTHER
     5    0,48,20, 0,48, 0,33, 0,37,24, 0, 0,28,39, 0, 0,34/
E
      DATA PART2/
C         1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
C
N     CSELECT
     6    0,48,20, 0,48, 0,33, 0,37, 0,25, 0,28,39, 0, 0,34,
N     UNTIL
     7    0,48,20, 0,48, 0,33, 0,37, 0, 0,27,28,39, 0, 0,34,
N     XREPEAT
     8    6,48,48, 0,48, 6,33, 6,37, 6, 6, 6,28,39, 6, 6,34,
N     REPEAT
     9   26,48,48,26,48,26,33,26,37,26,26,26,28,39,26,26,34,
N     PERFORM
     B    1,48,48, 1,48, 1,33, 1,37, 1, 1, 1,28,39, 1, 1,34,
N     I/O STATEMENT
     1    2,48,48, 2,48, 2,33, 2,37, 2, 2, 2,28,39, 2, 2,34,
N     PROC
     2   12,14,48,40,14, 0,33, 0,37, 0, 0, 0,28,39, 0, 0,34,
N     CPROC
     3    0,48,48,15,48, 0,33, 0,37, 0, 0, 0,28,39, 0, 0,34,
N     RETURN
     4   11,48,48, 0,48, 5,33, 5,37, 5, 5, 5,28,39, 5, 5,34,
N     STOP
     5   11,48,48, 0,48, 5,33, 5,37, 5, 5, 5,28,39, 5, 5,34,
N     ENTRY
     6   12,10,48,40,48, 0,33, 0,37, 0, 0, 0,28,39, 0, 0,34,
N     END
     7   12,16,20,40,16,41,33,42,37,43,44,45,28,39,46,46,34,
N     FORMAT
     8    7, 7, 0, 7, 7, 7,33, 7,37, 7, 7, 7,28,39, 7, 7,34,
N     'SPECIAL'
     9    0, 1, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
N     ELSEIF
     C    0,48,20, 0,48, 0,33, 0,37, 0, 0, 0,28,39,35, 0,34/
N
N
      NEXIT=.FALSE.
      RETURN
E
      ENTRY PARSE
N
N
      WHILE .TRUE.
      SELECT ACTAB(STATE,TYPE-1)
      CASE 1
N                                  ***   PERFORM   STATEMENT
         CALL PFORM
      XWHILE
      CASE 2
N                                  ***   READ      STATEMENT
         PERFORM DOREAD
         PERFORM STACK
         STATE = 17
      XWHILE
      CASE 3
N                                  ***   XWHILE    STATEMENT
         PERFORM STACK
         STATE = 3
      CALL LEAVE
      XWHILE
      CASE 4
N                                  ***   XFOR      STATEMENT
         PERFORM STACK
         STATE = 3
      CALL DOEXIT
      XWHILE
      CASE 5
N                                  ***   RETURN    STATEMENT
N                                  ***   STOP      STATEMENT
         PERFORM STACK
         STATE = 3
      CALL CARD
      XWHILE
      CASE 6
N                                   ***  XREPEAT    STATEMENT
         PERFORM STACK
         STATE = 3
      CALL XUNTIL
      XWHILE
      CASE 7
N                                  ***   FORTRAN   STATEMENT
      CALL CARD
      XWHILE
      CASE 9
N      CONTINUATION LINE
         CALL CCARD
      XWHILE
      CASE 10
N                                  ***   ENTRY     STATEMENT
         STATE = 1
         CALL CARD
N                                        CLEAR EXIT FLAG
         NEXIT = .FALSE.
      XWHILE
      CASE 11
N                                  ***   RETURN    STATEMENT
N                                  ***   STOP      STATEMENT
         STATE = 2
         CALL CARD
      XWHILE
      CASE 12
N                                  ***   END AT WRONG PLACE
N                                        ERROR HANDLING
      CALL ERRMSG('STOP OR RETURN ARE MISSING                        ')
         STATE = 2
      CASE 13
N                                  ***   STATEMENT  AFTER SELECT
         STATE = 10
      CALL CONSEL
      XWHILE
      CASE 14
N                                  ***   PROC      STATEMENT
         STATE = 4
      CALL PROC
      XWHILE
      CASE 15
N                                  ***   CPROC      STATEMENT
         STATE = 5
      CALL PEND
      XWHILE
      CASE 16
N                                  ***   END       STATEMENT
         PERFORM END
      XWHILE
      CASE 17
N                                  ***   FOR       STATEMENT
         PERFORM STACK
         STATE = 6
      CALL FOR
      XWHILE
      CASE 18
N                                  ***   CFOR      STATEMENT
         PERFORM UNSTK
      CALL NEXT
      XWHILE
      CASE 19
N                                  ***   WHILE     STATEMENT
         PERFORM STACK
         STATE = 7
      CALL DOWHI
      XWHILE
      CASE 20
N                                  ***   AFTER XFOR,XWHILE,RETURN, STOP
N                                        OR XREPEAT
         PERFORM UNSTK
N                                        SET EXIT FLAG
         NEXIT = .TRUE.
      CASE 21
N                                  ***   CWHILE    STATEMENT
            PERFORM UNSTK
      CALL REP EAT
      XWHILE
      CASE 22
N                                  ***   SELECT    STATEMENT
         PERFORM STACK
         STATE = 9
      CALL DOSEL
      XWHILE
      CASE 23
N                                  ***   CASE      STATEMENT
      CALL DOCASE
N                                        CLEAR EXIT FLAG
         NEXIT = .FALSE.
      XWHILE
      CASE 24
N                                  ***   OTHER     STATEMENT
         STATE = 11
      CALL OTHER
N                                        CLEAR EXIT FLAG
         NEXIT = .FALSE.
      XWHILE
      CASE 25
N                                  ***   CSELECT    STATEMENT
         PERFORM UNSTK
      CALL REVERT
      XWHILE
      CASE 26
N                                  ***  REPEAT STATEMENT
         PERFORM STACK
         STATE = 12
      CALL C UNTIL
      XWHILE
      CASE 27
N                                  ***  UNTIL STATEMENT
         STATE = 13
      CALL DO UNTL
      XWHILE
      CASE 28
N                                   ***  STATEMENT AFTER UNTIL
         PERFORM UNSTK
      CALL CO UNTL
      CASE 29
N                                  ***   IF        STATEMENT
         PERFORM STACK
         STATE = 14
      CALL DOIF
      XWHILE
      CASE 30
N                                  ***   THEN      STATEMENT
         STATE = 15
      CALL THEN
      XWHILE
      CASE 31
N                                  ***   ELSE      STATEMENT
         STATE = 16
      CALL ELSE
N                                        CLEAR EXIT FLAG
         NEXIT = .FALSE.
      XWHILE
      CASE 32
N                                  ***   CIF       STATEMENT
         PERFORM UNSTK
      CALL FIN
      XWHILE
      CASE 33
N                                  ***   STATEMENT AFTER WHILE
         STATE = 8
      CALL CWHILE
N                                  ***   FIRST STATEMENT AFTER READ
      CASE 34
         PERFORM UNSTK
      CALL COREAD
N      ***   ELSEIF STATEMENT
      CASE 35
      STATE=14
      CALL ELSEIF
      NEXIT=.FALSE.
      XWHILE
N                                  ***   ERROR HANDLING
N                                        & ERROR RECOVERING
      CASE 37
      CALL ERRMSG('SELECT REJECTED, NOT FOLLOWED BY CASE             ')
      CALL REVERT
         PERFORM UNSTK
      CASE 39
      CALL ERRMSG('IF REJECTED, NOT FOLLOWED BY THEN                 ')
      CALL FIN
         PERFORM UNSTK
      CASE 40
      CALL ERRMSG('CPROC IS MISSING                                  ')
         STATE = 5
      CALL PEND
      CASE 41
      CALL ERRMSG('CFOR IS MISSING                                   ')
         PERFORM UNSTK
      CALL NEXT
      CASE 42
      CALL ERRMSG('CWHILE IS MISSING                                 ')
      PERFORM UNSTK
      CALL REP EAT
      CASE 43
         STATE = 11
      CALL ERRMSG('OTHER IS MISSING                                  ')
      CALL OTHER
         NEXIT = .FALSE.
      CASE 44
      CALL ERRMSG('CSELECT IS MISSING                                ')
         PERFORM UNSTK
      CALL REVERT
      CASE 45
      CALL ERRMSG('UNTIL IS MISSING                                  ')
         PERFORM UNSTK
      CALL CO UNTL
      CASE 46
      CALL ERRMSG('CIF IS MISSING                                    ')
         PERFORM UNSTK
      CALL FIN
      CASE 48
      CALL ERRMSG('STATEMENT CANNOT BE REACHED                       ')
      STATE=STATE-ACTAB(STATE,29)
      XWHILE
      OTHER
N                                   ***  ERROR
      STATE=STATE-ACTAB(STATE,29)
      CALL ERRMSG('ILLEGAL IN THIS CONTEXT                           ')
      XWHILE
      CSELECT
      CWHILE
      RETURN
E
      PROC STACK
         STPTR = STPTR + 1
N                                        CHECK STACK OVERFLOW
         IF STPTR .GT. NSTACK
         THEN
      CALL ERRMSG('NESTING TOO DEEP; FATAL ERROR                     ')
      CALL ABORT
      CIF
N                                        ASSIGN NEW STATE
         STSTK(STPTR) = STATE
      CPROC
N
N                                        UNSTACK STATE
      PROC UNSTK
N                                        ASSIGN NEW STATE
         STATE = STSTK(STPTR)
         STPTR = STPTR - 1
N                                        CLEAR EXIT FLAG
         NEXIT = .FALSE.
      CPROC
N
N                                        END STATEMENT HANDLING
      PROC END
         STATE = 1
N                                        CLEAR THE MACHINES
         CALL CCLEAR
         CALL LCLEAR
         CALL PCLEAR
         CALL UCLEAR
         CALL WCLEAR
N                                        CLEAR EXIT FLAG
         NEXIT = .FALSE.
         RETFL = .TRUE.
         STPFL = .TRUE.
      STPTR=0
N                                        PASS STATEMENT TO OUTPUT
         CALL CARD
N                                        WRITE SEGMENT TRAILER
      CALL TRAIL
      CPROC
E
N                    LABEL IN I/O STMT OR CALL
      PROC DOREAD
N
N        MAP OF NPARM
N        ------------
N           NPARM(1)        KIND
N           NPARM(2)        7
N           NPARM(3)        POSITION OF '=' OR '*'  OR 72
N           CPARM(4-9)      PROC NAME
N           NPARM(10)       KIND
N           NPARM(11)       POSITION OF ',' OR ')'
N           NPARM(12)       POSITION OF '=' OR '*'  OR 72
N           CPARM(13-18)    PROC NAME
N          ETC.
N           NPARM(64)       0
N           NPARM(65)       POSITION OF ',' OR ')'
N           NPARM(66)       72
N
N        KIND INDICATION
N           0     NO EXIT PARAMETER
N           1     RETURN
N           2     STOP
N           3     XFOR
N           4     XWHILE
N           5     XREPEAT
N           6     PROC NAME
N
         J = 1
      JJ=1
      WHILE NPARM(JJ).GT.0
      SELECT NPARM(JJ)
N                                        RETURN
            CASE 1
N                                        ASSIGN LABEL
               LAB(J) = 10 000
N                                        GENERATE RETURN
               IF RETFL
               THEN
                  RETFL = .FALSE.
      K=LAB(J)
      L=K+1
      CALL GOTO(L)
      CALL RETRN(K)
      CALL LABEL(L)
      CIF
N                                        STOP
            CASE 2
N                                        ASSIGN LABEL
               LAB(J) = 10 002
N                                        GENERATE STOP
               IF STPFL
               THEN
                  STPFL = .FALSE.
      K=LAB(J)
      L=K+1
      CALL GOTO(L)
      CALL STP(K)
      CALL LABEL(L)
      CIF
N                                        XFOR
            CASE 3
N                                        ASSIGN LABEL
               CALL LREAD(LAB(J))
N                                       XWHILE
            CASE 4
N                                        ASSIGN LABEL
               CALL WREAD(LAB(J))
N                                       XREPEAT
            CASE 5
N                                        ASSIGN LABEL
               CALL UREAD(LAB(J))
N                                        PROC NAME
            CASE 6
N                                        ASSIGN LABEL
      CALL PREAD(CPARM(JJ+3),LAB(J))
            OTHER
      CSELECT
            J = J + 1
      JJ=JJ+9
      CWHILE
N                                        GENERATE STATEMENT
         J = 1
      JJ=1
      WHILE NPARM(JJ).GT.0
            PERFORM GEREAD
N                                        WRITE LABEL
            CALL REDLB(LAB(J))
            J = J + 1
      JJ=JJ+9
      CWHILE
N                                        TAIL OF STATEMENT
         PERFORM GEREAD
      CPROC
N
N
      PROC GEREAD
N                                        COPY PARAMETERS
         K = J - 1
      L=NPARM(JJ+1)
      M=NPARM(JJ+2)
N          GENERATE PART OF I/O STATEMENT OR CALL
         CALL REDTX(K,L,M)
      CPROC
      END
N
N          WRITE A LINE FOR SUBSEQUENT INPUT TO FORTRAN
N     COMPILER
N
      SUBROUTINE WRITER
N     INCREMENT FOR COMMENT & CONTINUATION
      PARAMETER (INCCOM=1,INCCON=1)
N
      LOGICAL NEXIT
      CHARACTER*1 LINE(80)
      COMMON /BLINE/LINE
      COMMON/BPARS/NTYP,NTARGT,NEXIT,NOUT,LUOUT
      CHARACTER*1 NAME(6)
      DIMENSION LABL(*)
      INTEGER     I,KGB,NEL,NELC

      RETURN
E
N      ><  WRITE COMMENT OR CONT. LINE
      ENTRY CCARD
      NEL=NELC(LINE,80)
      WRITE(NTARGT,'(80(A1:))') (LINE(KGB),KGB=1,NEL)
      CALL ICRISN(INCCON)
      RETURN
N
N      ><  WRITE FORTRAN LINE
      ENTRY  CARD
      NEL=NELC(LINE,80)
      WRITE(NTARGT,'(80(A1:))') (LINE(KGB),KGB=1,NEL)
      CALL ICRISN(1)
      RETURN
N
N      ><  WRITE DIRECTLY TO TARGET FILE
      ENTRY FCARD
      NEL=NELC(LINE(2),79)
      WRITE(NTARGT,'(80(A1:))') (LINE(KGB+1),KGB=1,NEL)
      CALL ICRISN(INCCOM)
      RETURN
N
N      ><        IF(.NOT.(
      ENTRY IFNOT
      WRITE(NTARGT,'(5X,A)')             ' IF(.NOT.('
      CALL ICRISN(1)
      RETURN
N
N              ><        GOTO .....
      ENTRY GOTO(L)
      IF .NOT. NEXIT
      THEN
      WRITE(NTARGT,'(5X,A,I5)')          ' GOTO ',L
      CALL ICRISN(1)
      CIF
      RETURN
N
N      ><  ..... CONTINUE
      ENTRY  LABEL (L)
      WRITE(NTARGT,'(I5,A)')           L,' CONTINUE'
      CALL ICRISN(1)
      RETURN
N
N      ><  ..... RETURN
      ENTRY RETRN(L)
      WRITE(NTARGT,'(I5,A)')           L,' RETURN'
      CALL ICRISN(1)
      RETURN
N
N      ><  ..... STOP
      ENTRY STP(L)
      WRITE(NTARGT,'(I5,A)')           L,' STOP'
      CALL ICRISN(1)
      RETURN
N
N      ><  ASSIGN STATEMENT
      ENTRY ASSGN (L,NAME)
      WRITE(NTARGT,'(5X,A,I5,A,6A1)')    ' ASSIGN ',L,' TO ',NAME
      CALL ICRISN(1)
      RETURN
N
N      ><  ASSIGNED GOTO
      ENTRY AGOTO(NAME)
      WRITE(NTARGT,'(5X,A,6A1)')       ' GOTO ',NAME
      CALL ICRISN(1)
      RETURN
N
N      ><  COMPUTED GOTO
      ENTRY CGOTO(N,LABL)
      WRITE(NTARGT,'(5X,A)')                ' GOTO('
      NUM=N
      PERFORM LABELS
      WRITE(NTARGT,'(5X,A)')           '-), IZZZSE'
      CALL ICRISN(1+INCCON)
      RETURN
N
N      ><  TERMINATE GOTO  (AFTER 'IFNOT')
      ENTRY CLGOTO(L)
      WRITE(NTARGT,'(5X,A,I5)')          '-))GOTO ',L
      CALL ICRISN(INCCON)
      RETURN
N
N
N      ><  REMAINDER OF STMT AS CONT. LINE
      ENTRY TXT(K)
      NEL=NELC(LINE(K),73-K)
      WRITE(NTARGT,'(5X,A,80(A1:))') '-',(LINE(I+K-1),I=1,NEL)
      CALL ICRISN(INCCON)
      RETURN
N
N      ><  PART OF I/O STMT WITH EXITS
      ENTRY REDTX(L,K,K1)
      NEL=K1-K+1
      WRITE(NTARGT,'(5X,I1.0,80(A1:))') L,(LINE(I),I=K,K1)
      IF L.EQ.0
      THEN
      CALL ICRISN(1)
      ELSE
      CALL ICRISN(INCCON)
      CIF
      RETURN
N
N
N      ><  EXIT LABEL OF I/O STMT
      ENTRY  REDLB (L)
      WRITE(NTARGT,'(5X,A,I5)')       '-',L
      CALL ICRISN(INCCON)
      RETURN
N
N      ><  DO LOOP
      ENTRY  DOLP  (L,K)
      NEL=NELC(LINE(K),68-K)
      WRITE(NTARGT,'(5X,A,I5,80(A1:))') ' DO ',L,(LINE(I+K-1),I=1,NEL)
      CALL ICRISN(1)
      RETURN
N
N      ><  BLOCK IF
      ENTRY BLKIF
      WRITE(NTARGT,'(5X,A)')             ' IF('
      CALL ICRISN(1)
      RETURN
N
N      ><  THEN
      ENTRY BLKTHN
      WRITE(NTARGT,'(5X,A)')             '-)THEN'
      CALL ICRISN(INCCON)
      RETURN
N
N      ><  ELSE
      ENTRY BLKELS
      WRITE(NTARGT,'(5X,A)')             ' ELSE'
      CALL ICRISN(1)
      RETURN
N
N      ><  ENDIF
      ENTRY BLKCIF
      WRITE(NTARGT,'(5X,A)')             ' ENDIF'
      CALL ICRISN(1)
      RETURN
N
N      ><  ELSEIF
      ENTRY BLKEIF
      WRITE(NTARGT,'(5X,A)')            ' ELSEIF('
      CALL ICRISN(1)
      RETURN
N
N
N      WRITE STMT LABELS FOR CGOTO
      PROC LABELS
      WRITE(NTARGT,1) (LABL(I),I=1,NUM)
    1 FORMAT((5X,'-',11(I5,:,',')))
      CALL ICRISN(((NUM-1)/11+1)*INCCON)
      CPROC
      END
N        IFER
N
N          HANDLES EVERY THING CONCERNING THE
N          IF-THEN-ELSEIF-ELSE-CIF CONSTRUCT
N
      SUBROUTINE IFER
N
      CHARACTER*1 LINE(80)
      COMMON /BLINE/LINE
N LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU

      RETURN
E
N
N                                        ><  IF STATEMENT
      ENTRY DOIF
      CALL BLKIF
      PERFORM CONDIT
      RETURN
N
N                                        ><  THEN STATEMENT
      ENTRY THEN
      CALL BLKTHN
      RETURN
N
N                                        ><  ELSEIF STATEMENT
      ENTRY ELSEIF
      CALL BLKEIF
      PERFORM CONDIT
      RETURN
N
N                                        ><  ELSE STATEMENT
      ENTRY ELSE
      CALL BLKELS
      RETURN
N
N          ><  CIF OR ENDIF STATEMENT
      ENTRY FIN
      CALL BLKCIF
      RETURN
N
N
N     WRITE (FIRST LINE OF) CONDITION
      PROC CONDIT
         I=7
         REPEAT
            I = I + 1
         UNTIL ( LTU( LINE(I) ) .EQ. 'F' )
         I=I+1
         CALL TXT(I)
      CPROC
      END
N        WHILER
N          HANDLES EVERY THING CONCERNING THE WHILE CONSTRUCT
N
      SUBROUTINE WHILER
      SAVE
N
      CHARACTER*1 LINE(80)
      COMMON /BLINE/LINE
N                                        WHILE STACK POINTER
      INTEGER  WHISTP
N                                        WHILE STACK
      INTEGER  WHISTK(32)
N                                        LABEL NUMBER COUNT
      INTEGER  NXTLAB
      INTEGER I
N                                        CHARACTER FOR COMPARISON
      CHARACTER*1 E
N LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU

      DATA WHISTP /0/,NXTLAB /15000/,I /10099/
      DATA E /'E'/
      RETURN
E
N                                        ><  WHILE STATEMENT
      ENTRY DOWHI
N                                        STACK LABEL
         WHISTP = WHISTP + 1
         WHISTK(WHISTP) = NXTLAB
N                                        GENERATE'<LABEL> CONTINUE'
         CALL  LABEL(NXTLAB)
         NXTLAB = NXTLAB + 1
      CALL BLKIF
      I=10
         REPEAT
            I = I + 1
      UNTIL ( LTU( LINE(I) ) .EQ. E )
      I=I+1
      CALL TXT(I)
      RETURN
N
N
N                                        ><  PRODUCE OBJECT LINE
N                                        AT END OF WHILE STATEMENT
      ENTRY CWHILE
      CALL BLKTHN
         NXTLAB = NXTLAB + 1
      RETURN
N
N
N                                       ><  XWHILE STATEMENT
      ENTRY LEAVE
         PERFORM NLEAVE
N                                        GENERATE 'GO TO <LABEL+1>'
      CALL GOTO(I)
      RETURN
N
N
N                                       ><  XWHILE IN I/O STMT OR CALL
      ENTRY WREAD(LAB)
         PERFORM NLEAVE
N                                        COPY LABEL
         LAB = I
      RETURN
N
N
N                                        ><  CWHILE STATEMENT
      ENTRY REPEAT
         I = WHISTK(WHISTP)
      CALL GOTO(I)
         I = I + 1
      CALL BLKCIF
      CALL LABEL(I)
N                                        UNSTACK WHILE
         WHISTP = WHISTP - 1
      RETURN
N
N
N                                        ><  CLEAR WHILE HANDLER
      ENTRY WCLEAR
         WHISTP = 0
N                                        RESET LABEL COUNT
         NXTLAB = 15000
      RETURN
E
      PROC NLEAVE
         IF WHISTP .LE. 0
         THEN
      CALL ERRMSG('NO WHILE CONSTRUCT TO LEAVE                       ')
         ELSE
            I = WHISTK(WHISTP) + 1
      CIF
      CPROC
      END
N        CASER
N          HANDLES EVERYTHING CONCERNING SELECT CONSTRUCTS
N
      SUBROUTINE CASER
      SAVE
N      NUMBER OF CASE LABELS
      PARAMETER (NCASL=500)
N      STACK SIZE
      PARAMETER (NSELCA=33)
N
      CHARACTER*1 LINE(80)
      COMMON /BLINE/LINE
      COMMON /BPARM/NCASV(66)
N                                        LABEL COUNT
      INTEGER   NXTLAB
N                                        SELECT STACK POINTER
      INTEGER  SELPTR
N                                        CASE LABEL LIST START STACK
      INTEGER  SELCAS(NSELCA)
N                                        CASE LABEL LIST
      INTEGER  CASLAB(NCASL)
N                                        NR OF CASE LABEL LIST ENTRIES
      INTEGER  LABMAX
N                                        FIRST CASE LABEL LIST ENTRY
      INTEGER  FIRSTC
N                                        LAST CASE LABEL LIST ENTRY + 1
      INTEGER LASTC
N                                        THIS CASE LABEL LIST ENTRY
      INTEGER  CASENT
N                                        CASE VALUE MAX
      INTEGER  VALMAX
N                                        OTHER LABEL
      INTEGER  OTHERL
N                                       CSELECT LABEL
      INTEGER  REVERL
      CHARACTER*1 BLANK
      CHARACTER*1 EQUAL
N                                        CHARACTER FOR COMPARISON
      CHARACTER*1 T
      CHARACTER*1 SELVAR(6)
N LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU

      DATA NXTLAB /14000/,SELPTR /1/
      DATA SELCAS/NSELCA*1/,LABMAX /NCASL/,VALMAX /198/
      DATA FIRSTC /1/,LASTC /1/
      DATA EQUAL /'='/,T /'T'/,BLANK /' '/
      DATA SELVAR /'I','Z','Z','Z','S','E'/
      RETURN
E
N                                        ><  'SELECT' STATEMENT
      ENTRY DOSEL
N      GENERATE 'IZZZSE=...'
      I=11
         REPEAT
            I = I + 1
      UNTIL ( LTU( LINE(I) ) .EQ. T )
      FOR J=7,I
      LINE(J)=BLANK
      CFOR
      FOR J=1,6
      LINE(J+6)=SELVAR(J)
      CFOR
         LINE(I + 1) = EQUAL
         CALL CARD
N                                        ASSIGN OTHER LABEL
         OTHERL = NXTLAB
         REVERL = OTHERL + 1
         NXTLAB = NXTLAB + 3
N                                        STACK CASE LABEL LIST START
         SELPTR = SELPTR + 1
         SELCAS(SELPTR) = LASTC
N                                        STACK OTHER LABEL
         CASLAB(LASTC) = OTHERL
         FIRSTC = LASTC
         LASTC = LASTC + 1
      RETURN
N                                        END OF CONTINUATIONS
N
N
      ENTRY CONSEL
N                                        GENERATE 'GO TO <SELECT>'
      CALL GOTO(OTHERL+2)
N                                        HANDLE CASE
         PERFORM NEWCAS
      RETURN
N
N                                        ><  'CASE' STATEMENT
      ENTRY DOCASE
N                                        GENERATE 'GO TO <CSELECT>'
      CALL GOTO(REVERL)
N                                        HANDLE CASE
         PERFORM NEWCAS
      RETURN
N
N                                        ><  'OTHER' STATEMENT
      ENTRY OTHER
N                                        GENERATE 'GO TO <CSELECT>'
      CALL GOTO(REVERL)
         I = LASTC - FIRSTC - 1
      CALL LABEL(OTHERL+2)
N                                        CHECK FOR EMPTY CASE LABEL LIST
         IF I .GT. 0
         THEN
N                                        GENERATE 'GO TO(-,-,-,-)'
      CALL CGOTO(I,CASLAB(FIRSTC+1))
      CIF
N                                        GENERATE '<OTHER> CONTINUE'
         CALL LABEL(OTHERL)
      RETURN
N
N                                       ><  'CSELECT' STATEMENT
      ENTRY REVERT
N                                        GENERATE '<CSELECT> CONTINUE'
         CALL LABEL(REVERL)
N                                        UNSTACK LAST ENTRY
         LASTC = SELCAS(SELPTR)
N                                        UNSTACK SELECT
         SELPTR = SELPTR - 1
N                                        RESET START ENTRY
         FIRSTC = SELCAS(SELPTR)
N                                        RESET OTHER LABEL
         OTHERL = CASLAB(FIRSTC)
N                                        RESET CSELECT LABEL
         REVERL = OTHERL + 1
      RETURN
N
N                                        ><  RESET CASE HANDLER
      ENTRY CCLEAR
         FOR I = 1 , SELPTR
            SELCAS(I) = 1
      CFOR
         SELPTR = 1
         FIRSTC = 1
         LASTC = 1
N                                        RESET GENERATION SWITCH
N                                        RESET LABEL COUNT
         NXTLAB = 14000
      RETURN
E
      PROC NEWCAS
         J = 1
N                                        FOR EACH NEW CASE VALUE
         WHILE NCASV(J) .GT. 0
N                                        ASSIGN ENTRY IN CASE LABEL LIST
            CASENT = FIRSTC + NCASV(J)
N                                        CHECK RANGE EXTENSION
            IF CASENT .GE. LASTC
            THEN
N                                        CHECK CASE VALUE RANGE
               IF NCASV(J) .GT. VALMAX
               THEN
      CALL ERRMSG('CASE VALUE GREATER THAN 198                       ')
      XWHILE
      CIF
N                                        CHECK ROOM IN CASE LABEL LIST
               IF CASENT .GE. LABMAX
               THEN
      CALL ERRMSG('TOO MANY NESTED CASES; FATAL ERROR                ')
      CALL ABORT
      CIF
N                                        INIT CASE LABELS WITH OTHER
               FOR I = LASTC , CASENT
                  CASLAB(I) = OTHERL
      CFOR
N                                        INCREMENT LAST CASE POINTER
               LASTC = CASENT + 1
      ELSE
N                                        CHECK DOUBLE CASE VALUE
            IF CASLAB(CASENT) .NE. OTHERL
            THEN
      CALL ERRMSG('DUPLICATE CASE VALUE                              ')
      XWHILE
      CIF
      CIF
N                                        INIT CASE LABEL ENTRY
            CASLAB(CASENT) = NXTLAB
            J = J + 1
      CWHILE
N                                        GENERATE '<CASE LABEL>CONTINUE'
         CALL  LABEL(NXTLAB)
         NXTLAB = NXTLAB + 1
      CPROC
      END
N        UNTLER
N        HANDLES EVERYTHING CONCERNING THE REPEAT CONSTRUCT
N
      SUBROUTINE UNTILR
N
      SAVE
      CHARACTER*1 LINE(80)
      COMMON /BLINE/LINE
N                                        STACK POINTER
      INTEGER UNTSTP
N                                        LABEL STACK
      INTEGER UNTSTK(32)
N                                        LABEL COUNTER
      INTEGER NXTLAB
      INTEGER I
N                                        COMPARISON CHARACTER
      CHARACTER*1 L
N LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU

      DATA UNTSTP /0/,NXTLAB /16000/,I /10099/
      DATA L /'L'/
      RETURN
E
N                                        ><  REPEAT  STATEMENT
      ENTRY C UNTIL
N                                        STACK LABEL
         UNTSTP = UNTSTP + 1
         UNTSTK(UNTSTP) = NXTLAB
N                                        GENERATE '<LABEL>CONTINUE'
         CALL LABEL(NXTLAB)
         NXTLAB = NXTLAB + 2
      RETURN
N
N                                       ><  XREPEAT STATEMENT
      ENTRY XUNTIL
         PERFORM NXUNTL
N                                        GENERATE 'GOTO <LABEL+1>'
      CALL GOTO(I)
      RETURN
N
N                                       ><  XREPEAT IN I/O STMT OR CALL
      ENTRY UREAD(LAB)
N                    OUTPUT LABEL FOR I/O STMT OR CALL
         PERFORM NXUNTL
N                                        COPY LABEL
         LAB = I
      RETURN
N
N                                        ><  UNTIL STATEMENT
      ENTRY DO UNTL
      CALL IFNOT
      I=10
         REPEAT
            I = I + 1
      UNTIL ( LTU( LINE(I) ) .EQ. L )
      I=I+1
N                                        PRODUCE OBJECT LINE
      CALL TXT(I)
      RETURN
N
N                                        ><  STATEMENT AFTER UNTIL
      ENTRY CO UNTL
      I=UNTSTK(UNTSTP)
      CALL CLGOTO(I)
N                                        GENERATE '<LABEL+1> CONTINUE'
      CALL LABEL(I+1)
N                                        UNSTACK UNTIL
         UNTSTP = UNTSTP - 1
      RETURN
N
N                                        ><  CLEAR UNTIL HANDLER
      ENTRY UCLEAR
         UNTSTP = 0
N                                        RESET LABEL COUNT
         NXTLAB = 16000
      RETURN
E
N                                        GET EXIT LABEL WHEN PRESENT
      PROC NXUNTL
         IF UNTSTP .LE. 0
         THEN
      CALL ERRMSG('NO REPEAT CONSTRUCT TO LEAVE                      ')
         ELSE
            I = UNTSTK(UNTSTP) + 1
      CIF
      CPROC
      END
N        LOOPER
N
N          HANDLES EVERYTHING CONCERNING THE FOR-CFOR
N     STRUCTURE
N
      SUBROUTINE LOOPER
      SAVE
N
      CHARACTER*1 LINE(80)
      COMMON /BLINE/LINE
N                                        FOR STACK POINTER
      INTEGER FORPTR
N                                        FOR STACK
      INTEGER FORSTK(32)
N                                        R
      CHARACTER*1 R
N                                        LABEL NUMBER COUNT
      INTEGER NXTLAB
      INTEGER I
N LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU

      DATA FORPTR /0/,R /'R'/
      DATA NXTLAB /13000/,I /10099/
      RETURN
E
N                                        ><  FOR STATEMENT
      ENTRY FOR
N                                        GET AND STACK LABEL
         FORPTR = FORPTR + 1
         FORSTK(FORPTR) = NXTLAB
N                                        LOOKUP POSITION OF R IN FOR
      J=8
         REPEAT
            J = J + 1
      UNTIL ( LTU( LINE(J) ) .EQ. R )
         J = J + 1
N                                        GENERATE 'DO <CFOR> -----'
      CALL DOLP(NXTLAB,J)
N                                        RESERVE XFOR LABEL
         NXTLAB = NXTLAB + 2
      RETURN
N
N                                        ><  XFOR STATEMENT
      ENTRY DOEXIT
         PERFORM NEXIT
N                                        GENERATE 'GO TO <XFOR>'
         CALL  GOTO(I)
      RETURN
N
N                                        ><  XFOR IN I/O STMT OR CALL
      ENTRY LREAD(LAB)
N                    OUTPUT LABEL FOR I/O STMT OR CALL
         PERFORM NEXIT
N                                        COPY LABEL
         LAB = I
      RETURN
N
N                                        ><  CFOR STATEMENT
      ENTRY NEXT
         I = FORSTK(FORPTR)
N                                        GENERATE '<CFOR> CONTINUE'
         CALL  LABEL(I)
         I = I + 1
N                                        GENERATE '<XFOR> CONTINUE'
         CALL  LABEL(I)
N                                        UNSTACK
         FORPTR = FORPTR - 1
      RETURN
N
N                                        ><  CLEAR FOR-CFOR HANDLER
      ENTRY LCLEAR
         FORPTR = 0
N                                        RESET LABEL COUNT
         NXTLAB = 13000
      RETURN
N
N      ><  OBTAIN NESTING DEPTH
      ENTRY FORDEP(ID)
      ID=FORPTR
      RETURN
E
      PROC NEXIT
         IF FORPTR .LE. 0
         THEN
      CALL ERRMSG('NO FOR CONSTRUCT TO LEAVE                         ')
         ELSE
            I = FORSTK(FORPTR) + 1
      CIF
      CPROC
      END
N        PROCER
N
N          HANDLES EVERYTHING  CONCERNING PROCEDURES
N
      SUBROUTINE PROCER
      SAVE
N      MAX. NUMBER OF PROCS (MUST BE .LE. 99)
      PARAMETER (MAXPRC=99)
N
      CHARACTER*1 LINE(80)
      COMMON /BLINE/LINE
N                                        LABEL COUNT
      INTEGER NXTLAB
N                                        TEMP'PROC'NAME IDENTIFIER
      CHARACTER*1 PROD(31) ,PARM(31)
N                                        PROC LIST POINTER (LOOK UP)
      INTEGER   PROPTR
N                                        PROC LIST POINTER (END STMNT)
      INTEGER   PROPRT
N                                        LAST PROC LIST ENTRY POINTER
      INTEGER   LASTPR
N                                        CURRENT PROC LIST ENTRY POINTER
      INTEGER   THISPR,IREV
N                                        CURRENT PROC POINTER
      INTEGER  CURPRC
N                                        PROC NAME
      CHARACTER*1 PRONAM(31,MAXPRC)
N                                        PROC LABEL
      INTEGER PROLAB(MAXPRC)
N                                        NUMBER OF REFERENCES
      INTEGER NOFREF(MAXPRC)
N                                        CHARACTERS FOR NAME COPY
      CHARACTER*1 XAR
      CHARACTER*1 DIGIT(0:9)
      CHARACTER*1 M,C,BLANK
      CHARACTER*1 INAME(6)
      INTEGER SAVEP,SAVE(7),PLAB
N     LOWER TO UPPER FUNCTION
      CHARACTER*1 LTU
      LOGICAL OKAY
      INTEGER KGB

      DATA SAVEP /0/,SAVE /7*0/
      DATA NXTLAB /17000/,PROD /31*' '/
      DATA PROPTR /0/,PROPRT /0/,LASTPR /1/
      DATA PROLAB /MAXPRC*0/,NOFREF /MAXPRC*0/
      DATA INAME /'I','Z','Z','Z',' ',' '/
      DATA DIGIT/'0','1','2','3','4','5','6','7','8','9'/
      DATA M/'M'/,C/'C'/,BLANK/' '/
      RETURN
E
N
N                                        ><  HANDLE PERFORM
      ENTRY PFORM
N                                        GET PROC NAME
         XAR = M
         PERFORM COPY
N                                        ADD NAME TO PROC LIST,GET LABEL
         PERFORM ADPROC
N                                        GENERATE 'ASSIGN <L> TO <PROC>'
         INAME(5)=DIGIT(THISPR/10)
         INAME(6)=DIGIT(MOD(THISPR,10))
         CALL ASSGN(NXTLAB,INAME)
N                                        GENERATE 'GO TO <PROC-LABEL>'
         CALL  GOTO(IREV)
N                                        GENERATE '<L> CONTINUE'
         CALL  LABEL(NXTLAB)
N      INCREMENT LABEL
         PERFORM PUTLAB
N      CHECK WHETHER IN FOR LOOP
        CALL FORDEP(K)
**  WARNING DISABLED *****
**        IF K.GT.0
**        THEN
**          CALL WARN(PRONAM(1,THISPR),
**     - ': PERFORM IN FOR-LOOP CAUSES NON-STANDARD FORTRAN ')
**        CIF
      RETURN
N
N                                        ><  OPEN PROC DEFINITION
      ENTRY PROC
N                                        GET PROC NAME
         XAR = C
         PERFORM COPY
N                                        ADD NAME TO PROC LIST,GET LABEL
         PERFORM ADPROC
N                                        GEN '<PROC-LABEL> CONTINUE'
            CALL  LABEL(IREV)
N                                        MARK PROC 'DEFINED'
            PROLAB(THISPR) = - PROLAB(THISPR)
N                                        SAVE CURRENT PROC POINTER
         CURPRC = THISPR
      RETURN
N
N                                        ><  CLOSE PROC DEFINITION
      ENTRY PEND
N                                        RESTORE CURRENT PROC POINTER
         THISPR = CURPRC
N                                        WRITE RETURN GOTO
         PERFORM GETLAB
      RETURN
N
N      ><  PROC IN I/O STMT OR CALL
      ENTRY PREAD(PARM,PLAB)
N                                        COPY PROC NAME
         FOR K = 1 , 31
            PROD(K) = PARM(K)
         CFOR
N                                        ADD PROC TO DICTIONARY
         PERFORM ADPROC
N                                        COPY PROC LABEL
         PLAB = IREV
N                                        GENERATE 'ASSIGN <L> TO <PROC>'
         INAME(5)=DIGIT(THISPR/10)
         INAME(6)=DIGIT(MOD(THISPR,10))
         CALL ASSGN(NXTLAB,INAME)
N                                        SAVE RETURN LABEL
         SAVEP = SAVEP + 1
         SAVE(SAVEP) = NXTLAB
         PERFORM PUTLAB
      RETURN
N
N                    FIRST STATEMENT AFTER I/O STMT OR CALL
      ENTRY COREAD
N                                        GENERATE CONTINUE STATEMENTS
         WHILE SAVEP .GT. 0
            CALL  LABEL(SAVE(SAVEP))
            SAVEP = SAVEP - 1
      CWHILE
      RETURN
N
N                                        ><  CLEAR PROC HANDLER
      ENTRY PCLEAR
N                                        GENERATE STUBS FOR LEFT PROC'S
      PROPRT=1
      WHILE PROPRT.LE.LASTPR
N                                        IF NO PROC DEFINED
            IF PROLAB(PROPRT) .GT. 0 .AND. PROPRT .LT. LASTPR
N                                        GENERATE STUB
            THEN
N                                        GENERATE '<PROC LABEL>CONTINUE'
      CALL LABEL(PROLAB(PROPRT))
N                                        WRITE RETURN LABEL LIST
               THISPR = PROPRT
               PERFORM GETLAB
      CALL WARN(PRONAM(1,PROPRT)
     -,'IS NOT DEFINED                                    ')
      CIF
N                                        CLEAR LIST
            PROLAB(PROPRT) = 0
      PROPRT=PROPRT+1
      CWHILE
N                                        RESET POINTERS
      NXTLAB=17000
N                                        RESET LAST PROC COUNT
         LASTPR = 1
      RETURN
E
N                              ADD NAME TO PROC LIST,GET LABEL
      PROC ADPROC
N                                        FOR EACH LIST ENTRY
         FOR  PROPTR = 1 , LASTPR
N                                        IF NOT FOUND
            IF PROPTR .EQ. LASTPR
            THEN
              IF LASTPR.GT.MAXPRC
              THEN
      CALL ERRMSG('TOO MANY PROCS                                    ')
                CALL ABORT
              CIF
N                                        GET LABEL
              IREV = NXTLAB
              NXTLAB = NXTLAB + 1
N                                        CREATE NEW ENTRY
              FOR  K = 1 , 31
                PRONAM(K,PROPTR) = PROD(K)
              CFOR
              PROLAB(PROPTR) = IREV
N                                        INCREMENT LAST ENTRY COUNT
              LASTPR = LASTPR + 1
              THISPR = PROPTR
            XFOR
          ELSE
N                                        LOOK FOR MATCH
      OKAY=.TRUE.
      FOR KGB=1,31
      OKAY=(OKAY.AND.(PRONAM(KGB,PROPTR).EQ.PROD(KGB)))
      CFOR
      IF (OKAY)
      THEN
N     IF MATCH THEN COPY LABEL
             IREV = IABS(PROLAB(PROPTR))
N                                        CHECK WHETHER
             IF PROLAB(PROPTR) .LT. 0
N                                        PROC IS ALREADY DEFINED
             THEN
      CALL ERRMSG('PROC REFERENCED AFTER ITS DEFINITION              ')
             CIF
             THISPR = PROPTR
             XFOR
           CIF
         CIF
        CFOR
      CPROC
N
N
N      COUNT REFS AND INCREMENT LABEL
      PROC PUTLAB
         NOFREF(THISPR) = NOFREF(THISPR) + 1
         NXTLAB = NXTLAB + 1
      CPROC
N
N
N                                        WRITE RETURN GOTO
      PROC GETLAB
         IREV = NOFREF(THISPR)
N                                        IF NO REFERENCES
         IF IREV .LE. 0
         THEN
N                                        THEN GIVE WARNING
      CALL WARN(PRONAM(1,THISPR)
     -,'IS NOT REFERENCED                                 ')
         ELSE
N                                        GENERATE 'GOTO IZZZ..'
      INAME(5)=DIGIT(THISPR/10)
      INAME(6)=DIGIT(MOD(THISPR,10))
      CALL AGOTO(INAME)
      CIF
         NOFREF(THISPR) = 0
      CPROC
N
N
N                                        COPY PROC NAME
      PROC COPY
      J=9
N                                        LOCATE FIRST POSITION
         REPEAT
      J=J+1
      UNTIL ( LTU( LINE(J) ) .EQ. XAR )
      J=J+1
N                                        BLANK FIELD
         FOR I = 1 , 31
            PROD(I) = BLANK
      CFOR
         I = 0
N                                        COPY CHARACTERS
      FOR K=J,72
N                                        WHEN NOT BLANK
      IF LINE(K).NE.BLANK
            THEN
               I = I + 1
               IF I .GT. 31
               THEN
      CALL ERRMSG('PROC NAME TOO LONG                                ')
      XFOR
               ELSE
                     PROD(I) = LTU(LINE(K))
      CIF
      CIF
      CFOR
      CPROC
      END
E
N RTAB
N
N TRANSLATE TAB CHARACTERS TO BLANKS
N CAN BE AN EMPTY SUBROUTINE IF TABS DO NOT OCCUR
N
       SUBROUTINE RTAB(LINE,NCH)
      CHARACTER*1 TAB,BLANK
N      ITAB IS INTERNAL CHARACTER VALUE OF TAB
       PARAMETER (LB=80,ITAB=9,NTAB=8,BLANK=' ')
       CHARACTER*1 LINE(NCH),TBUF(LB)

N      CONVERT INTERNAL CHAR.VALUE TO TYPE CHARACTER*1
      CALL CVIC(ITAB,TAB)
       IF NCH.GT.LB
       THEN
N      CANNOT HAPPEN WHEN CALLED FROM SHELTR
       STOP 4711
       ELSE
       II=0
       IO=0
       REPEAT
       II=II+1
       IF LINE(II).EQ.TAB
       THEN
       NSP=NTAB-MOD(IO,NTAB)
       FOR I=1,NSP
       IO=IO+1
       TBUF(IO)=BLANK
       IF IO.EQ.NCH
       THEN
       XREPEAT
       CIF
       CFOR
       ELSE
       IO=IO+1
       TBUF(IO)=LINE(II)
       CIF
       UNTIL IO.EQ.NCH
       FOR I=1,NCH
       LINE(I)=TBUF(I)
       CFOR
       CIF
       RETURN
      END
N     CONVERT INTERNAL TO CHARACTER
      SUBROUTINE CVIC(I,C)
      INTEGER I
      CHARACTER*1 C
      C=CHAR(I)
      RETURN
      END
N     FATAL TRANSLATION HANDLER
      SUBROUTINE ABORT
      STOP 999
      END
N     CONVERT A LOWERCASE CHARACTER TO IT'S UPPERCASE EQUIVALENT
      CHARACTER*1 FUNCTION LTU( CH )
      CHARACTER*1  CH
      IPOS = INDEX('abcdefghijklmnopqrstuvwxyz',CH)
      SELECT IPOS
      CASE 1
        LTU = 'A'
      CASE 2
        LTU = 'B'
      CASE 3
        LTU = 'C'
      CASE 4
        LTU = 'D'
      CASE 5
        LTU = 'E'
      CASE 6
        LTU = 'F'
      CASE 7
        LTU = 'G'
      CASE 8
        LTU = 'H'
      CASE 9
        LTU = 'I'
      CASE 10
        LTU = 'J'
      CASE 11
        LTU = 'K'
      CASE 12
        LTU = 'L'
      CASE 13
        LTU = 'M'
      CASE 14
        LTU = 'N'
      CASE 15
        LTU = 'O'
      CASE 16
        LTU = 'P'
      CASE 17
        LTU = 'Q'
      CASE 18
        LTU = 'R'
      CASE 19
        LTU = 'S'
      CASE 20
        LTU = 'T'
      CASE 21
        LTU = 'U'
      CASE 22
        LTU = 'V'
      CASE 23
        LTU = 'W'
      CASE 24
        LTU = 'X'
      CASE 25
        LTU = 'Y'
      CASE 26
        LTU = 'Z'
      OTHER
        LTU=CH
      CSELECT
      RETURN
      END
E     SHLTRN - Function NELC
      INTEGER FUNCTION NELC(A,N)
      CHARACTER*1 A(*)
      INTEGER     N,NEL
      NEL=N
      WHILE (NEL.GT.0)
        IF (A(NEL).EQ.' ')
        THEN
          NEL=NEL-1
        ELSE
          XWHILE
        CIF
      CWHILE
      NELC=NEL
      RETURN
      END
