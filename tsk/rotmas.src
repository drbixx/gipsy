rotmas.src

        Copyright (c) Kapteyn Astronomical Institute, Groningen 2014
        All Rights Reserved.

Name:         rotmas.src
Creator:      vogelaar
Host:         albirumi
Date:         Sep 12, 2014
Contents:     rotmas.make rotmas.dc1 gui.h hidden.h inpmod.h
              fileform.h inputs.h xvplot.h subsvar.h paramform.h
              gammaq.h ggiverify.h chi2plot.h chi2form.h colormenus.h
              rotmas.c gui.c hidden.c inpmod.c fileform.c
              inputs.c xvplot.c subsvar.c paramform.c gammaq.c
              ggiverify.c chi2plot.c chi2form.c colormenus.c subsvar.l

#>            rotmas.make
#----------------------------------------------------------------------
# Makefile for ROTMAS, jun 27, 1998
#
#
# Pack sources into rotmas.src with:     > make -f rotmas.make pack
# Clean executable and objects           > make -f rotmas.make clean
# Unpack source files with:              > $gip_exe/xfile rotmas.src
# Install source file with:              > p -reserve rotmas.src
#                                        > p -install rotmas.src
#
# Local compilation for testing:         > p rotmas.make
#
# The CC_OPTS etc are set by 'compile'
#----------------------------------------------------------------------

SHELL = /bin/sh

OPTS  = $(CC_OPTS)
COMP  = $(CC_COMP)
LIBS  = $(CC_LIBS)

.SUFFIXES: .c .o

DOCUMENTS = rotmas.dc1

#Lexical file for subsvar.c
LEX       = subsvar.l

INCLUDES  = gui.h hidden.h inpmod.h fileform.h inputs.h xvplot.h \
            subsvar.h paramform.h gammaq.h ggiverify.h chi2plot.h chi2form.h\
            colormenus.h

SOURCES   = rotmas.c gui.c hidden.c inpmod.c fileform.c inputs.c xvplot.c \
            subsvar.c paramform.c gammaq.c ggiverify.c chi2plot.c chi2form.c\
            colormenus.c

OBJECTS   = rotmas.o gui.o hidden.o inpmod.o fileform.o inputs.o xvplot.o \
            subsvar.o paramform.o gammaq.o ggiverify.o chi2plot.o chi2form.o\
            colormenus.o

default:: rotmas

pack::
	$${gip_sys}/pack.csh rotmas.src rotmas.make \
        $(DOCUMENTS) $(INCLUDES) $(SOURCES) $(LEX)

clean::
	rm -f rotmas $(OBJECTS)


# Prevent making subsvar.c from subsvar.l because we already have a
# subsvar.c and don't want a new one. Note the real tab before the command.

subsvar.c:   subsvar.l
	touch subsvar.c

rotmas.o: $(INCLUDES)

gui.o:       gui.h
hidden.o:    hidden.h
inpmod.o:    inpmod.h
fileform.o:  fileform.h
inputs.o:    inputs.h 
xvplot.o:    xvplot.h
paramform.o: paramform.h  
gammaq.o:    gammaq.h


.c.o:  
	@echo "$(CC_COMP) -c $(CC_OPTS) $(X11_OPTS) $< ";\
	$(CC_COMP) -c $(CC_OPTS) $(X11_OPTS) $<

rotmas:  $(OBJECTS)
	@echo "$(CC_COMP) -o rotmas $(OBJECTS) $(X11_LIBS) $(CC_LIBS) $(XT_LIBS)";\
	$(CC_COMP) -o rotmas $(OBJECTS) $(X11_LIBS) $(CC_LIBS) $(XT_LIBS)
#<

#>            rotmas.dc1
Program:       ROTMAS
               
#begin section 1
                            Global description
                            ------------------


Assume that matter circulates around a galactic center, at distance R to that 
center, with circular velocity Vc. A plot of radius versus circular velocity 
is called a rotation curve. Usually such a curve is a composition of several 
velocities and the purpose of ROTMAS is to fit these components interactively 
to an 'observed' rotation curve. Applying the tilted ring model, these 
velocities can also be transformed into so called line-of-sight velocities 
which can be plotted over a separate contour diagram (XV plot) of the galaxy.


ROTMAS allows the following components for the rotation curve:
A bulge (velocities in the program represented by data
parameter Vb), a stellar disk (Vd), a gas disk (Vg) an extra component Vx (e.g. 
for molecular (CO, H_2) gas), and a dark halo or some
other component represented by a 'user' function, called Vu.
The total velocity is also a function (Vt). An expression usually contains 
variable parameters. See also help item 'Expressions' for help on expression 
syntax. 
All the components can be interactively varied to explore parameter space. 
ROTMAS uses the (modified) values of the variable parameters as initial 
estimates for a least squares fit. This fit routine provides the best fit 
parameters for the total velocity which can be compared then to the observed 
rotation curve or to the line-of-sight velocities plotted in an XV diagram.
Fit results are written on screen and stored in the GIPSY log file.
At any moment the status of the data and the status of the program itself
can be saved to disk. Saved data has a fixed format so that it can be used 
as input for other programs. 

There are three special variable parameters called mb, md and mg which stand
for mass scaling factor for bulge, disk and gas. If used in an expression, 
they will scale your curves for bulge, disk and gas in the plot, even if
they do not represent a valid scaling factor in the expression.

Note: ROTMAS can also be used as a simple fit program e.g to fit a straight
line through your data. The only disadvantage of this will be that the labels 
along your axes are radii and velocity. Example:

In the inputs window, enter for the observed radii: 1:10 and for the observed
data also 1:10. Enter in the main window for Vt(r)=b+a*r and press the fit 
button.

#end section 1


#begin section 2
                               Expressions
                               -----------

You can enter expressions for a user function Vu and the total velocity Vt.
Note that:

-The expression must have a derivative.
-Syntax is case insensitive
-Maximum length of the expressions may not exceed 1024 characters.
-The name of the variables in these expressions cannot exceed 16 characters.
-Maximum number of variables is 32.
-Variables always include data parameters Vg, Vd, Vb, Vu even if there is 
 no data available.
-Variables  mb, md and mg have a special meaning.

The program distinguishes two categories of variables. The first are
the variables Vg, Vd, Vb, Vu. These represent the velocity of the gas,
disk and bulge as read from a file, and Vu is a velocity entered as
an expression for instance to represent a dark halo. Other variables
can be changed interactively by so called valuators or can be fitted 
by a least squares routine. In this last category there are three 
special variables mb, md and mg which are the mass scaling
factors for bulge, disk and gas. They are special because they rescale 
the the curves for bulge, disk and gas in the plot according to
the relation Vb_plot = sqrt( mb ) * Vb_data etc.

ROTMAS allows you to select some expressions from a menu. The standard
formula for example is given by:

       Vt(r)=sqrt(mg*Vg*abs(Vg)+md*Vd*abs(Vd)+mb*Vb*abs(Vb)+Vu**2)

The default expression for the total velocity is a summation of the
individual contributions of gas, disk, bulge and Vu, the velocity
expression that you entered for e.g. the dark halo. Note the use
of the abs function. It conserves sign in the quadratic contribution!

Other pre-programmed formulas:

Standard Vtotal without bulge:
Vt(r)=sqrt(mg*Vg*abs(Vg)+md*Vd*abs(Vd)+Vu**2)

Mond:
Vt(r)=sqrt((mg*abs(Vg)*Vg+md*Vd*abs(Vd)+mb*Vb*abs(Vb))*
      sqrt(1+sqrt(1+(2*r*a/(mg*abs(Vg)*Vg+md*Vd*abs(Vd)+mb*Vb*abs(Vb)))**2))/sqrt(2))
with default: a=3734

Special User functions:
Exponential: sqrt(4*{PI}*4.321*sig0*r**2/
(4*h)*(bi(0,0.5*r/h)*bk(0,0.5*r/h)-bi(1,0.5*r/h)*bk(1,0.5*r/h)))

Hernquist:
sqrt(4.321*M0*1e4)*(sqrt(R))/(R0+R) 
with defaults: R0=35 M0=55 R0_MIN=30 R0_MAX=40

Isotherm:
sqrt(4*{PI}*4.321*rho*rc*rc*(1-(rc/r)*atan(r/rc))) 
with defaults: RHO=7 RC=7"

Navarro-Frenk-White profile:
(R200/0.73)*sqrt(R200/R*((ln(1+C*R/R200)-(C*R/R200)/(1+C*R/R200))/(ln(1+C)-C/(1+C))))


Units: r         in Kpc
       V         in Km/s
       M         in M0 (solar mass = 2x10^30 Kg)
       rho       in 10^-3 M0/pc^3 
       a(mond)   in Km/s.s^-1.Kpc^-1




Configuration of menu
=====================

You can append menu items for the Vt and Vu menu, see text at Configuration.


Warning
=======

If your expression for Vu or Vt allows singularities at certain values
of R, and your weight (error) in that point is unequal to zero then
the fit will fail. Change the value of the error then to 0. If you are
using uniform weights then the error value cannot be changed. What you can
do in that situation is fill the errors field in the "INPUTS" window
with an expression like 0 1::45 to enter a zero for the first radius
and a one for the next 45 radii.

#end section 2




#begin section 3
                              List of functions
                              -----------------
  functions
  abs(x)         absolute value of x 
  acos(x)        inverse cosine of x
  asin(x)        inverse sine of x   
  atan(x)        inverse tan of x
  bj(n,x)        Bessel function of 1st kind, integer order
  by(n,x)        Bessel function of 2nd kind, integer order
  bi(n,x)        modified Bessel fn. of 1st kind, integer order
  bk(n,x)        modified Bessel fn. of 2nd kind, integer order
  cos(x)         cosine of x
  cosh(x)        hyperbolic cosine of x
  deg(x)         convert x to degrees
  exp(x)         exponential of x
  ln(x)          natural log of x
  log(x)         log (base 10) of x
  rad(x)         convert x to radians
  sign(x)        sign of x (-1,0,1)  
  sin(x)         sine of x
  sinc(x)        sin(x)/x (sinc function)
  sinh(x)        hyperbolic sine of x
  sqrt(x)        square root of x
  tan(x)         tangent of x
  tanh(x)        hyperbolic tangent of x

  constants
  (Enclose between braces to distinguish from variables)
  PI             3.14159....
  C              speed of light (SI)
  H              Planck (SI)
  K              Boltzmann (SI)
  G              gravitation (SI)
  S              Stefan-Boltzman (SI)
  M              mass of sun (SI)
  P              parsec (SI)

  available operators:
  +              addition
  -              subtraction
  *              multiplication
  /              division
  **             power

  Example: sqrt(4*{PI}*4.321*rho*rc**2*(1-(rc/r)*atan(r/rc)))  
 
#end section 3



#begin section 4  
                           chi-square landscape
                           --------------------

Recipe
======

To be able to explore parameter space and estimate errors on parameters, 
a chi-square (contour) landscape can be plotted. First press the 
<CHI2PLOT> button to open the chi square landscape window.
The axes of the plot correspond to parameters in your function for Vu and Vt.
an are selected by the <x:> and <y:> buttons in the new window.
Pressing on one of the buttons will pop-up a menu with available 
parameters. After selecting the parameters, one must select the mode.
First mode is a chi-square plot with chi square values as contour 
levels and the second mode plots the contours as confidence intervals in 
units of 1 sigma (see: Confidence intervals). 
The <GO/STOP> button starts calculating a minimum value for 
chi-square on each sample point in a grid with sizes given by the input field 
"sample size:"
The sample ranges are copied from the ranges in the parameter valuators.
To center your plot, use the <FIT> button to set reasonable values for
the valuator ranges. 
ROTMAS calculates defaults for the contour levels, but alternative 
values can be entered in the "Levels:" input field.
The minimum value for chi-square is calculated using a least squares fit 
with the axis parameters as fixed parameters and the other parameters are 
fixed or free depending on their status in the GUI.
Note that a real minimum chi-square can only be approached if all or most 
of the parameters are free in the fit.  


The chi-square values depend on the selected weights. For the interpretation
of the chi-square landscape it is important to know whether uniform weights
or errors as weights are used for the calculations.


How to abort the calculations
=============================

If you want to abort the process of calculating a chi-square landscape then
press the <GO/STOP> again. The progress of a running process is displayed 
in the status line in the main window.


Levels
======

As soon as the chi-square values are known to the program, defaults are
calculated. For the confidence intervals mode, the default is 1 2 3 4 5
and the default for the reduced chi-square is derived from the same numbers
but transformed to a chi-square value.
The first contour level in the levels input field will be plotted in red. The 
other contours are plotted in yellow. A green cross is plotted at the position
of the minimum value of chi-square found in the sample. Usually, because
of the sampling, this is not the position of the real minimum.


Confidence intervals
====================

A confidence region (or interval) is a region that contains a certain 
percentage of the total probability distribution. You can use constant 
chi-square boundaries as confidence limits. ROTMAS calculates the steps
in chi-square as function of the number of fixed parameters (2) for which 
you want the confidence limits and as function of the probability.
The probability is expressed in sigma (1 == 68.3%, 2 == 95.4% 3 == 99.73%
etc.)
The steps in chi-square are distributed as the chi-square distribution.


Mouse interaction
=================

If you click with the left mouse button somewhere in the chi-square landscape,
then the landscape parameters at that point are fixed in a least squares fit
while the other parameters keep their free/fixed status. The results of
the fit are transmitted to the main window and the rotation curve(s) are
replotted. The reported value of of the reduced chi-square after a fit must 
correspond then with the minimum value in the chi-square landscape.


Warning
=======

Allowing the event handling of this <GO/STOP> button in the middle of 
building the chi-square landscape, means in this case that also other events 
are allowed and some of them could harm the consistency of the program
(e.g. changing the value of the least squares fit tolerance etc.).
So please be patient and wait until the contours are plotted.

#end section 4



#begin section 5
                              The XV-plot
                              -----------

Recipe
======

Plotting a XV diagram must be started by pressing the <XVPLOT> button
in the main window of ROTMAS. An empty window with input fields and
buttons will pop-up. First you need a GIPSY input set e.g. made by
program SLICE or from some other source. Together with values for 
contour levels, a plot is made with R in kpc along the x-axis and
V in km/s along the y axis. But if you want an overlay of rotation curve 
velocities converted to line of sight velocities, then you have to 
enter tilted ring parameters like a set of inclinations, position
angles, a systemic velocity, the position angle of the slice and a distance
in Mpc.

If you enter less inclinations or position angles than the number of radii,
the missing values are copied from the last one entered.


Converting tilted ring velocities to line of sight
==================================================

For the velocity conversion we have the following relations:

                   theta = arctan( tan(beta)/cos(i) )
                   
                    Vz = V0 + Vc.sin(i).cos(theta)
 

where: 

Vc      tilted ring circular velocity
theta   azimuthal angle in the plane of the galaxy
beta    position angle (in the sky) of slice
i       inclination of tilted ring
V0      systemic (line of sight) velocity
Vz      line of sight velocity

For the radius conversion:

                    Rproj = R.cos(theta)/cos(beta)

where:

R       tilted ring radius
Rproj   radius in the sky


The conversion factor for a pixel to an offset in radius is read from 
the header of the GIPSY (XV)set (i.e. CDELT for the first axis of the 
(sub)set) and this offset is converted to minutes of arc. 
We want to convert the offsets to kpc because the radii in the rotation
curves are in kpc's. The following formula is used for the conversion:

                  R(Kpc) = R(arcmin) * 0.290888 * distance(Mpc)

Now it is possible to convert any rotation curve radius to a corresponding
pixel in the XV map and we can plot any point in a rotation curve in 
the XV map.
#end section 5


#begin section 6
                         Input fields an buttons
                         -----------------------



WINDOW: MAIN
============

FILE           (type: menu, keyword: FILEMENU=)   
               Options are: 1) save data
                            2) save parameters
                            3) load parameters
                            4) save chi^2 data
                            5) exit

               For the save options, a new window appears where you are 
               prompted to enter a filename. The program checks if the file 
               already exists. 
               
               
               ad 1) save data   (type: input field (text), keyword OUTFILE=)
                     Enter a name for the output file. Press enter or OK to 
                     confirm or CANCEL to return.
                     The output of the (fitted) data has a fixed format. 
                     Data start at line 11. The order in columns is:
                     Radius vgas vdisk vbulge vobs  err vobs Vu Vt Rxv Vxy
                     Radii are in kpc, velocities in km/s

                     Example output:
                     
                     !# Results of ROTMAS saved at 03-Jul-1998 (14:59:31)
                     !# User velocity   : Vu=0
                     !# Total velocity  : Vt=SQRT(MD*VD**2)
                     !# Parameter name  :           MD
                     !# Parameter value :     5.103946
                     !# Parameter error :     0.000000
                     !#
                     !# Radius |  vgas   |  vdisk  |  vbulge |  vobs   | err
                     !# kpc       km/s      km/s       km/s     km/s     km/s
                     !#======================================================
                        0.2546   -0.277155   33.5253         0     14.39     
                        0.5093   -0.702933   40.2798         0     24.38     
                        0.7639   -1.78983    46.0473         0     29.25      
                  
               ad 2) save parameters (type: input field (text), 
                                      keyword PARMFILE=)
                     Enter a name for the program parameter file. Press enter
                     or OK to confirm or CANCEL to return.
                     The file with keywords can be used as a default file 
                     for a new ROTMAS session or to restore a previous program
                     status without restarting. If you saved keywords to a file
                     'mykeys.def' then you can start ROTMAS
                     on the Hermes prompt with:  mykeys(rotmas) 
               
               ad 3) load parameters  (type: input field (text),
                                      keyword PARLOAD=)
                     Enter a name for the program parameter file.
                     For all the keywords in this file, events are generated
                     as if you specified them manually.

               ad 4) save chi^2 data  (type: input field (text),  
                                      keyword CHI2FILE= )
                     Enter a name for a file on disk that contains data 
                     from the chi-squared plot.

                     Example output:

                     !# Results of ROTMAS chi2 data saved at 07-Dec-1999...
                     !# chi2 landscape data from 20 x 20 sample
                     !#           A            MD  value of chi-square
                         297.220001      1.210000    1145.207642
                         328.506836      1.210000     973.705505
                         359.793671      1.210000     816.389221 etc.

               ad 5) exit
                     
                     If you did not save your data, ROTMAS will prompt with 
                     the save data window instead of aborting the program.
                     If you did save your data once in the same session, then
                     the program will not prompt anymore and will exit 
                     immediately.
               
               
PLOTTER        (type: menu, keyword: PLOTTER=)
               The system printers are listed. After selection of a device
               from the list, button PLOT becomes active. A plot is created 
               after pressing the plot button. 


PLOT           (type: button, keyword: PLOT=)
               Plot the rotation curve on the device selected with menu 
               PLOTTER. If a XV plot is visible, plot this map and an overlay 
               of the rotation curve on the same page. 
               If the plot is ready, the program will tell you that in its 
               status line.               
               If a PostScript file is selected then the name of the
               created file is logged and displayed in the GIPSY log file.


INPUTS         (type: input window, keyword: INPUTS=) 
               Pop up a new window for specification of input. See description 
               at WINDOW: INPUTS 


ROTMOD         (type: input window, keyword: ROTMOD=)
               Pop up a new window for specification of input for GIPSY task 
               ROTMOD. 
               After running ROTMOD new data files on disk wil be used as 
               input for ROTMAS.
               See description at WINDOW: ROTMOD


XVPLOT         (type: button, keyword: XVPLOT=)
               Pop up a new window for specification of input for a GIPSY set 
               and parameters to plot line of sight velocities on an XV plot.
               See description at WINDOW: XVPLOT


CHI2PLOT       (type: button, keyword: CHI2PLOT=)
               Pop up a new window for with input fields and plot window
               for a chi-square landscape. 


FIT            (type: button, keyword: FIT=)
               Start a least squares fit algorithm for the current data. 
               Use current parameter values as initial estimates for the 
               routine. Results are displayed in the status line of ROTMAS. 
               They are also logged in the GIPSY LOG file.
               Special options for the fit can be entered in the OPTIONS menu.
               The fit routine uses either weights from file (INPUTS window) or 
               uniform weights.
               Three parameters (tolerance, mixing parameter and max. 
               iterations) needed by the fit routine are specified in the 
               OPTIONS window. If the program could make a fit then the 
               results are displayed in the status line with the number of 
               iterations, the reduced chi-square and the goodness-of-fit 
               probability. 


WEIGHTS        (type: menu, keyword: WEIGHTS=)
               options:
               1) uniform
               2) errors
               Set the weights for the least squares routine and the 
               calculation of chi-square. If you select uniform then the 
               weight at radius 0 is set to zero.
               If weights are set to errors and the weight at radius 0 kpc is 
               unequal to zero, then you will be warned with a message in the 
               status after fitting.


OPTIONS        (type: input window, keyword: OPTIONS=)
               See description at WINDOW: OTIONS 


HELP           (type: menu, keyword: HELP=)
               A number of help items are listed. The help text is extracted 
               from the dc1 document of ROTMAS.


REFRESH        (type: button, keyword: REFRESH=)
               Reread all the input files and replot the curves.


Vu(r)          (type: input field, keyword VUFUN=) 
               Enter (or select from function menu) an expression for one of 
               the rotation curve components e.g. a dark halo. See also help 
               item expressions.


Vt(r)          (type: input field, keyword VTFUN=)
               Enter (or select from function menu) an expression for the 
               total velocity.
               Vt (and Vu) recognizes 4 data parameters Vb, Vg, Vd and Vu 
               and variables of which mb, mg and md have a special meaning 
               (in the plot they always act as a mass scaling factor). If 
               a so called 'standard' expression is selected then you can 
               drag the plotted components in the plot by pressing the left 
               mouse button.
               See also help item expressions.






WINDOW: OPTIONS
===============

Tolerance      (type: input field (floats), keyword: TOL=)
               The least squares routine needs a criterion for stopping. 
               It stops when successive iterations fail to produce a 
               decrement in reduced chi-squared less than 'TOLERANCE'. If 
               this value is less than the minimum tolerance possible,  it 
               will be set to this value. This means that maximum accuracy 
               can be obtained by setting 'TOLERANCE' to 0.0.


Lambda         (type: input field (floats), keyword: LAB=)
               A mixing parameter, LAMBDA determines the initial weight of 
               steepest descent method relative to the Taylor method in the 
               least squares fit. LAMBDA should be a small value (e.g. 0.01).


Maxits         (type: input field (integer), keyword: MAXITS=)
               Maximum number of iterations allowed in least squares fit.



WINDOW: INPUTS
==============


               INPUT FROM FILE
               ===============

File           (type: input field (text), keyword: FILE=)
               Enter the name of an ASCII file that contains columns with 
               your observed rotation curve data. The name typed here will be 
               used to compose the GIPSY command to read data from file. 
               These commands are automatically listed in the input fields 
               below.


Rows           (type: input field (integers), keyword: ROWS=)
               The FILE specification can only be active if also rows are 
               entered. The rows field allows abbreviated input. Here are the 
               options (same as input from recall files)
               m:n  read lines from m to n
               m:   read lines from line m to end of file.
                :n  read lines from start of file to line n.
                :   read all rows.


Radii          (type: input field (integer), keyword: RADII_COL=)
               Enter the number for the column that represents the radii. 
               Radii must be in kpc. 


Observed       (type: input field (integer), keyword: ODATA_COL=)
               Enter the column number in which your observed data is 
               stored.


Bulge          (type: input field (integer), keyword: BDATA_COL=) 
Disk           (type: input field (integer), keyword: DDATA_COL=) 
Gas            (type: input field (integer), keyword: GDATA_COL=)
               Enter the column number in which you data is stored for 
               your gaseous disk, bulge and stellar disk.


Top title      Annotation at the top of a plot can be set in this field 
               or with keyword TOPTITLE=  which accepts a string like 
               "ngc 2343" (omit the quotes). You need to refresh the plot 
               after specifying the title with the "refresh" button.



               INPUT FROM TABLES
               =================

Set            (type: input field (text), keyword: TABSET=)
               Name of the set from which a table must be extracted.


Table          (type: input field (text), keyword: TABLE=)
               Name of the table in the set.


Rows           (type: input field (integers), keyword: TROWS=)
               Rows for which column data must be extracted. The syntax is
               the same as for recall files, i.e. m:n, m:, :n and :


Radii          (type: input field (column name), keyword: TRADII=)


Observed       (type: input field (column name), keyword: TODATA=)


Errors         (type: input field (column name), keyword: TERRORS=)


Bulge          (type: input field (column name), keyword: TBDATA=)
Disk           (type: input field (column name), keyword: TDDATA=)
Gas            (type: input field (column name), keyword: TGDATA=)
               


               COMMON INPUT
               ============

Observed radii (type: input field (floats), keyword: RADII=)
               If you did not use the input fields for input from text file
               then enter your radii (kpc) here. 
               Example: file(rcfit7524.dat,1,13:)


Errors         (type: input field (floats), keyword: ERRORS=)
               Draw error bars in through the observed data points.
               Use values as weights in least square fit.
               Example: file(rcfit7524.dat,8,13:)
                        1.3::30                     ! 31 times value 1.3


Bulge radii    (type: input field (floats), keyword: BRADII=)
Disk radii     (type: input field (floats), keyword: DRADII=)
Gas radii      (type: input field (floats), keyword: GRADII=)
               If you have different radii compared to the observed radii,
               then enter your numbers here and the program will try to 
               sample on the original radii using a spline algorithm.
               The length of the radii array must be equal to the length 
               of the data array
 

Bulge data     (type: input field (integer), keyword: BDATA=)
Disk data      (type: input field (integer), keyword: GDATA=)
Gas data       (type: input field (integer), keyword: DDATA=)
               If you don't use the input for file rows and columns, then 
               you can enter here the observed data.


CLOSE          (type: button, keyword: INPUTS=)
               Hide window.


ROTMOD         (type: button, keyword: ROTMOD=)
               Open input window for ROTMOD keywords. ROTMOD calculates the 
               rotation curve for a truncated exponential disk (Casertano, 
               M.N.R.A.S., vol. 203, p735-p747, 1983), or for any other user 
               supplied density law. It can also calculate the rotation curve 
               for a spherical bulge.



WINDOW: ROTMOD
==============
               To get a                

               Stellar Bulge
               =============


Radii          (type: Input field (floats), keyword: BRADII=)
               Field will be filled if bulge radii was entered in a previous
               situation.


Mass           (type: Input field (float), keyword: B_MOD_MASS=)


Bulge Data:

Radii          B_MOD_RADIUS=
units          B_MOD_RUNIT=
distance       B_MOD_DISTANCE=
Densities      B_MOD_DENSITY=
units          B_MOD_DUNIT=


OK             B_MOD_OK=

               Stellar disk
               ============

Zlaw           D_MOD_ZLAW=
Z0             D_MOD_Z0=
Radii          DRADII= (DDATA=)
Mass           D_MOD_MASS=
Accuracy       D_MOD_ACCURACY=
DATA           D_MOD_USER=
PARAM          D_MOD_PARAM=


Disk data:

Radii          D_MOD_RADIUS=
units          D_MOD_RUNIT=
distance       D_MOD_DISTANCE=
Densities      D_MOD_DENSITY=
units          D_MOD_DUNIT=

Disk parameters:

Dens_0         D_MOD_DENS0=
R_cutoff       D_MOD_RCUT= 
H              D_MOD_H=
Delta          D_MOD_DELTA=

CLOSE          ROTMOD=
OK             D_MOD_OK=

               Gaseous disk
               ============
               Same keywords as above, except the prefix. This is G_ 
               instead of D_.



WINDOW: XVPLOT 
==============


Inset          (type: Input field (text), keyword: XV_INSET=)
               Example:  mjf7524s30 dec 0


Box            (type: Input field (4 floats), keyword: XV_BOX=)
               Example:  -80 -24 80 25


Levels         (type: Input field (floats), keyword: XV_LEVELS=)
               Example:  1:13:2    From level 1 to level 13 in steps of 2


Inclinations   (type: Input field (floats), keyword: XV_INC=)
               Input in degrees. 
               Example:  46::31    For all (=31) radii the same number


pos.angles     (type: Input field (floats), keyword: XV_PA=) 
               Input in degrees.
               Example:  327::31   For all (=31) radii 327 degrees


Syst.vel.      (type: Input field (1 float), keyword: XV_SYSV=)
               The units of the systemic velocity is km/s.
               Example:  320

Slice Pa       (type: Input field (1 float), keyword: XV_SLICEPA=)
               Angle of the slice with which the xv map was created.
               the input is a number in degrees. 
               Example:  327


D(Mpc)         (type: Input field (1 float), keyword: XV_DISTANCE=)
               Distance of the galaxy in Mpc. This number is needed to 
               convert the offsets in the XV map in minutes of arc, to 
               Kpc.  The conversion from arcmin to kpc is:
               x(kpc) = x(arcmin) * 0.290888 * D(Mpc)


Close          (type: Button, keyword: XVPLOT=)
               Hide window.


GO             (type: Button, keyword: XV_GO=)
               Make a contour plot for a set of levels of data from
               a GIPSY set.



WINDOW: CHI2PLOT
================

x:             (type menu, keyword VARNAME1=)
               Enter variable from the list for the x labels and scaling.
               Together with a variable for y: a chi-square landscape can be 
               plotted.
               The boundaries for each variable is copied from the value in the 
               corresponding valuator. For a sample of n x m data points a 
               contour plot is made. The contour levels are entered in the 
               LEVELS input field. The sample sizes are set in the 
               sample size: input field. The default size is 20 x 20.


y:             (type menu, keyword VARNAME2=)
See x:


MODE           (type menu, keyword CHI2MODE=)
               Select a mode for the chi-square plot. The options are
               1) Chi-square 
               2) Confidence intervals
               See also description at 'Levels'.


GO/STOP        (type button, keyword GO=)
               Make the chi-square plot, i.e. calculate the data and draw the
               contours. However, calculating the minimum chi-square at all
               the sample points can take a while. Therefore this process
               can be interrupted by pressing the <GO/STOP> button again. 


Levels         (type: input field, keyword LEVELS=)
               Enter values for the chi-square landscape. Input depends 
               on the mode of the plot. 
               1) Reduced chi-square, needs levels in reduced chi-square. 
                  Default is a logarithmic scale.
               2) Goodness of fit needs levels in probabilities between 0 and 1.
                  Default are the probabilities 0.1 0.2 .... 1.0
               3) Confidence intervals needs levels expressed in sigma e.g. 
                  Levels: 1 2 3 4 5
                  Default are the levels 1 2 3 4 5 (sigma).

               A default for each situation is used if nothing was specified 
               before you started to plot. If you change mode, a new default 
               is calculated, otherwise, while replotting, the levels do not 
               change unless you enter new values.


CLOSE          (type button, keyword CHI2PLOT=)
               Close the chi-square landscape  window.
            
#end section 6



#begin section 7

                             Configuration
                             -------------

There are three different ways to configure your application:

1) Configure colours and fonts with an X application resource file
2) Configure contents Vt and Vu menu's
3) Use a GIPSY defaults file to set the initial program status, or use a 
   saved parameter file with keywords to restore a previous program status.
4) Use hidden keyword PLOTSIZE= to start with a different size of the main 
   window.

ad 1) 
Create a file with the name 'XGgi' in the directory where you want to
run GIPSY. See also "Graphical User Interface" item in HELP menu.


ad 2)
It is possible to add your own functions in the Vt and Vu menu's. Create
a file on disk with first line the name of your function and second 
line the expression. Repeat this for all your personal functions.
Start ROTMAS with one or both of the keywords VUMENUFILE= or VTMENUFILE=
followed by the name of your file on disk. 
Example: The personal menu file addexpr.txt contains the lines

Modified standard
sqrt(mg*Vg*abs(Vg)+(md+mb)*Vd**2+Vb**2+Vu**2)  md = 1.2


Notice that you can also give initial values for the parameters.
Start ROTMAS with command: ROTMAS VTMENUFILE=addexpr.txt


ad 3)
You can pre specify keywords (and therefore also the contents of input fields
and the status of buttons) using a GIPSY defaults file. Once in ROTMAS you
can create such a file after pressing the FILE button and selecting the 
"save parameters". Make sure that if you want to restart ROTMAS with a default 
file, then the filename must end on '.def'. Suppose you created the file 
myrot.def. Then start ROTMAS with your new defaults with command: myrot(rotmas)
If you want to load ROTMAS parameters with the "load parameters" option
in the FILE menu, then the status of the program is restored to the status
as described in the parameter file. The latter method is always used in a
running program.


ad 4)
If you want a different size of the main window, use keyword PLOTSIZE=
at start up. This keyword accepts two integer numbers for the plotsize
in pixels in x- and y direction.
Example: ROTMAS PLOTSIZE=500 400

#end section 7


#begin section 8
                                Hardcopy
                                --------

If a device is selected (menu "PLOTTER") and the <PLOT> button is
pushed, then the window with the rotation curves is plotted and
if the window with the XV map is open, also the XV map with overlay 
velocities is plotted. There is not a possibility to make a hardcopy of
the chi-square landscape. However, the chi-square data can be saved to disk
using the appropriate save option in the file menu.

#end section 8


#begin section 9
                               About
                               -----

Version:       1.1

Purpose:       Interactive modeling of rotation curves

Category:      MODELS, ROTATION-CURVES, VELOCITY-FIELDS

File:          rotmas.src

Author:        M.G.R. Vogelaar (GUI: J.P. Terlouw)

Keywords:      See sections below.
  
Example:       .......

Updates:       Mar 03, 1998: VOG, Document created.
               Jul 24, 2000: VOG, Small chi2/goodness of fit changes.
               Apr 15, 2009: VOG, Removed unused definition of NINT().
                                  Initialized string 'dummy' to ""
                                  otherwise a weird error was displayed
               May 29, 2011: VOG, Added extra component 'Vx' for 
                                  molecular gas (CO en H_2).
                                  Also added new entry for Vu:
                                  Navarro-Frenk-White profile.
               Sep 12, 2014: VOG, Bug in plot label Vx removed

Note:          This document is used by program ROTMAS to extract text
               for each item in a help menu. The sections are identified 
               by: 
               #begin section n
               where n is a number, and the end of a section is marked by:
               #begin section n

Email          M.G.R. Vogelaar       (email: vogelaar@astro.rug.nl) 
               J.P. Terlouw (Gui)    (email: terlouw@astro.rug.nl)


New:           Added "load parameters" option in FILE menu. With this 
               option you can restore a previous status of ROTMAS without 
               the need to restart the program.
#end section 9
#<

#>            gui.h
#if !defined(_gui_h_)
#define _gui_h_
void gui(void);                             /* activate GUI */
void funcpar(int nnames,                    /* parameter manipulation objects */
             char **names, float *values, float *minima, float *maxima);
void vumenu( char** names, char** expr);    /* user function menu */
void vtmenu( char** names, char** expr);    /* total function menu */
void chi2menu( char** names );              /* chi-squared plot mode */
void gui_status(char *message, int lineno); /* display status message */
void gui_error(char *message);              /* display error message */
void gui_chi2(char *value);                 /* display chi-squared value */
#endif

#<

#>            hidden.h
#if !defined(_hidden_h_)
#define _hidden_h_
ident Hidden(char*);
#endif

#<

#>            inpmod.h
#if !defined(_inpmod_h_)
#define _inpmod_h_
ident Inpmod(char*);
#endif

#<

#>            fileform.h
#if !defined(_fileform_h_)
#define _fileform_h_
ident Fileform(char*);
void  ask_overwrite(void);
#endif

#<

#>            inputs.h
#if !defined(_inputs_h_)
#define _inputs_h_
ident Inputs(char*);
#endif

#<

#>            xvplot.h
#if !defined(_xvplot_h_)
#define _xvplot_h_
ident Xvplot(char*);
bool  xvup(void);
#endif

#<

#>            subsvar.h
#if !defined(_subsvar_h_)
#define _subsvar_h_
extern int subsvar( char *, char *, char *, char * );
#endif
#<

#>            paramform.h
#if !defined(_paramform_h_)
#define _paramform_h_
ident Paramform(char*);
#endif

#<

#>            gammaq.h
#if !defined(_gammaq_h_) 
#define _gammaq_h_
extern float gammaq( float, float, char * );
extern float confidence( float, float, float, char * );
#endif
#<

#>            ggiverify.h
#if !defined(_ggiverify_h_)
#define _ggiverify_h_
void ggiverify(char *question, char *key, int *arg);
#endif

#<

#>            chi2plot.h
#if !defined(_chi2plot_h_)
#define _chi2plot_h_
ident Chi2plot(char*, char**);
void SetChi2Labels(void);
#endif

#<

#>            chi2form.h
#if !defined(_chi2form_h_)
#define _chi2form_h_
ident Chi2form(char*);
void  ask_chi2over(void);
#endif

#<

#>            colormenus.h
#if !defined(_colormenus_h_)
#define _colormenus_h_
void ColorMenus(char *key);
#endif
#<

#>            rotmas.c
/* rotmas.c -XT
                            COPYRIGHT (c) 1998
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.


*/

/*  rotmas.c: include files     */

#include    "stdio.h"        /* Defines ANSI C input and output utilities */
#include    "stdlib.h"       /* Defines the ANSI C functions for number */
                             /* conversion, storage allocation, and similar tasks.*/
#include    "string.h"       /* Declares the ANSI C string functions*/
                             /* like:strcpy, strcat etc.*/
#include    "math.h"         /* Declares the mathematical functions and macros.*/
#include    "cmain.h"        /* Defines the main body of a C program with */
                             /* MAIN_PROGRAM_ENTRY and IDENTIFICATION */
#include    "gipsyc.h"       /* Defines the ANSI-F77 types for Fortran to C intface */
                             /* including def. of char2str,str2char,tofchar,zadd */
                             /* and macros tobool and toflog */
#include    "float.h"        /* Definition of FLT_MAX etc.*/
#include    "ctype.h"        /* Declares ANSI C functions for testing characters */
                             /* like: isalpha, isdigit etc. also tolower, toupper.*/


/* Common includes */

#include    "init.h"         /* Declare task running to HERMES and initialize.*/
#include    "finis.h"        /* Informs HERMES that servant quits and cleans up the mess.*/
#include    "anyout.h"       /* General character output routine for GIPSY programs.*/
#include    "setfblank.h"    /* Subroutine to set a data value to the universal BLANK.*/
#include    "setdblank.h"    /* Double version */
#include    "error.h"        /* User error handling routine. */
#include    "myname.h"       /* Obtain the name under which a GIPSY task is being run.*/
#include    "nelc.h"         /* Characters in F-string discarding trailing blanks.*/
#include    "wkey.h"         /* Write keywords to task's own parameter list */


/* User input routines */

#include    "userfio.h"      /* Easy-C companions for user interface routines.*/
#include    "userint.h"      /* User input interface routines.*/
#include    "userlog.h"
#include    "userreal.h"
#include    "userdble.h"
#include    "usertext.h"
#include    "usercharu.h"
#include    "userchar.h"
#include    "reject.h"       /* Reject user input.*/
#include    "cancel.h"       /* Remove user input from table maintained by HERMES.*/
#include    "status.h"


/* Input of sets */

#include    "gdsinp.h"       /* Input of set, subsets, return # subsets.*/
#include    "gdspos.h"       /* Define a position in a subset.*/
#include    "gdsbox.h"       /* Define a box inside/around a subset.*/
#include    "gdsc_range.h"   /* Return lower left and upper right corner of a subset.*/
#include    "gdsc_ndims.h"   /* Return the dimensionality of a coordinate word.*/
#include    "gdsc_grid.h"    /* Extract grid value.*/
#include    "gdsc_fill.h"    /* return coordinate word filled with a grid */
                             /* value for each axis.*/
#include    "gdsi_read.h"    /* Reads data from (part of) a set.*/
#include    "gdsd_rdble.h"


/* Axis conversions */

#include    "grtoph.h"
#include    "phtogr.h"
#include    "axunit.h"
#include    "factor.h"


/* PGPLOT includes */

#include    "pgplot.h"       /* All PGPLOT includes. */


/* Function evaluation */

#include    "dydx.h"         /* Determine derivative of a mathematical expression */
#include    "fieini.h"       /* Decodes a string containing  a mathematical expression for FIEDO */
#include    "fiedo.h"        /* FIEDO evaluates the code generated by FIEINI */
#include    "fiepar.h"       /* Defines the parameter names for the next call to FIEINI */
#include    "fieclr.h"       /* Clears code previous generated by FIEINI */


/* Fit related */

#include    "lsqfit.h"       /* Make lst-squares fit of a function to a set of data points */


/* Other includes: */

#include    "gui.h"          /* Local GUI for this program, included as a function */
#include    "ggi.h"          /* Describes Ggi, the GIPSY graphical user interface */
#include    "minmax1.h"      /* Minimum and maximum in real arrays */
#include    "spline1.h"      /* 1D cubic spline interpolation */
#include    "time.h"         /* Defines ANSI C date and time functions */
#include    "timer.h"        /* Cpu timer functions */
#include    "gammaq.h"
#include    "ggiverify.h"
#include    "fileform.h"
#include    "xvplot.h"
#include    "chi2form.h"
#include    "subsvar.h"
             


/* DEFINITIONS: */

/* Initialize Fortran compatible string with macro 'fmake' */

#define fmake(fchr,size) { \
                           static char buff[size+1];\
                           int i;\
                           for (i = 0; i < size; buff[i++] = ' ');\
                           buff[i] = 0;\
                           fchr.a = buff;\
                           fchr.l = size;\
                         }

/* Calloc version of 'fmake. Strings allocated with'  */
/* finit, must be freed with free( fc.a ) */
#define finit( fc , l ) { fc.a = calloc( ( (l) + 1 ) * sizeof( char ) ) ;\
                            fc.a[ l ] = '\0' ;\
                            fc.l = l; }

#define MYMAX(a,b)     ( (a) > (b) ? (a) : (b) )
#define MYMIN(a,b)     ( (a) > (b) ? (b) : (a) )
#define ANYLEN(s)      ( strlen(s) > 128 ? 128 : strlen(s) )
#define SIGN(a)        ( (a) > (0.0) ? (1.0) : (-1.0) )
#define ABS(a)         ( (a) < 0 ? (-(a)) : (a) )
#define PI             3.141592653589793
#define RAD(a)         ( (a) * 0.017453292519943295769237 )
#define DEG(a)         ( (a) * 57.295779513082320876798155 )

#define RELEASE        "1.1 Apr 28, 2011"  /* Version number */
#define MAXAXES        10         /* Max. axes in a set */
#define MAXSUBSETS     1          /* Max. allowed subsets */
#define MAXBUF         4096       /* Buffer size for I/O */
#define STRLEN         256        /* Max length of strings */
#define FILENAMELEN    256        /* Max length of file names */
#define FITSLEN        20         /* Max length of header items etc.*/
#define NONE           0          /* Default levels in userxxx routines */
#define REQUEST        1
#define HIDDEN         2
#define EXACT          4
#define YES            1          /* C versions of .TRUE. and .FALSE. */
#define NO             0
#define MAXPOINTS      16384      /* 8 K for dummy buffer for floats */
#define MAXLEVELS      256        /* Max. number of levels for contour plots */

#define MAXVAR         32         /* Max # of variables in dark halo expression */
#define MAXVARLEN      16         /* Max. legth of variable name */
#define MAXPAR         (MAXVAR-5)   /* Number of changeable parameters. TODO: Why 5? */
#define MAXEXPRLEN     1024       /* Max length of d.h. expression */
#define MAXDERVLEN     4096       /* Derivative usually is a longer expression */

#define DEBUG          16         /* Hermes output test mode */
#define FIRSTLINE      0          /* Lines for the gui_status routine */
#define SECONDLINE     1
#define THIRDLINE      2
#define FOURTHLINE     3

#define FIXED          0          /* Parameters are fixed or free in a fit */
#define FREE           1

#define ERASE          1          /* Flag to erase plotted V's */
#define NO_ERASE       0

#define INVISIBLE      0
#define VISIBLE        1
#define VISUNCHANGED   2

#define SCREEN         0
#define HARDCOPY       1

/* Define colours */

#define BACKGROUND     0
#define FOREGROUND     1
#define WHITE          1
#define RED            2
#define GREEN          3
#define BLUE           4
#define CYAN           5
#define MAGENTA        6
#define YELLOW         7
#define ORANGE         8
#define GREENYELLOW    9
#define GREENCYAN      10
#define BLUECYAN       11
#define BLUEMAGENTA    12
#define REDMAGENTA     13
#define DARKGRAY       14
#define LIGHTGRAY      15

/* Define Fonts */

#define ROMAN          2

/* Define symbols */

#define PLUS           2
#define BIGCIRCLE      23

/* Define line styles */

#define FULL_LINE      1              /* PGPLOT related */
#define DASHED         2
#define DOTTED         4

/* Curve indices */

#define BULGE          0              /* Define indices for the arrays */
#define DISK           1
#define GAS            2
#define OTHER          3
#define OBSERVED       4
#define OBSERR         5
#define RADII          6

#define BULGESCALED    7              /* Scaled data for BULGE,DISK and GAS */
#define DISKSCALED     8
#define GASSCALED      9
#define OTHERSCALED    10
#define VTDAT          11             /* VTDAT:V=sqrt(Vb^2+Vd^2+Vg^2+Vdh^2) */
#define VUDAT          12             /* The Dark Halo data */
#define WEIGHTS        13             /* Array with the weights (1 or 1/sigma^2) */

#define NUMARRAYS      14             /* For dynamic allocations */
#define NUMCOMP        4              /* Bulge, gas, disk, Other */
#define SCALED         7              /* Offset in array indices for scaled data */
#define DATCURVES      4              /* Max. number of 'data' curves from file etc.*/
#define NUMSAVEARRAYS  11

#define BRADII         0
#define DRADII         1
#define GRADII         2
#define XRADII         3              /* Hier stond 4. Waarom? */


/* Identify the way of using the weights in the lsqfit */

#define WEIGHTS_UNI    0
#define WEIGHTS_ERR    1              /* Handy for in menu with more options */


/* Special for help items in 'printhelp' */

#define LASTSECTION    9              /* Highest section number in rotmas.dc1 */


/* PGPLOT viewports for different devices */

#define MAINVIEWPORT   0.12, 0.1, 0.95, 0.9     /* Main plot on screen */
#define VIEWPORTPLOT   0.1, 0.3, 0.9, 0.9       /* As plotted on paper/PSdevice */
#define CHI2VIEWPORT   0.1, 0.1, 0.9, 0.9       /* Small CHI2 plot */
#define XVVIEWPORT     0.1, 0.1, 0.9, 0.9       /* XV set overlay */


/* Chi2 plot modes */

#define CHI2LANDSCAPE  0
#define CONFIDENCE     1


/* Miscellaneous */

#define STANDARDVT     "sqrt(mg*Vg*abs(Vg)+md*Vd*abs(Vd)+mb*Vb*abs(Vb)+Vu**2)"
#define STANDARDOTHER  "sqrt(mg*Vg*abs(Vg)+md*Vd*abs(Vd)+mb*Vb*abs(Vb)+mx*Vx*abs(Vx)+Vu**2)"
#define STANDARDNOVB   "sqrt(mg*Vg*abs(Vg)+md*Vd*abs(Vd)+Vu**2)"
#define EXPONENTIAL    "sqrt(4*{PI}*4.321*sig0*r**2/(4*h)*(bi(0,0.5*r/h)*bk(0,0.5*r/h)-bi(1,0.5*r/h)*bk(1,0.5*r/h)))"
#define MOND           "sqrt((mg*Vg*abs(Vg)+md*Vd*abs(Vd)+mb*Vb*abs(Vb))*sqrt(1+sqrt(1+(2*r*a/(mg*abs(Vg)*Vg+md*Vd*abs(Vd)+mb*Vb*abs(Vb)))**2))/sqrt(2)) A=3734"
#define HERNQUIST      "sqrt(4.321*M0*1e4)*(sqrt(R))/(R0+R) R0=35 M0=55 R0_MIN=30 R0_MAX=40"
#define ISOTHERM       "sqrt(4*{PI}*4.321*rho*rc*rc*(1-(rc/r)*atan(r/rc))) RHO=7 RC=7"
#define NFW            "(R200/0.73)*sqrt(R200/R*((ln(1+C*R/R200)-(C*R/R200)/(1+C*R/R200))/(ln(1+C)-C/(1+C))))"
/* This is Navarro-Frenk-White profile */

static fint     setlevel = 0;
static float    blank;               /* Global value for BLANK. */
static float    fstore[MAXPOINTS];   /* For input radii routines */
static float    gstore[MAXPOINTS];   /* For input data routines */


/*--------------------------------------------------*/
/* The derivatives calculated in the LSQfit function*/
/* need to calculate the function value too. But    */
/* each call to derv_c is preceded by a call to     */
/* func_c. Therefore we store common parameters to  */
/* speed up calculations.                           */
/*--------------------------------------------------*/
typedef struct
{
   float    datain[MAXVAR];            /* Values of only the parameters in expr.*/
} lsqtype;

static lsqtype lastLSQ;


typedef struct
{
   float   chi2;                          /* Current chi2 */
   float   redchi2;                       /* Current reduced chi square */ 
   int     ndat;                          /* Number of contributions */
                                          /* i.e. not blanks and weight > 0 */
   int     nfree;                         /* Degrees of freedom */
} chi2type;


typedef struct
{
   int     arraylen[NUMARRAYS];        /* Array length for each curve or fie. */
   float   *dataptr[NUMARRAYS];        /* bulge/disk/gas arrays etc. */
   int     visible[NUMARRAYS];         /* Erase before plotting? */
   float   radiimin;                   /* Needed for PGPLOT window X limits */
   float   radiimax;
   float   observedmax;                /* Needed for PGPLOT window Y limits */
   float   observedmin;
   char    keys[DATCURVES+3][FITSLEN]; /* Keywords for the (file) input data + OBSERVED, OBSERR, RADII */
   char    radkeys[DATCURVES+1][FITSLEN];   /* Keywords for radii, B/D/G/XRADII, the +1 is not clear*/
   int     numdervs;
   int     color[NUMARRAYS];           /* Each data array can have its own color */
   fint    partid[MAXVAR-4];           /* Id's for derivatives */
   fint    Vt_id;                      /* Id for Vt function */
   fint    Vu_id;                      /* Id for Vu function */
   int     npars;                      /* # constants in Vuser expression */
   float   *indata;
   char    varsbuf[MAXVAR*MAXVARLEN];  /* Char. buffer for par. names in DH expr. */
   float   tol;                        /* Lsqfit tolerance */
   float   lab;                        /* Lsqfit mixing factor */
   int     lsqiters;
   fint    maxits;                     /* Lsqfit max. iterartions allowed */
   fint    weights;                    /* From menu: Uniform=0, errors=1 */

   /*--------------------------------------------------*/
   /* There are always 4 (=DATCURVES) parameters, Gas, */
   /* Bulge and Disk and Other. For a fit,             */
   /* there can be more                                */
   /* parameters, given by a dark halo function. The   */
   /* max. number of these parameters is MAXVAR. The   */
   /* length of each parameter cannot exceed MAXVARLEN */
   /* characters.                                      */
   /*--------------------------------------------------*/
   char    parname[DATCURVES+MAXVAR][MAXVARLEN];
   char    mscalename[DATCURVES][3];      /* Parameters mb, md, mg, mx are less than 3 characters*/
   float   parval[DATCURVES+MAXVAR];
   float   parerr[DATCURVES+MAXVAR];
   fint    freepar[DATCURVES+MAXVAR];     /* Fix/free in lsqfit */
   ident   sched_const[DATCURVES+MAXVAR]; /* id's of scheduled functions .... */
                                          /* corresponding to constants in DH expr. */
   ident   sched_fix[DATCURVES+MAXVAR];   /* Same for fix/free button */
   ident   savedataid;
   ident   plotcursorid;                  /* Cursor interaction function id */
   ident   chi2cursorid;                  /* id for chi2 landscape plot */
   char   *chi2axisnames[2];
   int     chi2index[2];                  /* Indices of current chi2 axes */
   chi2type chi2;                          /* Current chi2 */
   int     chi2mode;                      /* chi2 or red.chi2 or probabilities? */
   int     chi2stepx;                     /* Samples for chi2 landscape */
   int     chi2stepy;
   float  *chi2data;                      /* Results of chi2 landscape plot */
   float  *chi2X;
   float  *chi2Y;
   int     chi2datalen;
   char    chi2file[FILENAME_MAX];        /* Ascii file for chi2 data */
   char    filename[FILENAME_MAX];
   char    darkhalo[MAXEXPRLEN];          /* Store expressions for Vt and Dhalo */
   char    vtotal[MAXEXPRLEN];
   int     emptyVU;                       /* VU field empty */
   int     datasaved;                     /* Remember if data is saved once */
   int     onlyboxtxt;
   /*--------------------------------------------------*/
   /* Pointer to array with velocity and radius data   */
   /* points to an input array for the lsqfit function */
   /* in the routine that calculates the chi2          */
   /* landscape data. The data is reused if one presses*/
   /* the mouse button in this chi2 landscape. The     */
   /* current parameter values are used to make a fit  */
   /* and the curve that results from this is plotted. */
   /*--------------------------------------------------*/
   float   *VdVbVgVxR;
}
globaltype;


static globaltype  globals;



typedef struct
{
   fchar    name;                   /* Name of input set */
   char     buf[STRLEN];
   fint     subin[MAXSUBSETS];      /* Subset coordinate words */
   fint     axnum[MAXAXES];         /* Array of size MAXAXES containing the */
                                    /* axes numbers.  The first elements (upto */
                                    /* the dimension of the subset) contain the */
                                    /* axes numbers of the subset, the other */
                                    /* ones ontain the axes numbers outside the */
                                    /* the subset ordered according to the */
                                    /* specification by the user. */
   fint     axcount[MAXAXES];       /* Array of size MAXAXES containing the */
                                    /* number of grids along an axes as */
                                    /* specified by the user. The first elements */
                                    /* (upto the dimension of the subset) contain */
                                    /* the length of the subset axes, the other */
                                    /* ones contain the the number of grids along */
                                    /* an axes outside the subset. */
                                    /* the operation for each subset, Class 2 */
                                    /* is for applications for which the operation */
                                    /* requires an interaction between the different */
                                    /* subsets. */
   fint     subdim;                 /* Dimensionality of the subsets for class 1 applications */
   fint     setdim;                 /* Dimension of set. */
   fint     flo[MAXAXES];           /* Low  edge of frame in grids */
   fint     fhi[MAXAXES];           /* High edge of frame in grids */
   fint     blo[MAXAXES];           /* Low  edge of box in grids */
   fint     bhi[MAXAXES];           /* High edge of box in grids */
   fint     nsubs;                  /* Number of subsets entered */
   int      validbox;
   int      validset;
   float    *convertedV;
   float    *convertedR;
   float    *mirrorV;
   float    *mirrorR;
   float    *pa;
   float    *inc;
   int      inclen;
   int      palen;
   float    levels[MAXLEVELS];
   fint     numlevels;
   fchar    Vunits;
   char     vunits[FITSLEN];
   double   Vtokms;
   double   Xtoarcmin;
   double   offsetcdelt;
   float    Vsys;
   float    slicePA;
   float    galaxydist;
   float    xlo, xhi, vlo, vhi;      /* XV box in physical coordinates */
   int      visibleVT;
   int      visibleVTmir;
} settype;

static settype  xvset;




static void clearstr( fchar Fstr )
/*---------------------------------------------*/
/* Blank a Fortran string up to Len characters */
/*---------------------------------------------*/
{
   int    i;
   fint   len = Fstr.l;


   for (i = 0; i < (int) len; i++) {
      Fstr.a[i] = ' ';
   }
}




static void stamp( char *mes )
/*------------------------------------------------------------*/
/* PURPOSE: Put time and user name in string.                 */
/*------------------------------------------------------------*/
{
   struct tm   *ptr;
   time_t      lt;


   lt    = time( NULL );                       /* Get the coded calendar time */
   ptr   = localtime( &lt );
   strftime( mes, STRLEN, "%d-%b-%Y (%H:%M:%S)", ptr );
}





static void dydxerror( fint err,
                       char *mes )
/*------------------------------------------------------------*/
/* PURPOSE: Generate an error message for 'dydx' function.    */
/*------------------------------------------------------------*/
{
   if (err == -1)
      strcpy( mes, "Derivative error: syntax error" );
   else if (err == -2)
      strcpy( mes, "Derivative error: syntax error" );
   else if (err == -3)
      strcpy( mes, "Derivative error: unknown function" );
   else if (err == -4)
      strcpy( mes, "Derivative error: function too large for output argument" );
   else if (err == -5)
      strcpy( mes, "Derivative error: derivative too large for output argument" );
   else if (err == -6)
      strcpy( mes, "Derivative error: constant name too long for output argument" );
   else if (err == -7)
      strcpy( mes, "Derivative error: too many constants for output argument" );
}




static void lsqerr( int  err,
                    char *message,
                    char *statmes1,
                    char *statmes2 )
/*------------------------------------------------------------*/
/* PURPOSE: return lsqfit error in character string. Add      */
/* remark for status line.                                    */
/*------------------------------------------------------------*/
{
   if (err == -1)
   {
      strcpy( message, "Too many free parameters, maximum is 32" );
      strcpy( statmes1, "Enter an expression with less variables" );
      strcpy( statmes2, "" );
   }
   else if (err == -2)
   {
      strcpy( message, "No free parameters");
      strcpy( statmes1, "There is nothing to fit: Free one or more parameters" );
      strcpy( statmes2, "" );
   }
   else if (err == -3)
   {
      strcpy( message, "Not enough degrees of freedom" );
      strcpy( statmes1, "You have more free parameters than useable data points" );
      strcpy( statmes2, "" );
   }
   else if (err == -4)
   {
      strcpy( message, "Max. number of its. too small to obtain a solution which satisfies tol." );
      strcpy( statmes1, "Fix (more) parameters or improve initial estimates!" );
      strcpy( statmes2, "Or, change Max. Its. in FIT OPTIONS" );
   }
   else if (err == -5)
   {
      strcpy( message, "Diagonal of matrix in fit routine contains elements which are zero" );
      strcpy( statmes1, "Fix (more) parameters or change lambda in FIT OPTIONS." );
      strcpy( statmes2, "Perhaps your Vt or Vu uses a variable (Vb, Vg, Vd, Vx) for which there is no data" );
   }
   else if (err == -6)
   {
      strcpy( message, "Determinant of the coefficient matrix is zero" );
      strcpy( statmes1, "Try changing lambda in FIT OPTIONS." );
      strcpy( statmes2, "Or, increase number of data points" );
   }
   else if (err == -7)
   {
      strcpy( message, "Square root of negative number in fit procedure" );
      strcpy( statmes1, "Perhaps a fit is not possible for this situation" );
      strcpy( statmes2, "" );
   }
   else
   {
      strcpy( message, "Unknown error in lsqfit" );
      strcpy( statmes1, "" );
      strcpy( statmes2, "" );
   }
}




static void inifieerror( fint err,
                         fint errpos,
                         char *mes )
/*------------------------------------------------------------*/
/* PURPOSE: Generate an error message for 'inifie'.           */
/*------------------------------------------------------------*/
{
   if (err == -2)
      strcpy( mes, "No storage space left to initialize function.");
   else if (err == -1)
      sprintf( mes, "Syntax error in expression at position %d",
               errpos );
}




static void setwindow( float  xlo,
                       float  ylo,
                       float  xhi,
                       float  yhi )
/*------------------------------------------------------------*/
/* Purpose: C version of pgswindow, sets the plot window.     */
/* Note the permutation in parameter order.                   */
/*------------------------------------------------------------*/
{
   pgswin_c( &xlo, &xhi, &ylo, &yhi );
/*   pgpage_c();*/
}




static void setcolor( int col )
/*------------------------------------------------------------*/
/* Purpose: C version of pgsci, sets the color.               */
/*------------------------------------------------------------*/
{
   fint  color = (fint) col;
   pgsci_c( &color );
}




static void setcharheight( float ch )
/*------------------------------------------------------------*/
/* Purpose: C version of pgsch_c                              */
/*------------------------------------------------------------*/
{
   pgsch_c( &ch );
}




static void getcharheight( float *ch )
/*------------------------------------------------------------*/
/* Purpose: C version of pgqch_c                              */
/*------------------------------------------------------------*/
{
   pgqch_c( ch );
}




static void setlinewidth( int lw )
/*------------------------------------------------------------*/
/* Purpose: C version of pgslw_c                              */
/*------------------------------------------------------------*/
{
   fint   lwi = (fint) lw;

   pgslw_c( &lwi );
}




static void getlinewidth( int *lw )
/*------------------------------------------------------------*/
/* Purpose: C version of pgqlw_c                              */
/*------------------------------------------------------------*/
{
   fint  lwi = (fint) *lw;

   pgqlw_c( &lwi );
   *lw = (int) lwi;
}





static void clearscreen( void )
/*------------------------------------------------------------*/
/* Purpose: C version of pgpage, erase screen contents.       */
/*------------------------------------------------------------*/
{
   pgpage_c();
}



static void hermesstatus( char *txt )
/*------------------------------------------------------------*/
/* PURPOSE: Update status in hermes status                    */
/*------------------------------------------------------------*/
{
   status_c( tofchar(txt) );
}




static void clearstatus( void )
/*------------------------------------------------------------*/
/* PURPOSE: Clear status and error messages in gui.           */
/*------------------------------------------------------------*/
{
   gui_error( "" );
   gui_status( "", FIRSTLINE );
   gui_status( "", SECONDLINE );
   hermesstatus("");
}




static void toupperstr( char *s )
/*------------------------------------------------------------*/
/* Purpose: Convert a string to upper case.                   */
/*------------------------------------------------------------*/
{
   /* Convert to upper case */
   int i;
   for (i = 0; i < strlen( s ); i++)
   {
      s[i] = toupper( s[i] );
   }
}




static void plotpoints( int      ndat,
                        float    *x,
                        float    *y,
                        int      symbol,
                        int      color )
/*------------------------------------------------------------*/
/* Purpose: Plot series of points with given marker and color.*/
/*------------------------------------------------------------*/
{
   fint    n   = (fint) ndat;
   fint    sym = (fint) symbol;
   fint    oldcol;

   if (ndat <= 0)
      return;

   pgqci_c( &oldcol );
   setcolor( color );
   pgpt_c( &n, x, y, &sym );
   setcolor( oldcol );
}




static void plotcurve( int      ndat,
                       float    *x,
                       float    *y,
                       int      *visible,
                       int      color,
                       int      device )
/*------------------------------------------------------------*/
/* Purpose: Plot series of points connected by lines at given */
/*          color.                                            */
/*------------------------------------------------------------*/
{
   fint    n = (fint) ndat;
   fint    oldcol;
   bool    curmode;

   if (ndat <= 0)
      return;

   curmode = GgiPlotXor( YES );
   pgqci_c( &oldcol );
   setcolor( color );
   pgline_c( &n, x, y );
   setcolor( oldcol );
   (void) GgiPlotXor( NO );

   /* Change visibility status only if the device is screen and */
   /* not a hardcopy device. */
   
   if (device == SCREEN)
   {
      if (*visible)
         *visible = NO;
      else
         *visible = YES;
   }
}




static void error_status( char *errstr,
                          char *statstr1,
                          char *statstr2 )
/*------------------------------------------------------------*/
/* PURPOSE: Update status and error messages in gui.          */
/*------------------------------------------------------------*/
{
   gui_error( errstr );
   gui_status( statstr1, FIRSTLINE );
   gui_status( statstr2, SECONDLINE );
}




static void resetvisibility( globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: Set visibility of all curves to invisible.        */
/*------------------------------------------------------------*/
{
   int   i;

   for (i = 0; i < NUMARRAYS; i++)
   {
      g->visible[i] = NO;
   }
}




static void printhelp( int section )
/*------------------------------------------------------------*/
/* PURPOSE: Extract and show help text.                       */
/* The dc1 document is divided in sections that start with    */
/* #start section nr where nr is 1, 2, etc. The sections ends */
/* with #end section 1.                                       */
/* The input section number is already corrected for item 0   */
/* and the horizontal line.                                   */
/*------------------------------------------------------------*/
{
   char       path[FILENAME_MAX];
   char       docline[STRLEN+1];
   char       filename[FILENAME_MAX];
   char       searchstr[30];
   char       extract[FILENAME_MAX];
   int        found = NO;
   FILE       *fp, *fpO;


   strcpy( path, getenv("gip_root") );

   if (section == LASTSECTION + 2)
   {
      /* User want ROTMOD documentation */
      (void) sprintf( filename, "%s/tsk/rotmod.dc1", path );
      fp = fopen( filename, "r" );
      if (fp == NULL)
      {
         error_status( "Cannot open rotmod.dc1 for help", "", "" );
         return;
      }
      GgiShowDoc( filename );
      return;
   }
   
   if (section == LASTSECTION + 1)
   {
      /* User want ggi documentation */
      (void) sprintf( filename, "%s/doc/ggi.doc", path );
      fp = fopen( filename, "r" );
      if (fp == NULL)
      {
         error_status( "Cannot open ggi.doc for help", "", "" );
         return;
      }
      GgiShowDoc( filename );
      return;
   }
      
  

   (void) sprintf( filename, "%s/tsk/rotmas.dc1", path );
   fp = fopen( filename, "r" );
   if (fp == NULL)
   {
      /* Cannot open here, search in current directory. */
      fp = fopen( "rotmas.dc1", "r" );
   }
   if (fp == NULL)
   {
      error_status( "Cannot open rotmas.dc1 for help", "", "" );
      return;
   }
   tmpnam( extract );              /* Create unique name */
   fpO = fopen( extract, "w");
   if (fpO == NULL)
   {
      error_status( "Cannot open tmp file for help!",  "", "" );
      return;
   }

   sprintf( searchstr, "#begin section %d", section );

   do
   {
      fgets( docline, STRLEN, fp );
      found = (strstr( docline, searchstr ) != NULL);
   }
   while ( !found && !feof(fp) );

   sprintf( searchstr, "#end section %d", section );
   if (found && !feof(fp))
   {
      found = NO;
      do
      {
         fgets( docline, STRLEN, fp );
         found = (strstr( docline, searchstr ) != NULL);
         if (!found)
            fprintf( fpO, docline );
      }
      while ( !found && !feof(fp) );
   }
   if (section == LASTSECTION)
   {
      /* Add release info */
      fprintf( fpO, "\n \n   ROTMAS Release %s\n", RELEASE );
   }
   fclose (fpO );
   anyoutf( DEBUG, "tmp file = %s", extract );
   GgiShowDoc( extract );
   fclose( fp );
   remove( extract );
}




static void updateredchi2( globaltype *g )
/*------------------------------------------------------------*/
/* Purpose:  Calculate chi2 for current status.               */
/* The Vt array must be updated before calling this routine.  */
/*------------------------------------------------------------*/
{
   int   free = 0;
   int   ndat;
   int   i;
   char  mes[STRLEN];


   g->chi2.chi2 = 0.0;
   for (ndat = 0, i = 0; i < g->arraylen[RADII]; i++)
   {
      float chi = g->dataptr[OBSERVED][i] - g->dataptr[VTDAT][i];
      if (g->arraylen[OBSERR])
      {
         float sigma;
         if (g->weights == WEIGHTS_UNI)
            sigma = 1.0;
         else
         {
            if (g->arraylen[OBSERR] > 0)
               sigma = g->dataptr[OBSERR][i];
            else
               sigma = 1.0;
         }
         if (sigma != 0.0)
         {
            chi /= sigma;
            ndat++;
         }
         else
            chi = 0.0;
      }
      else
      {
         /* Do not alter chi2 */
         ndat++;
      }
      g->chi2.chi2 += chi * chi;
   }
   for (i = 0; i < g->numdervs; i++)
   {
      if (g->freepar[i] == FREE)
         free++;
   }
   sprintf( mes, "%10g", g->chi2.chi2 );
   gui_chi2( mes );
   g->chi2.redchi2 = g->chi2.chi2 / (float) (ndat-free);   
   g->chi2.nfree = free;
   g->chi2.ndat = ndat;
}




static void ploterrors( int      ndat,
                        float    *x,
                        float    *y,
                        float    *yerr,
                        int      color )
/*------------------------------------------------------------*/
/* Purpose: Plot series of points with given marker and color.*/
/*------------------------------------------------------------*/
{
   fint    n = (fint) ndat;
   fint    oldcol;
   fint    dir;
   float   termlen = 0.0;
   bool    curmode;

   if (ndat <= 0)
      return;

   curmode = GgiPlotXor( YES );
   pgqci_c( &oldcol );
   setcolor( color );
   dir = 2;
   pgerrb_c( &dir, &n, x, y, yerr, &termlen );
   dir = 4;
   pgerrb_c( &dir, &n, x, y, yerr, &termlen );
   setcolor( oldcol );
   (void) GgiPlotXor( curmode );
}




static bool UserLog(char *key)
/*------------------------------------------------------------*/
/* Purpose: Special version of userlog with default.          */
/*------------------------------------------------------------*/
{
   bool result = toflog(FALSE);
   fint fint1 = 1, fint2 = 2;

   (void) userlog_c( &result, &fint1, &fint2, tofchar(key), tofchar(" ") );
   return tobool( result );
}




static void getfloat( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Input routines for Tolerance and Lambda.          */
/*------------------------------------------------------------*/
{
    float      *userval = (float *) arg;
    fint       nitems = 1;
    fint       dfault = HIDDEN;

    (void) userreal_c( userval,
                       &nitems,
                       &dfault,
                       tofchar(key),
                       tofchar(" ") );
}




static void getint( ident id,
                    char  *key,
                    int   code,
                    void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Simple function to enter an integer.              */
/*------------------------------------------------------------*/
{
    int       *userval = (int  *) arg;
    fint       fintval;
    fint       nitems  = 1;
    fint       dfault  = HIDDEN;

    fintval = (fint) *userval;
    (void) userint_c( &fintval,
                      &nitems,
                      &dfault,
                      tofchar(key),
                      tofchar(" ") );
    *userval = (int) fintval;
}





static void getcol( ident id,
                    char  *key,
                    int   code,
                    void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Simple function to enter a PGPLOT colour.         */
/* Refresh the main plot window if a colour is changed.       */
/*------------------------------------------------------------*/
{
   int       *userval = (int  *) arg;
   fint       fintval;
   fint       nitems  = 1;
   fint       dfault  = HIDDEN;


   fintval = (fint) *userval;
   (void) userint_c( &fintval,
                     &nitems,
                     &dfault,
                     tofchar(key),
                     tofchar(" ") );
   if (fintval >=1 && fintval <= 15)
   {
      /* This is a valid PGPLOT colour */
      float   xlo, ylo, xhi, yhi;
      *userval = (int) fintval;                  
      pgqwin_c( &xlo, &xhi, &ylo, &yhi );      
      wkeyf("BOX=%g %g %g %g", xlo, ylo, xhi, yhi );
   }    
}




static void getweight( ident id,
                       char  *key,
                       int   code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: WEIGHTS= keyword handler.                         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint         fintval;
   fint         nitems  = 1;
   fint         dfault  = HIDDEN;


   fintval = (fint) g->weights;
   (void) userint_c( &fintval,
                     &nitems,
                     &dfault,
                     tofchar(key),
                     tofchar(" ") );
   g->weights = (int) fintval;
   if (g->arraylen[OBSERVED] > 0 && g->arraylen[VTDAT] > 0)
      updateredchi2( g );
}




static void plmove( float  x, float y )
/*------------------------------------------------------------*/
/* Purpose: C-versions of PGPLOT routines.                    */
/*------------------------------------------------------------*/
{
   pgmove_c( &x, &y );
}
static void pldraw( float  x, float y )
{
   pgdraw_c( &x, &y );
}
static void linestyle( int style )
{
   fint    Style = (fint) style;
   pgsls_c( &Style );
}





static void setmarker( float x, float y, fint sym )
/*-------------------------------------------------------------*/
/* PURPOSE: Set marker op x, y.                                */
/*-------------------------------------------------------------*/
{
   fint one = 1;
   pgpt_c( &one, &x, &y, &sym );
}
      



static void copyfromto( float  *in,
                        float  *out,
                        int    ndat,
                        float  mult )
/*------------------------------------------------------------*/
/* Purpose: Copy and multiply data from 'in' to 'out'.        */
/*------------------------------------------------------------*/
{
   int i;
   for (i = 0; i < ndat; i++)
   {
      out[i] = mult * in[i];
   }
}




static int getindex( float r,
                     float *R,
                     int   n )
/*------------------------------------------------------------*/
/* PURPOSE: Find index of r in array R.                       */
/*------------------------------------------------------------*/
{
   int  i = 0;
   int  found = NO;
   int  result = -1;

   while (i < n-1 && !found)
   {
      found = (r >= R[i] && r < R[i+1]);
      if (!found && i == n-2)
      {
         found = (r == R[i+1]);
         i++;
      }
      if (!found)
         i++;
   }
   if (found)
      result = i;

   return( result );
}




static double putinrangedeg( double angle )
/*------------------------------------------------------------*/
/* PURPOSE: Return angle between 0 and < 360.0                */
/*------------------------------------------------------------*/
{
   while (angle < 0.0)
      angle +=360.0;
   while (angle > 360.0)
      angle -=360.0;
   return( angle );
}



static double putinrangerad( double angle )
/*------------------------------------------------------------*/
/* PURPOSE: Return angle between 0 and < 2*PI                 */
/*------------------------------------------------------------*/
{
   double twopi = 2.0*PI;
   while (angle < 0.0)
      angle += twopi;
   while (angle > twopi)
      angle -= twopi;
   return( angle );
}




static double arctan( double y, double x )
/*------------------------------------------------------------*/
/* PURPOSE: Return arctangens between 0 and < 360.0           */
/*------------------------------------------------------------*/
{
   double r;
   r = atan2( y, x );
   if (r < 0.0)
      r += 2.0*PI;
   return( r );
}




static void readeventsfile( ident id,
                            char  *key,
                            int   code,
                            void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: PARLOAD= keyword handler.                       */
/* Read keywords from file and generate events with them.     */
/* With this option you can simulate pressing buttons with    */
/* commands in a file on disk.                                */
/*------------------------------------------------------------*/
{
   globaltype *g = (globaltype *) arg;
   FILE       *fp;
   fchar      Dummytxt; 
   fint       dfault, nitems, r;
   char       message[STRLEN+1];
   char       eventsfilename[FILENAMELEN];
   

   clearstatus(); 
    
   dfault = HIDDEN;
   nitems = 1;
   Dummytxt.l = FILENAMELEN-1;
   Dummytxt.a = eventsfilename;
   r = userchar_c( Dummytxt, &nitems, &dfault, tofchar(key), tofchar(" ") );
   Dummytxt.a[nelc_c(Dummytxt)] = '\0';
  
   fp = fopen( Dummytxt.a, "r" );
   if (fp == NULL)
   {
      gui_error( "Cannot open events file" );
      GgiPrompter( "AGAIN", "File does not exist" );
      return;            
   }     
   GgiPrompter( "ACCEPT", "" ); 
   clearstatus();
   while (!feof(fp))
   {
      if ( fgets(message, STRLEN, fp) );
      {
         if (!feof(fp))                 /* Extra check on end of file */
         {
            wkeyf( message );
            (void) GgiHandleEvents();
         } 
      }
   }
   fclose( fp );   
}




static void fillpars( globaltype  *g )
/*------------------------------------------------------------*/
/* Purpose: */
/*------------------------------------------------------------*/
{
   int   i, par;
   int   alen = g->arraylen[RADII];

   for (i = 0; i < alen; i++)
   {
      float  val;
      for (par = 0; par < g->npars; par++)
      {
         g->indata[par*alen+i] = g->parval[par];        /* The constants */
      }
      /*----------------------------------------*/
      /* Now add VD,VB,VG,VX, R and VU. Note that*/
      /* VU is always a dummy. The other vari-  */
      /* ables may or may not be needed but     */
      /* must be included because we fixed the  */
      /* order with 'fiepar'.                   */
      /*----------------------------------------*/
      if (g->arraylen[DISK] == 0)  val = 0.0; else val = g->dataptr[DISK][i];
      g->indata[par*alen+i] = val;   par++;
      if (g->arraylen[BULGE] == 0) val = 0.0; else val = g->dataptr[BULGE][i];
      g->indata[par*alen+i] = val;   par++;
      if (g->arraylen[GAS] == 0)   val = 0.0; else val = g->dataptr[GAS][i];
      g->indata[par*alen+i] = val;   par++;
      if (g->arraylen[OTHER] == 0)   val = 0.0; else val = g->dataptr[OTHER][i];
      g->indata[par*alen+i] = val;   par++;
      
      g->indata[par*alen+i] = g->dataptr[RADII][i]; par++;
      if (g->arraylen[VUDAT] == 0) val = 0.0; else val = g->dataptr[VUDAT][i];
      g->indata[par*alen+i] = val;    /* Vu, if any */
   }
}




static void calcVtdat( globaltype  *g )
/*------------------------------------------------------------*/
/* Purpose: Calculate the curve which represents the summed   */
/* data.                                                      */
/*                                                            */
/* The DEFAULT resulting velocity is given by:                */
/*                                                            */
/*                                                            */
/* V_t = sqrt(mg*Vg*abs(Vg)+md*Vd**2+mb*Vb**2+Vu**2)          */
/*                                                            */
/*------------------------------------------------------------*/
{
   int    alen = g->arraylen[RADII];
   fint   r, n;


   /* Is there anything for calculating a total curve ? */
   /* Not (yet) a function for Vt */
   if (g->Vt_id == -1)
   {
      return;
   }

   /* There is a total curve to plot */
   fillpars( g );

   n = (fint) alen;
   r = fiedo_c( g->indata, &n, g->dataptr[VTDAT], &(g->Vt_id) );
   if (r == -1)
      error_status( "Problems evaluating Vt", "id out of range", "" );
   if (r == -2)
      error_status( "Problems evaluating Vt",
                    "No code generated by routine fieini", "" );

   /* Suspicious point at R=0 ? */
   if (g->dataptr[VTDAT][0] == blank)
      g->dataptr[VTDAT][0] = 0.0;

   g->arraylen[VTDAT] = g->arraylen[RADII];
   updateredchi2( g );
}




static void calcVudat( globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: For given values for the function parameters,     */
/*          evaluate the dark halo function.                  */
/*------------------------------------------------------------*/
{
   int    alen;
   fint   r, n;

   alen = g->arraylen[RADII];
   if (alen == 0)
   {
      error_status( "There are no radii available!",
                    "Press INPUTS button to enter 'observed' radii", "" );
      return;
   }
   if (g->arraylen[OBSERVED] == 0)
   {
      error_status( "There is no observed data available!",
                    "Press INPUTS button to enter 'observed' data points", "" );
      return;
   }

   fillpars( g );

   n = (fint) alen;
   r = fiedo_c( g->indata, &n, g->dataptr[VUDAT], &(g->Vu_id) );
   if (r == -1)
      error_status( "Problems evaluating Vu", "id out of range", "" );
   if (r == -2)
      error_status( "Problems evaluating Vu",
                    "No code generated by routine fieini", "" );

   if (g->dataptr[VUDAT][0] == blank)
      g->dataptr[VUDAT][0] = 0.0;

   if (g->emptyVU)
      g->arraylen[VUDAT] = 0;
   else
      g->arraylen[VUDAT] = g->arraylen[RADII];
}




void initplot( char  *devspec,
               float  xl,
               float  yb,
               float  xr,
               float  yt,
               fint   nsubx,
               fint   nsuby )
/*------------------------------------------------------------*/
/* PURPOSE: Initialze PGPLOT.                                 */
/* Initialize plot software. Set viewport                     */
/*------------------------------------------------------------*/
{
   fint   unit;            /* Ignored by pgbeg, use unit=0. */
   fint   nxysub[2];       /* Number of subdivisions on 1 page. */
   fint   r;


   /*--------------------------------------------------*/
   /* Initialize PGPLOT with a call to 'pgbeg'.        */
   /* There are 4 arguments for PGBEG:                 */
   /* UNIT, this argument is ignored by PGBEG (use     */
   /*       zero).                                     */
   /* FILE, If this argument is a question mark PGBEG  */
   /*       will prompt the user to supply a string.   */
   /* NXSUB, # sub divisions of the view surface in X. */
   /* NYSUB, # sub divisions of the view surface in Y. */
   /*--------------------------------------------------*/

   nxysub[0] = nsubx;
   nxysub[1] = nsuby;
   unit = 0;                                 /* Argument is ignored by PGPLOT */
   r = pgbeg_c( &unit,
                tofchar(devspec),
                &nxysub[0],
                &nxysub[1] );

   /* Device cannot be opened! */
   if (r != 1)
   {
      error_status( "Cannot open output device!",
                    "Reason unknown", "" );
   }
   /* Set viewport */
   pgsvp_c( &xl, &xr, &yb, &yt );
}




void drawbox( float  Xmin,
              float  Ymin,
              float  Xmax,
              float  Ymax,
              char  *xtitle,
              char  *ytitle,
              char  *ttitle,
              int    devtype )
/*------------------------------------------------------------*/
/* PURPOSE: Draw frame with labels for input box.             */
/* Draw box and labels. Take special care for the y labels    */
/* and title. Colors are defined globally. Xmin etc are the   */
/* corners of the box in world coordinates.                   */
/*------------------------------------------------------------*/
{
   float  charsize = 1.0;
   float  delta;
   fint   lwidth;
   fint   r;
   fint   nitems;
   fint   dfault;
   float  pg_box[4];                                  /* Corners of draw box. */
   fint   font;
   fint   color;
   fint   nxsub, nysub;
   float  xtick, ytick;
   char   message[STRLEN];


   /* Increase the size of the (default) box a little */
   delta = fabs( Xmax - Xmin ) / 10.0;
   if (delta == 0.0)
      delta = 1.0;
   Xmin = 0.0;
   Xmax += delta;
   Ymin = MYMIN( 0.0, Ymin );
   delta = fabs( Ymax - Ymin ) / 10.0;
   if (delta == 0.0)
      delta = 1.0;
   Ymin -= delta;
   Ymax += delta;
   pg_box[0] = Xmin;                              /* Get size from user input */
   pg_box[1] = Ymin;
   pg_box[2] = Xmax;
   pg_box[3] = Ymax;
   nitems = 4;
   dfault = HIDDEN;
   anyoutf( DEBUG, "Corners of box Xl,Yl, Xh,Yh:  [%f,%f,%f,%f]",
            Xmin, Ymin, Xmax, Ymax );
   r = userreal_c( pg_box,
                   &nitems,
                   &dfault,
                   tofchar("BOX="),
                   tofchar( message ) );

   Xmin = pg_box[0];
   Ymin = pg_box[1];
   Xmax = pg_box[2];
   Ymax = pg_box[3];

   globals.onlyboxtxt = YES;               /* Prevent execution of this event */
   wkeyf( "BOX=%g %g %g %g", Xmin, Ymin, Xmax, Ymax );

   setwindow( Xmin, Ymin, Xmax, Ymax );


   if (devtype == SCREEN)
      clearscreen();                                   /* Advance to new page */

   lwidth = 2;
   pgslw_c( &lwidth );                                      /* Set line width */

   charsize = 1.0;
   pgsch_c( &charsize );                                  /* Character height */

   font   = ROMAN;
   pgscf_c( &font );                                              /* Set font */

   color = FOREGROUND;                                           /* Set color */
   setcolor( color );

   /*----------------------------------------------------------------*/
   /* xtick is world coordinate interval between major tick marks    */
   /* on X axis. If xtick=0.0, the interval is chosen by PGBOX, so   */
   /* that there will be at least 3 major tick marks along the axis. */
   /* nxsub is the number of subintervals to divide the major        */
   /* coordinate interval into. If xtick=0.0 or nxsub=0, the number  */
   /* is chosen by PGBOX.                                            */
   /* BCNSTV :                                                       */
   /* B: draw bottom (X) or left (Y) edge of frame.                  */
   /* C: draw top (X) or right (Y) edge of frame.                    */
   /* N: write Numeric labels in the conventional location below     */
   /*    the viewport (X) or to the left of the viewport (Y).        */
   /* S: draw minor tick marks (Subticks).                           */
   /* T: draw major Tick marks at the major coordinate interval.     */
   /* V: orient numeric labels Vertically. This is only applicable   */
   /*    to Y.                                                       */
   /*----------------------------------------------------------------*/
   xtick = ytick = 0.0;
   nxsub = nysub = 0;
   pgbox_c( tofchar("ABCNST" ), &xtick, &nxsub,
            tofchar("BCNSTV"), &ytick, &nysub );

   /*----------------------------------------*/
   /* Plot the titles. User decides with the */
   /* TOPTITLE= keyword what the annotation  */
   /* is.                                    */
   /*----------------------------------------*/
   {
      fchar Toptitle;
      fint  dfault = HIDDEN;
      char  toptitle[128+1];

      Toptitle.a = toptitle;
      Toptitle.l = 128;

      clearstr( Toptitle );
      Toptitle.l =  usertext_c( Toptitle,
                         &dfault,
                         tofchar("TOPTITLE="),
                         tofchar("") );
      Toptitle.a[nelc_c(Toptitle)] = '\0';
       
     
      pglab_c( tofchar(xtitle), tofchar(ytitle), Toptitle );
   }
}




static void Vc2Vxy( float   *Rxy,
                    float   *Vxy,
                    float   *RMxy,
                    float   *VMxy,
                    float    Rc,
                    float    Vc,
                    float    incdeg,
                    float    padeg,
                    float    Vsys,
                    float    sl_angledeg )
/*------------------------------------------------------------*/
/* PURPOSE: Convert circular velocity at radius R to line of  */
/*          sight velocity Vxy.                               */
/* 'phi' enters as an angle wrt the +Y axis. Units are degree.*/
/* 'radius' is the rotation curve radius in arcsec or kpc.    */
/*------------------------------------------------------------*/
{
   double   beta;
   double   theta;
   double   costheta;
   double   cosinc, sininc;
   double   sl_anglerad;
   double   phirad, incrad;
   float    Vc_deproj;


   incrad      = RAD( incdeg );
   cosinc      = cos( incrad );
   sininc      = sin( incrad );
   phirad      = RAD( putinrangedeg(padeg) );
   sl_anglerad = RAD( putinrangedeg(sl_angledeg) );


   beta = putinrangerad( sl_anglerad - phirad );
   theta = arctan( tan(beta), cosinc );
   costheta = cos( theta );
   *Rxy  = Rc * (float) ( costheta / cos( beta )  );
   *RMxy = -(*Rxy);

   Vc_deproj = Vc * (float) ( sininc * costheta );
   *Vxy  = Vsys + Vc_deproj;
   *VMxy = Vsys - Vc_deproj;
}




static void plotinXV( settype     *inset,
                      int         ndat,
                      float       *R,
                      float       *V,
                      int         color )
/*------------------------------------------------------------*/
/* Purpose: Plot deprojected velocity in XV plot              */
/* Function must be called after an update of Vt in the main  */
/* plot window.                                               */
/*------------------------------------------------------------*/
{
   int      i;
   float    xlo, xhi, ylo, yhi;
   float    xloold, xhiold, yloold, yhiold;
   int      convert = (inset->palen > 0 && inset->inclen > 0);



   if (!xvup())
      return;
   if (!inset->validbox)
   {
      error_status( "Cannot plot in XV plot", "No valid box or set entered",
                    "Use XVPLOT input to enter set/box" );
      return;
   }
   if (!convert)
   {
      error_status( "Cannot plot in XV plot",
                    "Missing inclinations or position angles",
                    "Use XVPLOT input to enter pa's or inclinations." );
      return;
   }

   /* Store old window parameters */
   pgqwin_c( &xloold, &xhiold, &yloold, &yhiold );
   initplot( "XVPLOT//APPEND", XVVIEWPORT,1,1 ); /* open XVplot screen device */
   xlo = inset->blo[0]; xhi = inset->bhi[0];
   ylo = inset->blo[1]; yhi = inset->bhi[1];
   setwindow( inset->xlo, inset->vlo, inset->xhi, inset->vhi );

   if (inset->visibleVT)    /* Erase */
   {
      plotcurve( ndat,
                 inset->convertedR,
                 inset->convertedV,
                 &(inset->visibleVT),
                 CYAN,
                 SCREEN );
   }
   if (inset->visibleVTmir)
   {

      plotcurve( ndat,
                 inset->mirrorR,
                 inset->mirrorV,
                 &(inset->visibleVTmir),
                 CYAN,
                 SCREEN );
   }

   /*--------------------------------------------------*/
   /* User wants to plot rotation curve velocities as  */
   /* function of radius in an XV plot. However, the   */
   /* velocities are circular velocities. These        */
   /* velocities characterize tilted rings which also  */
   /* have an inclination and position angle. Together */
   /* with systemic velocity and slice angle, the      */
   /* circular velocities can be transformed to line   */
   /* of sight velocities needed for the XV plot.      */
   /*                                                  */
   /* Variables:                                       */
   /*                                                  */
   /* R[i]               :tilted ring radius in kpc    */
   /* V[i]               :ring velocity in km/s        */
   /* inset->inc[i]      :inclination of ring i        */
   /* inset->pa[i]       :pos angle of ring i          */
   /* inset->Vsys        :Systemic velocity            */
   /* inset->slicePA     :Pos angle of slice           */
   /*                                                  */
   /*--------------------------------------------------*/
   for (i = 0; i < ndat; i++)
   {
      Vc2Vxy( &(inset->convertedR[i]),
              &(inset->convertedV[i]),
              &(inset->mirrorR[i]),
              &(inset->mirrorV[i]),
              R[i],
              V[i],
              inset->inc[i],
              inset->pa[i],
              inset->Vsys,
              inset->slicePA );
   }


   /* Plot new ones */
   plotcurve( ndat,
              inset->convertedR,
              inset->convertedV,
              &(inset->visibleVT),
              CYAN,
              SCREEN );
   inset->visibleVT = YES;

   plotcurve( ndat,
              inset->mirrorR,
              inset->mirrorV,
              &(inset->visibleVTmir),
              CYAN,
              SCREEN );
   inset->visibleVTmir = YES;


   initplot( "GRAPHS//APPEND", MAINVIEWPORT,1,1 );  /* Reopen main plot screen */
   setwindow( xloold, yloold, xhiold, yhiold );
}




extern float func_c( float *xdat,
                     float *fpar,
                     fint  *npar,
                     fint  *fieid )
/*------------------------------------------------------------*/
/* PURPOSE: Calculate a function value for the user given     */
/*          expression.                                       */
/* The constants that we want to fit are entered in 'fpar'.   */
/* Only one point per call is calculated.                     */
/* The summed velocity is given by:                           */
/*                                                            */
/*   2          2              2            2      2          */
/* Vt = Mbulge.Vbulge + Mdisk.Vdisk + Mgas.Vgas + Vdh(a,b,...)*/
/*                                                            */
/*                                                            */
/* Mbulge, Mdisk, Mgas are the mass scaling factors that we   */
/* want to fit. Their values are stored in fpar[0..2].        */
/* Vdh is a dark halo function of zero or more parameters.    */
/* Their values are stored in fpar[3..n] where n is 3+the     */
/* number of parameters in Vdh.                               */
/*                                                            */
/* If an expression could not be evaluated then V=0.0 is      */
/* returned.                                                  */
/* Note that mass scaling factors are always > 0. However     */
/* can enter as negative values (e.g. for chi2 plot). There-  */
/* fore negative scaling factors change sign.                 */
/* There are a couple of values that are stored in a global   */
/* struct called 'lastLSQ'. These are used in a subsequent    */
/* call to derv_c.                                            */
/*------------------------------------------------------------*/
{
   float Vu, Vt;
   int   i, par;
   fint  r;
   fint  one = 1;


   for (par = 0; par < globals.numdervs; par++)
   {
       lastLSQ.datain[par] = fpar[par];        /* The constants */
   }
   
   /* Now add VD,VB,VG, VX, R and VU */
   /* Add VU separately */
   
   for (i = 0, par = globals.numdervs; i < NUMCOMP+1; i++,  par++)
   {
      lastLSQ.datain[par] = xdat[i];
   }
   /* Add dummy VU */
   lastLSQ.datain[par] = 0.0;
   /* Evaluate Vu before Vt */
   r = fiedo_c( lastLSQ.datain, &one, &Vu, &(globals.Vu_id) );
   lastLSQ.datain[par] = Vu;
   r = fiedo_c( lastLSQ.datain, &one, &Vt, &(globals.Vt_id) );

   return( Vt );
}




extern void derv_c( float *xdat,
                    float *fpar,
                    float *epar,
                    fint  *npar,
                    fint  *fieid )
/*------------------------------------------------------------*/
/* PURPOSE: Calculate values for all partial derivatives.     */
/* Note that the function id's for these derivatives start    */
/* with index '1', because element '0' is the function id of  */
/* the user given expression.                                 */
/* The summed velocity is given by:                           */
/*                                                            */
/*   2          2              2            2      2          */
/* Vt = Mbulge.Vbulge + Mdisk.Vdisk + Mgas.Vgas + Vdh(a,b,...)*/
/*                                                            */
/*                                                            */
/* if F==Vt^2 then:                                           */
/*                                                            */
/* dF         2        dF         2        dF         2       */
/* --      = Vbulge ,  --      = Vbulge    --      = Vbulge   */
/* dMbulge             dMdisk              dMgas              */
/*                                                            */
/*          2                                                 */
/* dF     dVdh(a,b,...)      dV                               */
/* --  =  ------------- = 2V.--   (etc,. for b, c,...)        */
/* da         da             da                               */
/*                                                            */
/*                                                            */
/* For the squared velocities, we use V^2 = V.ABS(V)          */
/* Note that the function value is not recalculated, but is   */
/* used from the global structure 'lastLSQ'.                  */
/*------------------------------------------------------------*/
{
   int   par;
   fint  datalen = 1;
   fint  r;


   for (par = 0; par < globals.numdervs; par++)
   {
      float   DV;
      r = fiedo_c( lastLSQ.datain, &datalen, &DV, &fieid[par] );
      if (DV == blank)
         epar[par] = 0.0;
      else
         epar[par] = DV;
   }
}




static void updateweights( globaltype *g, int *warning )
/*------------------------------------------------------------*/
/* PURPOSE: Calculate weights and store in WEIGHTS array.     */
/* Set the warning flag if there is a data point at R == 0    */
/* and the weight in that point is unequal to 0.              */
/* The errors from file are called sigma. Then the weights in */
/* the lsqfit are 1/(sigma*sigma).                            */
/*------------------------------------------------------------*/
{
   int    i;
   
 
   *warning = NO;
   for (i = 0; i < g->arraylen[RADII]; i++)
   {
      if (g->weights == WEIGHTS_UNI || g->arraylen[OBSERR] == 0)
      {
         if (g->dataptr[RADII][i] == 0.0)                            /* R = 0 */
            *warning = YES;
         g->dataptr[WEIGHTS][i] = 1.0;
      }
      else
      {
         float sigma = g->dataptr[OBSERR][i];

         if (g->dataptr[RADII][i] == 0.0 && sigma != 0.0)            /* R = 0 */
            *warning = YES;

         if (sigma == 0.0)
            g->dataptr[WEIGHTS][i] = 0.0;
         else
            g->dataptr[WEIGHTS][i] = 1.0/(sigma*sigma);
      }
   }
}




static void filllsqfitdata( float      *VdVbVgVxR,
                            fint        fxdim,
                            globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: Fill a data array for 'lsqfit'.                   */
/*                                                            */
/*          For a least squares fit, data must be provided    */
/*          in an array of length ndat*xdim. If one of the    */
/*          arrays is not used, zero's are substituted. Note  */
/*          that the call to func & derv in lsqfit needs all  */
/*          data Vd, Vb, Vg, Vx and R and always in the same  */
/*          order.                                            */
/*------------------------------------------------------------*/
{
   int          xdim = (int) fxdim;
   int          i;
   fint         ndat = g->arraylen[RADII];


   for (i = 0; i < ndat; i++)
   {
      float val;
      if (g->arraylen[DISK] == 0)
         val = 0.0;
      else
         val = g->dataptr[DISK][i];
      VdVbVgVxR[xdim*i] = val;

      if (g->arraylen[BULGE] == 0)
         val = 0.0;
      else
         val = g->dataptr[BULGE][i];
      VdVbVgVxR[xdim*i+1] = val;

      if (g->arraylen[GAS] == 0)
         val = 0.0;
      else
         val = g->dataptr[GAS][i];
      VdVbVgVxR[xdim*i+2] = val;

      if (g->arraylen[OTHER] == 0)
         val = 0.0;
      else
         val = g->dataptr[OTHER][i];
      VdVbVgVxR[xdim*i+3] = val;

      VdVbVgVxR[xdim*i+4] = g->dataptr[RADII][i];
   }
}




static void fittolog( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: FITTOLOG= keyword handler.                        */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   int          npar;
   int          ndat = g->arraylen[RADII];
   int          i;
   char         dummy[80];
   char         parmes[STRLEN];
   char         errmes[STRLEN];
   char         statline1[STRLEN];
   char         statline2[STRLEN];
   char         stampstr[STRLEN];
   float        nu = 0.0;
   float        goodnessoffit;
   bool         dofittolog = UserLog(key);

   if (!dofittolog)
      return;


   npar = g->numdervs;

   /* Now write results in GIPSY LOG file */

   nu = (float) (g->chi2.ndat - g->chi2.nfree );
   strcpy(dummy, "");
   if (g->weights == WEIGHTS_UNI)
      goodnessoffit = blank;
   else
      goodnessoffit = gammaq( nu/2.0, g->chi2.chi2/2.0, dummy );

   if (goodnessoffit == blank)
   {
      strcpy( errmes, dummy );
   }
   else
      strcpy( errmes, "" );

   if (goodnessoffit != blank)
   {
      sprintf( statline1,
           "Fit in %d iterations.   Red.chi^2: %g (N=%d,n=%d).   Fit quality: %g (%%)",
            g->lsqiters,
            g->chi2.redchi2,
            g->chi2.ndat, g->chi2.nfree,
            goodnessoffit*100.0 );
   }
   else
   {
      sprintf( statline1,
           "Fit in %d iterations.   Red.chi^2: %g (N=%d,n=%d)",
            g->lsqiters,
            g->chi2.redchi2,
            g->chi2.ndat, g->chi2.nfree );
   }


   strcpy( statline2, "" );
   for (i = 0; i < npar; i++)
   {
      if (g->freepar[i])
      {
         sprintf( parmes, "%s=%.3f +- %.3f  ",
                  g->parname[i],
                  g->parval[i],
                  g->parerr[i] );
         strcat( statline2, parmes );
      }
   }
   error_status( errmes, statline1, statline2 );             /* Output to gui */

   stamp( stampstr );
   anyoutf( 3, " " );

   /* Include Time and date in header */
   /*anyoutf*/( 3, "============ ROTMAS FIT RESULTS (%s) ============", stampstr );

   anyoutf( 3, "Used functions:" );
   if (g->Vu_id >= 0)
   {
      anyoutf( 3, "Vu(R) = %.*s", ANYLEN(g->darkhalo), g->darkhalo );
   }
   if (g->Vt_id >= 0)
   {
      anyoutf( 3, "Vt(R) = %.*s", ANYLEN(g->vtotal), g->vtotal );
   }
   anyoutf( 3, "(Fitted) parameter values:" );
   for (i = 0; i < npar; i++)
   {
      /* Put all (fixed and free) values and errors in LOG file */
      if (g->freepar[i])
         anyoutf( 3, "%-8s=%10g +- %10g (Free)",
                  g->parname[i],
                  g->parval[i],
                  g->parerr[i] );
      else
         anyoutf( 3, "%-8s=%10g +- %10g (Fixed)",
                  g->parname[i],
                  g->parval[i],
                  g->parerr[i] );
   }

   anyoutf( 3, "Least squares fit routine converged in %d iteration(s) to a minimum",
                g->lsqiters );
   anyoutf( 3, "value of chi-square of %f (equivalent to a REDUCED chi2 of %f)", 
                g->chi2.chi2, g->chi2.redchi2 );
   anyoutf( 3, "by fitting %d valid data points to Vt with %d free parameters,", 
                g->chi2.ndat, g->chi2.nfree );
            
   if (g->weights == WEIGHTS_UNI)
   {
      anyoutf( 3, "using uniform weight 1.0." );
   }
   else
   {
      anyoutf( 3, "using errors as weights." );
   }
   anyoutf( 3, "Tolerance in the fit was %g and the mixing parameter %g.",
            g->tol, g->lab );

   if (goodnessoffit != blank)
   {
      anyoutf( 3, "The probability that a RANDOM set of %d data points would yield a ",
               ndat  );
      anyoutf( 3, "value of chi-square greater or equal to %g when compared to the parent",
               g->chi2.chi2 );
      anyoutf( 3, "function is (1-p)=%g (%)",
               (1.0-goodnessoffit)*100.0  );
   }

   anyoutf( 3, "=======================================================================" );
   anyoutf( 3, " " );

   wkeyf( "FITTOLOG=NO" );  /* reset key */
}




static void fit( ident id,
                 char  *key,
                 int   code,
                 void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: FIT= keyword handler.                             */
/* Do the actual least squares fit.                           */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint         ndat = g->arraylen[RADII];
   float       *par;
   fint        *mpar;
   float       *err;
   int          i;
   fint         npar;
   char         mes[STRLEN];
   char         mes2[STRLEN];
   bool         dofit = UserLog(key);
   float        *VdVbVgVxR;
   fint         xdim = NUMCOMP+1;
   int          warning;


   /* read status of button */
   if (!dofit)
      return;

   error_status( "", "", "" );
   npar = g->numdervs;
   par  = (float *) calloc( npar, sizeof(float) );
   err  = (float *) calloc( npar, sizeof(float) );
   mpar = (fint *)  calloc( npar, sizeof(fint) );
   if (par == NULL || err == NULL || mpar == NULL)
   {
      error_status( "Cannot allocate memory for work arrays",
                    "Rerun program", "" );
      return;
   }
   VdVbVgVxR = (float *) calloc( ndat*xdim, sizeof(float) );
   if (VdVbVgVxR == NULL)
   {
      error_status( "Cannot allocate memory for LSQFIT work array",
                    "Rerun program", "" );
      return;
   }

   /* Set the weights */
   updateweights( g, &warning );

   for (i = 0; i < npar; i++)
   {
      par[i] = g->parval[i];
      mpar[i] = g->freepar[i];
   }

   filllsqfitdata( VdVbVgVxR, xdim, g );

   g->lsqiters  = lsqfit_c(  VdVbVgVxR,
                             &xdim,
                             g->dataptr[OBSERVED],
                             g->dataptr[WEIGHTS],
                             &ndat,
                             par,
                             err,
                             mpar,
                             &npar,
                             &(g->tol),
                             &(g->maxits),
                             &(g->lab),
                             g->partid );

   if (g->lsqiters < 0)
   /*--------------------------------------------------*/
   /* Display error message and free allocated memory. */
   /* reset FIT= button.                               */
   /*--------------------------------------------------*/
   {
      char   statmes1[STRLEN];
      char   statmes2[STRLEN];

      lsqerr( g->lsqiters, mes, statmes1, statmes2 );
      if (warning)
      {
         strcpy( statmes1, "Fit could have failed IF there was a singularity in evaluating Vu or Vt" );
         strcpy( statmes2, "and your weight in that point (e.g. R=0) was unequal to 0 !!" );
      }    
      error_status( mes, statmes1, statmes2 );
      free( mpar );
      free( err );
      free( par );
      free( VdVbVgVxR );
      wkeyf( "FIT=NO" );
      return;
   }

   for (i = 0; i < npar; i++)
   {
      anyoutf( DEBUG, "LSQFIT parameters: par[%d]=%f,  error=%f",
               i, par[i], err[i] );
   }

   /*--------------------------------------------------*/
   /* Create a message for the status text, i.e. list  */
   /* fitted values and their errors. Write this also  */
   /* the GIPSY LOG file.                              */
   /*--------------------------------------------------*/
   strcpy( mes2, "" );
   for (i = 0; i < npar; i++)
   {
      if (g->freepar[i])
      {
         float val = par[i];
         float delta = 0.5 * ABS( val );

         /* Update the value & min,max in the valuator */
         /* for this free parameter. */
         wkeyf( "%s=%g", g->parname[i], par[i] );
         wkeyf( "%s_MAX=%-4.2f %s_MIN=%-4.2f",
                g->parname[i], MYMAX( val+delta, val-delta ),
                g->parname[i], MYMIN( val+delta, val-delta ) );
         sprintf( mes, "%s=%.3f +- %.3f  ", g->parname[i], par[i], err[i] );
         strcat( mes2, mes );
      }
      /* Copy the errors too */
      g->parerr[i] = err[i];
   }

   /*--------------------------------------------------*/
   /* The output of the results have to wait for the   */
   /* update of the parameters and the chi2. Therefore */
   /* the function is scheduled so that it is called   */
   /* AFTER the updates.                               */
   /*--------------------------------------------------*/
   wkeyf( "FITTOLOG=Y" );


   free( par );                        /* We don't need these arrays anymore. */
   free( err );
   free( mpar );
   free( VdVbVgVxR );
   wkeyf( "FIT=NO" );                                     /* Reset FIT button */
}





static void plotcolorlabel( globaltype  *g,
                            int nr )
/*------------------------------------------------------------*/
/* PURPOSE: */
/*------------------------------------------------------------*/
{
   float    disp, coord, fjust;
   char     mes[20];
   fint     oldcol, col = g->color[nr];
   float    pscale = 6.0;

   if (g->arraylen[nr] == 0)
      return;

   coord = nr / pscale;
   fjust = 0.0;
   disp  = 1.1;
   pgqci_c( &oldcol );
   setcolor( col );
   if (nr == BULGE)
      strcpy( mes, "--- V\\d bulge" );                       /* Use subscript */
   if (nr == DISK)
      strcpy( mes, "--- V\\d disk" );
   if (nr == GAS)
      strcpy( mes, "--- V\\d gas" );
   if (nr == OTHER)
      strcpy( mes, "--- V\\d other" );
   if (nr == VTDAT)
   {
      strcpy( mes, "--- V\\d total" );
      coord = 4.0 / pscale;
   }
   if (nr == VUDAT)
   {
      strcpy( mes, "--- V\\d user" );
      coord = 5.0 / pscale;
   }
   pgmtxt_c( tofchar("T") , &disp, &coord, &fjust, tofchar(mes) );
   setcolor( oldcol );
}




static void cursor( ident         id,
                    GgiPlotInfo   info,
                    void          *arg )
/*------------------------------------------------------------*/
/* PURPOSE: React to cursor actions in mainplot window        */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float       x=info->x, y=info->y;                     /* World coordinates */
   int         button=info->button, state=info->state;

   static float yval = 1.0;
   static int   curve = -1;
   static int   indx = -1;


   /* push button: select graph */
   if ((button&ggiButn1) && !(state&ggiButn1))
   {
      indx = getindex( x, g->dataptr[RADII], g->arraylen[RADII] );

      if (indx >= 0)
      {
         float    x1, x2;
         float    y1, y2;
         float    dist;
         float    yinp[3];
         float    mindist = -1.0;
         float    *p;
         int      i;

         x1 = g->dataptr[RADII][indx];
         x2 = g->dataptr[RADII][indx+1];      /* Note that indx < arraylen -1 */
         for (i = 0; i < DATCURVES; i++)
         {
            if (g->arraylen[i] > 0)
            {
               p = g->dataptr[i+SCALED];
               /* determine distance to this curve in y direction */
               y1 = p[indx];
               y2 = p[indx+1];
               yinp[i] = y1 + (x-x1)*(y2-y1)/(x2-x1);
               dist = ABS( y - yinp[i] );

               if (mindist == -1.0)
               {
                  mindist = dist;
                  curve = i;
               }
               else
               {
                  if (dist < mindist)
                  {
                     mindist = dist;
                     curve = i;
                  }
               }
            }
         }
         if (curve >= 0)
         {
            p = g->dataptr[curve];
            y1 = p[indx];
            y2 = p[indx+1];
            yval = y1 + (x-x1)*(y2-y1)/(x2-x1);
         }
      }
   }
   if (curve < 0)
      return;

   if (indx >= 0)
   {
      float ratio = y/yval;
      float Mscale = SIGN(ratio) * ratio * ratio;
      wkeyf( "%s=%g", g->mscalename[curve], Mscale );
   }

   /* Button released update min and max. */
   if ((button&ggiButn1) && (state&ggiButn1) && indx >= 0)
   {
      float ratio = y/yval;
      float Mscale = SIGN(ratio) * ratio * ratio;
      float delta = 0.5 * Mscale;
      wkeyf( "%s_MIN=%-4.2f %s_MAX=%-4.2f",
             g->mscalename[curve], Mscale-delta, g->mscalename[curve], Mscale+delta );
      curve = -1;
   }
}




static void getdata( char        *key,
                     globaltype  *g,
                     int         nr )
/*------------------------------------------------------------*/
/* PURPOSE: Input routine for array data for OBSERVED, OBSERR */
/*          DISK, GAS, BULGE and OTHER.                       */
/*------------------------------------------------------------*/
{
   fint        nitems;
   fint        dfault = HIDDEN;
   fint        r;
   int         resample = NO;
   fint        samples;


   /* Demand that radii for the observed data is entered first! */
   if (g->arraylen[RADII] == 0)
   {
      error_status( "No observed radii entered!",
                    "Please enter 'observed' radii first.", "" );
      rejectf( key, "No radii entered!" );
      return;
   }


   /*--------------------------------------------------*/
   /* If one of the keywords for  BULGE, DISK or GAS   */
   /* data is triggered, then check if alternative     */
   /* radii are entered. If not, then take the radii in*/
   /* the observed radii in dataptr[RADII].            */
   /*--------------------------------------------------*/
   if (nr < DATCURVES)
   {
      /* BULGE, DISK, GAS or OTHER keyword triggered. Check the contents */
      /* of the BRADII=, DRADII=, GRADII= and XRADII keywords.  */
      nitems = MAXPOINTS;
      samples = userreal_c( fstore,
                            &nitems,
                            &dfault,
                            tofchar(g->radkeys[nr]),
                            tofchar(" ") );
      if (samples == 0)
      {
         anyoutf( DEBUG, "No alternative radii --> standard" );
         anyoutf( DEBUG, "Keyword=[%s]", g->radkeys[nr] );
         resample = NO;
      }
      else
      {
         resample = YES;
         anyoutf( DEBUG, "Alternative %d radii entered --> resample", samples );
         nitems = samples; 
         dfault = EXACT;
         samples = userreal_c( gstore,
                               &nitems,
                               &dfault,
                               tofchar(key),
                               tofchar(" ") );
         if (samples == 0)
         {
            /*---------------------------------------------------------*/
            /* If a radius keyword is triggered, then also this getdata*/
            /* routine is called. But it can happen that there is no   */
            /* data yet and resampling must be postponed till the data */
            /* keyword is triggered.                                   */
            /*---------------------------------------------------------*/
            resample = NO;
         }
         else
         {
            if (gstore[0] < g->dataptr[RADII][0])
               error_status( "", "Resampling routine must extrapolate!", "" );
         }
      }
   }

   /* At this point there are radii and the arrays are allocated. */

   /* If 'total' curve exists, clear it first */
   if (nr < DATCURVES)
   {
      if (g->visible[VTDAT])
      {
         plotcurve( g->arraylen[VTDAT],
                    g->dataptr[RADII],
                    g->dataptr[VTDAT],
                    &(g->visible[VTDAT]),
                    g->color[VTDAT],
                    SCREEN );
      }
   }
   /* If current curve exists, clear it first */
   if (nr < DATCURVES && g->arraylen[nr] > 0)
   {
      /* Plotting again in the same color == erasing */
      /* Erase 'data' curve. This is one of DISK, GAS or BULGE, OTHER */
      if (g->visible[nr])
      {
         plotcurve( g->arraylen[nr],
                    g->dataptr[RADII],
                    g->dataptr[nr+SCALED],
                    &(g->visible[nr]),
                    g->color[nr],
                    SCREEN );
      }
   }
   if (nr == OBSERR && g->arraylen[nr] > 0)
   {
      ploterrors( g->arraylen[OBSERR],
                  g->dataptr[RADII],
                  g->dataptr[OBSERVED],
                  g->dataptr[OBSERR],
                  g->color[OBSERVED] );  /* Same color as observed data */
   }

   if (nr < DATCURVES && resample)
   /*--------------------------------------------------*/
   /* Call spline routine to sample on observed radii. */
   /*--------------------------------------------------*/
   {
      fint   res;
      int    ok = YES;
      fint   outlen = g->arraylen[RADII];

      error_status( "", "", "" );
      res = spline1_c( fstore, gstore, &samples,
                       g->dataptr[RADII], g->dataptr[nr], &outlen );
      if (res == -1)
      {
         error_status( "Memory problems or empty array in spline routine",
                       "Check observed data array.", "" );
         ok = NO;
      }
      if (res == -2)
      {
         error_status( "Spline Interpolation problem!",
                       "The input array has two equal x-coordinates or a",
                       "value outside range of observed radii" );
         ok = NO;
      }
      if (res > 0)
      {
         error_status( "Spline Interpolation problem!",
                       "There are undefined values in input radii", "" );
         ok = NO;
      }
      if (!ok)
      {
         rejectf( key, "Interpolation problems!" );
         return;
      }
      /* Array gets the same length as observed data */
      g->arraylen[nr] = g->arraylen[RADII];
   }
   else
   /*--------------------------------------------------*/
   /* Read data directly from keyword and associate    */
   /* with observed radii.                             */
   /*--------------------------------------------------*/
   {
      nitems = g->arraylen[RADII];
      dfault = EXACT;
      r = userreal_c( g->dataptr[nr],
                      &nitems,
                      &dfault,
                      tofchar(key),
                      tofchar(" ") );
      g->arraylen[nr] = (int) r;
      anyoutf( DEBUG, "Keyword=[%s]", key );
      anyoutf( DEBUG, "Associate with observed data with len=%d, result len=%d", nitems, r );
   }

   if (nr == OBSERVED && g->arraylen[OBSERVED])
   {
      int i;
      initplot( "GRAPHS", MAINVIEWPORT,1,1 );
      clearscreen();
      resetvisibility( g );

      minmax1_c( g->dataptr[OBSERVED],
                 &r,
                 &(g->observedmin),
                 &(g->observedmax) );
      anyoutf( DEBUG, "Observed curve minimum = %f, maximum = %f",
               g->observedmin, g->observedmax );
      drawbox( g->radiimin,
               g->observedmin,
               g->radiimax,
               g->observedmax,
               "R (kpc)",
               "V (km/s)", "",
               SCREEN );

      /*--------------------------------------------------*/
      /* Plot curves  for BULGE/DISK/GAS                  */
      /* Plot circles for OBSERVED and plot error bars    */
      /* for OBSERR.                                      */
      /*--------------------------------------------------*/
      for (i = 0; i < DATCURVES; i++)
      {
         plotcurve( g->arraylen[i],
                    g->dataptr[RADII],
                    g->dataptr[i],
                    &(g->visible[i]),
                    g->color[i],
                    SCREEN );
         g->visible[i] = YES;
      }
      /* Plot the observed data points, if any */
      plotpoints( g->arraylen[OBSERVED],
                  g->dataptr[RADII],
                  g->dataptr[OBSERVED],
                  BIGCIRCLE,
                  g->color[OBSERVED] );                 /* Color */
      /* Plot the observed errors, if any */
      ploterrors( g->arraylen[OBSERR],
                  g->dataptr[RADII],
                  g->dataptr[OBSERVED],
                  g->dataptr[OBSERR],
                  g->color[OBSERR] );
   }
   else
   {
      if (nr < OBSERVED)
      {
         /* Copy data to array for storage. This array is used to scale */
         copyfromto( g->dataptr[nr], g->dataptr[nr+SCALED], g->arraylen[nr], 1.0 );
         if (g->dataptr[OBSERVED] != NULL)
         {
            plotcurve( g->arraylen[nr],
                       g->dataptr[RADII],
                       g->dataptr[nr+SCALED],
                       &(g->visible[nr]),
                       g->color[nr],
                       SCREEN );
            g->visible[nr] = YES;
            plotcolorlabel( g, nr );
         }
      }
      /* Errors can only be plotted if observed data points are plotted */
      if (nr == OBSERR && g->arraylen[OBSERVED] != 0)
      {
         ploterrors( g->arraylen[OBSERR],
                     g->dataptr[RADII],
                     g->dataptr[OBSERVED],
                     g->dataptr[OBSERR],
                     g->color[OBSERVED] );  /* Same color as observed data */
         if (!TriggerKey( "WEIGHTS=" ))
            wkeyf( "WEIGHTS=1" );
      }
   }
}




static void getradii( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: RADII= keyword handler. these are the R values of */
/* the Observed curve.                                        */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint        nitems = MAXPOINTS;
   fint        dfault = HIDDEN;
   fint        r;
   int         i;
   int         erase = NO;


   g->arraylen[RADII] = 0;
   r = userreal_c( &fstore[0],
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );

   g->arraylen[RADII] = (int) r;
   if (r <= 0)
   {
      /* There is nothing to do */
      initplot( "GRAPHS", MAINVIEWPORT,1,1 );
      clearscreen();
      resetvisibility( g );
      g->arraylen[RADII] = 0;
      return;
   }

   for (i = 0; i < NUMARRAYS; i++)
   {
      if (g->dataptr[i] != NULL)
      {
         free( g->dataptr[i] );
         g->arraylen[i] = 0;
         erase = YES;
      }
      g->dataptr[i] = (float *) calloc( (int) r, sizeof(float) );
      if (g->dataptr[i] == NULL)
      {
         error_status( "Cannot allocate memory for work arrays.",
                       "Try less radii or restart program", "" );
         return;
      }
   }

   if (xvset.convertedV != NULL)
      free( xvset.convertedV );
   xvset.convertedV = (float *) calloc( (int) r, sizeof(float) );
   if (xvset.convertedR != NULL)
      free( xvset.convertedR );
   xvset.convertedR = (float *) calloc( (int) r, sizeof(float) );

   if (xvset.mirrorV != NULL)
      free( xvset.mirrorV );
   xvset.mirrorV = (float *) calloc( (int) r, sizeof(float) );
   if (xvset.mirrorR != NULL)
      free( xvset.mirrorR );
   xvset.mirrorR = (float *) calloc( (int) r, sizeof(float) );

   if (xvset.inc != NULL)
      free( xvset.inc );
   xvset.inc = (float *) calloc( (int) r, sizeof(float) );
   if (xvset.pa != NULL)
      free( xvset.pa );
   xvset.pa = (float *) calloc( (int) r, sizeof(float) );

   if (!xvset.convertedR || !xvset.convertedV ||
       !xvset.mirrorR || !xvset.mirrorV ||
       !xvset.inc || !xvset.pa)
   {
      error_status( "Cannot allocate memory for XV data arrays.",
                    "Try less radii or restart program", "" );
      return;
   }

   g->arraylen[RADII] = (int) r;
   for (i = 0; i < g->arraylen[RADII]; i++)
   {
      g->dataptr[RADII][i] = fstore[i];
   }
   minmax1_c( g->dataptr[RADII], &r, &(g->radiimin), &(g->radiimax) );
   anyoutf( DEBUG, "Radius minimum = %f, maximum =  %f",
            g->radiimin, g->radiimax );

/*   if (erase)
   {
      TriggerKey( g->keys[OBSERVED] );
   }
  */
}




static void getobsdat( ident id,
                       char  *key,
                       int   code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Input routines for Observed curve.                */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   getdata( key, g, OBSERVED );
}
static void getobserrdat( ident id, char  *key,  int   code, void  *arg )
{
   globaltype  *g = (globaltype*) arg;
   getdata( key, g, OBSERR );
}
static void getbulgedat( ident id, char  *key,  int   code, void  *arg )
{
   globaltype  *g = (globaltype*) arg;
   getdata( key, g, BULGE );
}
static void getdiskdat( ident id, char  *key,  int   code, void  *arg )
{
   globaltype  *g = (globaltype*) arg;
   getdata( key, g, DISK );
}
static void getgasdat( ident id, char  *key,  int   code, void  *arg )
{
   globaltype  *g = (globaltype*) arg;
   getdata( key, g, GAS );
}
static void getotherdat( ident id, char  *key,  int   code, void  *arg )
{
   globaltype  *g = (globaltype*) arg;
   anyoutf( DEBUG, "getotherdat: Keyword=[%s]", key );
   getdata( key, g, OTHER );
}




static void getBradii( ident id,
                       char  *key,
                       int   code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Input routines for extra radii belonging to       */
/*          Bulge, Disk, Gas or X.                            */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   getdata( globals.keys[BULGE], g, BULGE );
}
static void getDradii( ident id, char  *key, int   code, void  *arg )
{
   globaltype  *g = (globaltype*) arg;
   getdata( globals.keys[DISK], g, DISK );
}
static void getGradii( ident id, char  *key, int   code, void  *arg )
{
   globaltype  *g = (globaltype*) arg;
   getdata( globals.keys[GAS], g, GAS );
}
static void getXradii( ident id, char  *key, int   code, void  *arg )
{
   globaltype  *g = (globaltype*) arg;
   getdata( globals.keys[OTHER], g, OTHER );
}




static void scaledata( char  *key,
                       void  *arg,
                       int   nr )
/*------------------------------------------------------------*/
/* PURPOSE: A change in scale occurred. This is a reaction to */
/* a change in one of the keywords MD=, MG= or MB=. Update    */
/* plot and data. Note that these keywords always represent   */
/* scaling factors, but there is no restriction in how you    */
/* want to use them in the Vu or Vt expressions.              */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint        nitems = 1;
   fint        dfault = HIDDEN;
   fint        r;
   float       velscale;
   float       val;


   if (g->arraylen[nr] == 0)
      return;

   r = userreal_c( &val,
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );

   velscale = SIGN(val) * sqrt( ABS(val) );


   if (g->visible[nr])
   {
      plotcurve( g->arraylen[nr],                  /* Erase */
                 g->dataptr[RADII],
                 g->dataptr[nr+SCALED],
                 &(g->visible[nr]),
                 g->color[nr],
                 SCREEN );
   }

   copyfromto( g->dataptr[nr],
               g->dataptr[nr+SCALED],
               g->arraylen[nr],
               velscale );

   plotcurve( g->arraylen[nr],
              g->dataptr[RADII],
              g->dataptr[nr+SCALED],
              &(g->visible[nr]),
              g->color[nr],
              SCREEN );
}




static void scalebulge( ident id,
                        char  *key,
                        int   code,
                        void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: Set the bulge data scale factor.                  */
/*------------------------------------------------------------*/
{
   scaledata( key, arg, BULGE );
}
static void scaledisk( ident id, char *key, int code, void *arg )
{
   scaledata( key, arg, DISK );
}
static void scalegas( ident id, char *key, int code, void *arg )
{
   scaledata( key, arg, GAS );
}
static void scaleother( ident id, char *key, int code, void *arg )
{
   scaledata( key, arg, OTHER );
}




static void chi2cursor( ident         id,
                        GgiPlotInfo   info,
                        void          *arg )
/*------------------------------------------------------------*/
/* PURPOSE: React to cursor actions in plot window            */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float       x=info->x, y=info->y;                   /* World coordinates ! */
   int         button=info->button, state=info->state;
   char        mes[80];


   if ( (button&ggiButn1) && (state&ggiButn1) )
   {
      float      *par;
      fint       *mpar;
      float      *err;
      int         i;
      int         indx1, indx2;
      fint        npar;
      fint        ndat, freecount;
      fint        its;
      fint        xdim = NUMCOMP+1;


      indx1 = g->chi2index[0];
      indx2 = g->chi2index[1];
      ndat = g->arraylen[RADII];
      npar = g->numdervs;
      par  = (float *) calloc( npar, sizeof(float) );
      err  = (float *) calloc( npar, sizeof(float) );
      mpar = (fint *)  calloc( npar, sizeof(fint) );
      if (par == NULL || err == NULL || mpar == NULL)
      {
         error_status( "Cannot allocate memory for lsqfit work arrays",
                       "Rerun program", "" );
         return;
      }
      for (i = 0; i < npar; i++)
      {
         mpar[i] = g->freepar[i];
         par[i] = g->parval[i];
      }
      mpar[indx1] = FIXED;
      mpar[indx2] = FIXED;
      par[indx1] = x;
      par[indx2] = y;

      freecount = 0;
      for (i = 0; i < npar; i++)
      {
         if (mpar[i] == FREE)
            freecount++;
      }

      if (freecount > 0)
      {
         its = lsqfit_c(  g->VdVbVgVxR,
                          &xdim,
                          g->dataptr[OBSERVED],
                          g->dataptr[WEIGHTS],
                          &ndat,
                          par,
                          err,
                          mpar,
                          &npar,
                          &(g->tol),
                          &(g->maxits),
                          &(g->lab),
                          g->partid );
      }
      else
      {
         /* Cannot fit update only chi2 landscape parameters */
         its = 1;
      }
      if (its < 0)
      {
         /* do nothing */
      }
      else
      {
         for (i = 0; i < npar; i++)
         {
            sprintf( mes , "%s=%f", g->parname[i], par[i] );
            wkeyf( mes );
         }
      }
      /* free data */
      free( par );
      free( err );
      free( mpar );
   }
}





static void redrawfie( globaltype  *g )
/*------------------------------------------------------------*/
/* PURPOSE: In reaction to a change in parameter value in a   */
/* scheduled valuator, erase Vu and Vt and redraw for new     */
/* values.                                                    */
/*------------------------------------------------------------*/
{
   if (g->visible[VUDAT])    /* erase */
   {
      plotcurve( g->arraylen[VUDAT],
                 g->dataptr[RADII],
                 g->dataptr[VUDAT],
                 &(g->visible[VUDAT]),
                 g->color[VUDAT],
                 SCREEN );
   }

   if (g->visible[VTDAT])    /* erase */
   {
      plotcurve( g->arraylen[VTDAT],
                 g->dataptr[RADII],
                 g->dataptr[VTDAT],
                 &(g->visible[VTDAT]),
                 g->color[VTDAT],
                 SCREEN );
   }


   /* New data for Vu and Vt */
   calcVudat( g );
   calcVtdat( g );

   /* Plot new curves */

   plotcurve( g->arraylen[VUDAT],
              g->dataptr[RADII],
              g->dataptr[VUDAT],
              &(g->visible[VUDAT]),
              g->color[VUDAT],
              SCREEN );


   plotcurve( g->arraylen[VTDAT],
              g->dataptr[RADII],
              g->dataptr[VTDAT],
              &(g->visible[VTDAT]),
              g->color[VTDAT],
              SCREEN );


   if (xvup() && xvset.validbox)
   {
      /* Erasing and plotting is done in next routine */
      plotinXV( &xvset,
                g->arraylen[VTDAT],
                g->dataptr[RADII],
                g->dataptr[VTDAT],
                g->color[VTDAT] );
   }
}




static void getandupdate( ident id,
                          char  *key,
                          int   code,
                          void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: XV_SYSV=, XV_SLICEPA= and XV_DISTANCE= keyword    */
/*          handler.                                          */
/*------------------------------------------------------------*/
{
    float      *userval = (float *) arg;
    fint       nitems = 1;
    fint       dfault = HIDDEN;

    (void) userreal_c( userval,
                       &nitems,
                       &dfault,
                       tofchar(key),
                       tofchar(" ") );

   if ( xvup() )
   {
      plotinXV( &xvset,
                globals.arraylen[VTDAT],
                globals.dataptr[RADII],
                globals.dataptr[VTDAT],
                globals.color[VTDAT] );
   }
}





static void changeparval( ident   id,
                          char   *key,
                          int     code,
                          void   *arg)
/*------------------------------------------------------------*/
/* PURPOSE: Set a new value for a Vu or Vt expression         */
/*          parameter. Update the plot for Vu and Vt.         */
/*------------------------------------------------------------*/
{
   float  *parval = (float *) arg;
   fint   nitems = 1;
   fint   r;
   fint   dfault = HIDDEN;

   r = userreal_c(  parval,
                    &nitems,
                    &dfault,
                    tofchar( key ),
                    tofchar(" ") );

   redrawfie( &globals );                          /* Use the global notation */
}




static void fixfree( ident id,
                     char  *key,
                     int   code,
                     void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: ...._FIX= keyword handler.                        */
/*------------------------------------------------------------*/
{
   fint  *fixfree = (fint *) arg;
   bool  fix   = UserLog(key);


   if (fix)
      *fixfree = FIXED;
   else
      *fixfree = FREE;
}




static void Vtotal( ident id,
                    char  *key,
                    int   code,
                    void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: VTFUN= & VUFUN=  handler reads and processes      */
/* the expressions for the user velocity Vu (usually the      */
/* velocity for the dark halo) and the result or total        */
/* velocity Vt. If the field is empty, it is assumed that the */
/* user wants the default summation of the squared velocities:*/
/*                                                            */
/*     Vt = SQRT(mg*Vg**2 + md*Vd**2 + mb*Vb**2 + Vh**2)      */
/*                                                            */
/*                                                            */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   char        exprO[MAXEXPRLEN];
   char        derv[MAXDERVLEN];
   char        errmes[STRLEN];
   fchar       ExprO, Derv, Vtotexpr;
   fchar       Vars[MAXVAR];
   fchar       Darkhalo;
   fint        DHlen;
   fint        errpos;
   fint        exprlen;
   fint        dfault = HIDDEN;
   fint        r;
   fint        csize = MAXVARLEN;
   fint        nvars, pvars;
   char        dummyvarbuf[MAXVAR*MAXVARLEN];
   fchar       Dummvariables[MAXVAR];
   char        derivates[MAXPAR*(MAXDERVLEN+1)];
   fchar       Partdervs[MAXPAR];
   char        wstr[10*MAXEXPRLEN];
   char        vstr[2*MAXEXPRLEN+10];
   int         removeVu = NO;


   if (g->arraylen[RADII] == 0)
   {
      error_status( "No observed radii entered!",
                    "Please enter 'observed' radii first.", "" );
      rejectf( key, "No radii entered!" );
      return;
   }

   {
      /* Is Mond selected, then empty Vu */
      fint vtmenuitem;
      fint nitems = 1;
      fint dfault = HIDDEN;
      
      if ( strcmp("VTFUN=", key) == 0 ) 
      {
         (void) userint_c( &vtmenuitem, &nitems, &dfault, tofchar("VTMENU"), tofchar("") );
         if (vtmenuitem == 2)
         {
            wkeyf( "VUFUN=" );
            /* Exit now. However a new call to this function  is scheduled */
            /* because VUFUN= is triggered. Then VTFUN= and VUFUN= are read */
            /* again. */
            return;   
         }
      }
   }
   /*--------------------------------------------------*/
   /* STEP 1: Initialize the fchars.                   */
   /* Note that 'fiepar' needs fchars of fixed size.   */
   /* The fie routines use the fchar length for loop   */
   /* variables.                                       */
   /*--------------------------------------------------*/
   {
      int   n;
      for (n = 0; n < MAXVAR*MAXVARLEN; n++)
         g->varsbuf[n] = '\0';

      for (n = 0; n < MAXVAR; n++)
      {
         Vars[n].a = &(g->varsbuf[n*MAXVARLEN]);     /* Make it (semi) global */
         Vars[n].l = MAXVARLEN;
         Dummvariables[n].a = &dummyvarbuf[n*MAXVARLEN];
         Dummvariables[n].l = MAXVARLEN;
      }
   }

   ExprO.a = exprO;      ExprO.l = MAXEXPRLEN-1;
   Derv.a  = derv;       Derv.l  = MAXDERVLEN-1;

   Vtotexpr.a = g->vtotal;     Vtotexpr.l = MAXEXPRLEN-1;
   Darkhalo.a = g->darkhalo;   Darkhalo.l = MAXEXPRLEN-1;

   /*--------------------------------------------------*/
   /* STEP 2: Clear the derivative expressions and     */
   /* expressions for Vu, Vt. Reset the fie id's.      */
   /* Deschedule the function corresponding to the     */
   /* parameters.                                      */
   /*--------------------------------------------------*/
   {
      int     i;

      for (i = 0; i < g->numdervs; i++)
      {
         if (g->partid[i] != -1)
            fieclr_c( &(g->partid[i]) );
         g->partid[i] = -1;
         /* Note that the deschedulers need POINTERS to the id's */
         (void) DescheduleKeyevent( &(g->sched_const[i]) );
         (void) DescheduleKeyevent( &(g->sched_fix[i]) );
      }
      if (g->Vt_id != -1)
         fieclr_c( &(g->Vt_id) );
      g->Vt_id = -1;
      if (g->Vu_id != -1)
      {
         removeVu = YES;
         fieclr_c( &(g->Vu_id) );
      }
      g->Vu_id = -1;
   }

   /* Remove Vu & Vt curve, using old data */
   if (removeVu)
   {
      if (g->visible[VUDAT])
      {
         plotcurve( g->arraylen[VUDAT],
                    g->dataptr[RADII],
                    g->dataptr[VUDAT],
                    &(g->visible[VUDAT]),
                    g->color[VUDAT],
                    SCREEN );
      }

      if (g->visible[VTDAT])
      {
         plotcurve( g->arraylen[VTDAT],
                    g->dataptr[RADII],
                    g->dataptr[VTDAT],
                    &(g->visible[VTDAT]),
                    g->color[VTDAT],
                    SCREEN );
      }
   }

   /*--------------------------------------------------*/
   /* STEP 3: Read the expression for Vt entered by    */
   /* the user.                                        */
   /* If an empty string is entered, substitute the    */
   /* default expression.                              */
   /*--------------------------------------------------*/
   clearstr( Vtotexpr );
   exprlen = usertext_c( Vtotexpr,      /* Read the new expr. entered by user */
                         &dfault,
                         tofchar("VTFUN="),
                         tofchar(" ") );
   Vtotexpr.a[nelc_c(Vtotexpr)] = '\0';


   error_status( "", "", "" );               /* Clear error and status fields */

   if (exprlen == 0)
   {
      if ( strcmp("VUFUN=", key) == 0 )
      {
         return;
      }
      else
      {
         char    buf[MAXEXPRLEN-1+7];
         exprlen = sprintf( buf, "VTFUN=%s", STANDARDVT );
         wkeyf( buf );
         return;
      }
   }
   Vtotexpr.a[exprlen] = '\0';

   toupperstr( Vtotexpr.a );

   /*--------------------------------------------------*/
   /* STEP 4: At this stage, we have an expression for */
   /* VTFUN=                                           */
   /* Determine which variables we have we to          */
   /* concatenate to the expression for Vu so that we  */
   /* are sure to get ALL the variables.               */
   /*--------------------------------------------------*/
   dfault = HIDDEN;

   /* Read the user defined (Dark Halo) expression */
   clearstr( Darkhalo );
   DHlen = usertext_c( Darkhalo,
                       &dfault,
                       tofchar("VUFUN="),
                       tofchar(" ") );
   Darkhalo.a[DHlen] = '\0';
   toupperstr( Darkhalo.a );

   /*--------------------------------------------------*/
   /* If there was no expression for VUFUN=, the     */
   /* user defined expression, then insert a zero in   */
   /* the VTFUN= string at the positions of VU.       */
   /*--------------------------------------------------*/
   g->emptyVU = NO;
   if (DHlen == 0)
   {
      strcpy( Darkhalo.a, "0" );
      g->emptyVU = YES;
   }

   anyoutf( DEBUG, "Darkhalo=[%.*s]", ANYLEN(Darkhalo.a), Darkhalo.a );
   anyoutf( DEBUG, "Vtotexpr=[%.*s]", ANYLEN(Vtotexpr.a), Vtotexpr.a );

   sprintf( vstr, "%s+%s", Vtotexpr.a, Darkhalo.a );

   /* Call dydx just to get the names of the parameters */
   ExprO.l = MAXEXPRLEN-1;
   clearstr( ExprO );
   r = dydx_c( tofchar( vstr ),/* expression to be differentiated.*/
               tofchar("R"),   /* variable with respect to which will be differentiated. */
               ExprO,          /* DYDX's interpretation of Expr.*/
               Derv,           /* derivative of Expr with respect to R.*/
               Dummvariables[0],/* names of constants appearing in Expr (in any order).*/
               &csize,         /* Input max. size of a variable string. */
               &nvars );       /* number of variables found.*/

   anyoutf( DEBUG, "Vt+Vu=%.*s", ANYLEN(vstr), vstr );

   /* Something wrong? */
   if (r != 0)
   {
      char  dydxerrmes[STRLEN];
      dydxerror( r, dydxerrmes );
      error_status( dydxerrmes, "Invalid expression for either Vu or Vt", "" );
      rejectf( key, "Invalid expression Vu/Vt" );
      return;
   }

   /*------------------------------------------------------------*/
   /* STEP 5: Store the parameter names, but skip the names      */
   /* VD,VB, VG, VX and VU.                                      */
   /* These parameters are added later to fix the order of       */
   /* parameters in 'fiepar'.                                    */
   /*------------------------------------------------------------*/
   {
      int   i;
      int   h = 0;

      for(i = 0; i < nvars; i++)
         Dummvariables[i].a[nelc_c(Dummvariables[i])] = '\0';


      for(i = 0; i < nvars; i++)
      {
         int   k, known;

         known = NO;
         k = strcmp("VD", Dummvariables[i].a ) ; if (k == 0) known = YES;
         k = strcmp("VB", Dummvariables[i].a ) ; if (k == 0) known = YES;
         k = strcmp("VG", Dummvariables[i].a ) ; if (k == 0) known = YES;
         k = strcmp("VX", Dummvariables[i].a ) ; if (k == 0) known = YES;
         k = strcmp("VU", Dummvariables[i].a ) ; if (k == 0) known = YES;

         if (!known)
            strcpy( Vars[h++].a, Dummvariables[i].a );
      }
      g->numdervs = g->npars = nvars = h;
      /*--------------------------------------------------*/
      /* Add the other possible parameters from the       */
      /* expression. The order is fixed and used to enter */
      /* variable values for all equations (Vu, Vt and    */
      /* partial derivatives).                            */
      /*--------------------------------------------------*/
      clearstr( Vars[h] ); strcpy( Vars[h++].a, "VD" );
      clearstr( Vars[h] ); strcpy( Vars[h++].a, "VB" );
      clearstr( Vars[h] ); strcpy( Vars[h++].a, "VG" );
      clearstr( Vars[h] ); strcpy( Vars[h++].a, "VX" );
      clearstr( Vars[h] ); strcpy( Vars[h++].a, "R" );
      clearstr( Vars[h] ); strcpy( Vars[h++].a, "VU" );
      pvars = h;
   }

   /*--------------------------------------------------*/
   /* STEP 6: Make the variables stored above, known   */
   /* to the expression evaluator. Order is:           */
   /* par1, par2,..., VD,VB,VG,VX, R and VU, all in    */
   /* capitals.                                        */
   /*--------------------------------------------------*/
   {
      int k;
      for (k=0; k<pvars; k++)
      {
         anyoutf( DEBUG, "VARIABLE %d in fiepar: [%s]", k, Vars[k].a );
      }
   }

   r = fiepar_c( Vars[0], &pvars );
   if (r != 0)
   {
      error_status( "Too many parameters in expression or other error","","" );
      return;
   }

   /*--------------------------------------------------*/
   /* STEP 7: Now we know the variables. Create a      */
   /* string in which the expression for Vu is         */
   /* substituted. With this string it will be         */
   /* possible to get all the partial derivatives      */
   /* needed for the lsqfit function.                  */
   /* After using this expression, we can forget it    */
   /* because we will work with Vu and Vt separately   */
   /* to evaluate the function values.                 */
   /*--------------------------------------------------*/
   subsvar( Vtotexpr.a, "VU", Darkhalo.a, wstr );  /* wstr is a workstring */
   exprlen = strlen( wstr );
   anyoutf( DEBUG, "Result=[%.*s]", ANYLEN(wstr), wstr );

   ExprO.l = MAXEXPRLEN-1;
   clearstr( ExprO );
   r = dydx_c( tofchar( wstr ),
               tofchar("R"),
               ExprO,
               Derv,
               Dummvariables[0],
               &csize,
               &nvars );
   ExprO.l = nelc_c(ExprO);
   ExprO.a[ExprO.l] = '\0';


   anyoutf( DEBUG, "Result after dydx=[%.*s]", ANYLEN(ExprO.a), ExprO.a );
   if (r != 0)
   {
      char  dydxerrmes[STRLEN];
      dydxerror( r, dydxerrmes );
      error_status( dydxerrmes, "Invalid expression for either Vu or Vt", "" );
      rejectf( key, "Invalid expression Vu/Vt" );
      return;
   }


   /*--------------------------------------------------*/
   /* STEP 8: Parse the string that contains the       */
   /* expression for Vtotal, in which VU is included,  */
   /* to 'fieini'                                      */
   /* to check whether the partial derivatives can be  */
   /* calculated. We don't need this expression for    */
   /* future use because we use the expression which   */
   /* contains the variable VU and not its substi-     */
   /* tution.                                          */
   /*--------------------------------------------------*/
   {
      fint  id = -1;
      fint  r;
      errpos = 0;
      pvars  = fieini_c( ExprO, &id, &errpos );
      if (pvars < 0)
      {
         inifieerror( pvars, errpos, errmes );
         error_status( errmes, "Problems with Vt expression after substitution Vuser", "" );
         rejectf( key, "Invalid expression Vu/Vt" );
         return;
      }
      r = fieclr_c( &id );
      if (r == -1)
         anyoutf( DEBUG, "Problems with fieclr: id out of range");
      if (r == -2)
         anyoutf( DEBUG, "Problems with fieclr: no code generated for this id");
   }

   /*--------------------------------------------------*/
   /* STEP 9: Get the partial derivatives for the      */
   /* lsqfit routines.                                 */
   /*--------------------------------------------------*/
   {
      int   n;

      for (n = 0; n < g->numdervs; n++)
      {
         Partdervs[n].a = derivates;  /*[n*MAXDERVLEN];*/
         Partdervs[n].l = MAXDERVLEN - 1;

         ExprO.l = MAXEXPRLEN-1;
         clearstr( ExprO );
         r = dydx_c( tofchar(wstr),
                     Vars[n],
                     ExprO,
                     Partdervs[n],
                     Dummvariables[0],
                     &csize,
                     &pvars );
         ExprO.l = nelc_c(ExprO);
         ExprO.a[ExprO.l] = '\0';

         Partdervs[n].a[nelc_c(Partdervs[n])] = '\0';
         if (r != 0)
         {
            dydxerror( r, errmes );
            error_status( errmes, "", "" );
         }
         anyoutf( DEBUG, "DYDX: DY/D[%.*s] = [%.*s]",
                  ANYLEN(Vars[n].a),      Vars[n].a,
                  ANYLEN(Partdervs[n].a), Partdervs[n].a );

         errpos = 0;
         pvars  = fieini_c( Partdervs[n], &(g->partid[n]), &errpos );
         if (pvars < 0)
         {
            inifieerror( pvars, errpos, errmes );
            /* Restore old situation and leave */
            error_status( errmes, "Problems initializing partial derivates", "" );
            return;
         }
      }
   }

   /*--------------------------------------------------*/
   /* STEP 10: Parse the user given function Vu and    */
   /* the Vtotal expression in their original form.    */
   /* Parse the expressions by dydx only. Note that to */
   /* evaluate Vtotal data later, we have to evaluate  */
   /* VU data first.                                   */
   /*--------------------------------------------------*/
   {
      fchar   Dummyderv;

      Dummyderv.a = derivates;
      Dummyderv.l = MAXDERVLEN - 1;

      /*--------------------*/
      /* Start with Vu      */
      /*--------------------*/
      /* Here we use dydx as a parser to get rid of {}'s */
      ExprO.l = MAXEXPRLEN-1;
      clearstr( ExprO );
      r = dydx_c( Darkhalo,
                  tofchar("R"),
                  ExprO,
                  Dummyderv,
                  Dummvariables[0],
                  &csize,
                  &pvars );
      ExprO.l = nelc_c(ExprO);
      ExprO.a[ExprO.l] = '\0';

      if (r != 0)
      {
         dydxerror( r, errmes );
         error_status( errmes, "Vu expression problem", "" );
         return;
      }
      errpos = 0;
      pvars  = fieini_c( ExprO, &(g->Vu_id), &errpos );
      if (pvars < 0)
      {
         inifieerror( pvars, errpos, errmes );
         /* Restore old situation and leave */
         error_status( errmes, "Problems initializing Vu", "" );
         return;
      }
      /*--------------------*/
      /* Now process Vtotal */
      /*--------------------*/
      ExprO.l = MAXEXPRLEN-1;
      clearstr( ExprO );
      r = dydx_c( Vtotexpr,
                  tofchar("R"),
                  ExprO,
                  Dummyderv,
                  Dummvariables[0],
                  &csize,
                  &pvars );
      ExprO.l = nelc_c(ExprO);
      ExprO.a[ExprO.l] = '\0';

      if (r != 0)
      {
         dydxerror( r, errmes );
         error_status( errmes, "Vt expression problem", "" );
      }
      errpos = 0;
      pvars  = fieini_c( ExprO, &(g->Vt_id), &errpos );
      if (pvars < 0)
      {
         inifieerror( pvars, errpos, errmes );
         /* Restore old situation and leave */
         error_status( errmes, "Problems initializing Vtotal expression", "");
         return;
      }
   }

   /*--------------------------------------------------*/
   /* STEP 11: Allocate memory for array that contains */
   /* input data for the parser function. For each R   */
   /* there are data entries par1, par2,...parn, VD,VB,*/
   /* VG, VX, R and VU. Therefore the size of the array*/
   /* must be the arraylen of Radii times number of    */
   /* derivatives plus 6 (VD,VB,VG, VX, R and VU).     */
   /*--------------------------------------------------*/
   {
      int size = g->arraylen[RADII] * (g->numdervs+NUMCOMP+2);
      if (g->indata != NULL)
         free( g->indata );
      g->indata = (float *) calloc( size, sizeof(float) );
      if (g->indata == NULL)
      {
         error_status( "Cannot allocate memory anymore!",
                       "Maybe you have to restart the program", "" );
         return;
      }
   }

   /*--------------------------------------------------*/
   /* STEP 12: Display parameter valuators in gui for  */
   /* all the parameters except VD,VB,VG, VX, R and VU.*/
   /*--------------------------------------------------*/
   {
      int   i;
      float mins[MAXPAR];
      float maxs[MAXPAR];
      char  *darkparname[MAXPAR];             /* Local only for the valuators */

      for (i = 0; i < g->numdervs; i++)
      {
         darkparname[i] = Vars[i].a;
         strcpy( g->parname[i], darkparname[i] );
         g->parval[i] = 1.0;
         mins[i] = 0.0;
         maxs[i] = 2.0;
      }
      /* Display the valuators for the dark halo parameters */
      funcpar( g->numdervs, darkparname, g->parval, mins, maxs );
   }

   /* Plot Vu and Vt with these new parameter values */
   redrawfie( g );
   plotcolorlabel( g, VUDAT );
   plotcolorlabel( g, VTDAT );

   /*--------------------------------------------------*/
   /* STEP 13: Schedule new functions corresponding to */
   /* all parameters except VD,VB,VG,R and VU.         */
   /*--------------------------------------------------*/
   {
      int     i;
      char    mes[FITSLEN];

      for (i = 0; i < g->numdervs; i++)
      {
         sprintf( mes, "%s=", g->parname[i] );
         g->sched_const[i] = ScheduleKeyevent( changeparval,
                                               mes,
                                               KEYCHANGE,
                                               &(g->parval[i]) );
         sprintf( mes, "%s_FIX=", g->parname[i] );
         g->sched_fix[i] = ScheduleKeyevent( fixfree,
                                             mes,
                                             KEYCHANGE,
                                             &(g->freepar[i]) );
      }
   }

   /*--------------------------------------------------*/
   /* STEP 14: Schedule the cursor function.           */
   /*--------------------------------------------------*/
   if (g->plotcursorid)
   {
      DescheduleGgiPlotCursor( &(g->plotcursorid) );
   }

   g->plotcursorid = ScheduleGgiPlotCursor( cursor,
                                            GgiPlotField("GRAPHS",0,0),
                                            g );
}




static void plotallcurves( globaltype  *g,
                           int          devicetype )
/*------------------------------------------------------------*/
/* PURPOSE: Plot all curves in a new pgplot device.           */
/*------------------------------------------------------------*/
{
   int     i;
   float   textangle = 0;
   float   textjust = 0.0;
   float   tx, ty;
   char    tlabel[10];


   drawbox( g->radiimin,
            g->observedmin,
            g->radiimax,
            g->observedmax,
            "R (kpc)",
            "V (km/s)", "",
            devicetype );


   for (i = 0; i < DATCURVES; i++)
   {
      plotcurve( g->arraylen[i],
                 g->dataptr[RADII],
                 g->dataptr[i+SCALED],
                 &(g->visible[i]),
                 g->color[i],
                 devicetype );

      if (devicetype == HARDCOPY)
      {
         int   indx = g->arraylen[i] - 1;

         if (i == BULGE)
            strcpy( tlabel, "V\\db" );
         if (i == DISK)
            strcpy( tlabel, "V\\dd" );
         if (i == GAS)
            strcpy( tlabel, "V\\dg" );
         if (i == OTHER)
            strcpy( tlabel, "V\\dx" );

         tx = g->dataptr[RADII][indx];
         ty = g->dataptr[i+SCALED][indx];
         pgptxt_c( &tx, &ty, &textangle, &textjust, tofchar(tlabel) );
      }
   }
   /* Plot the function, if any */

   plotcurve( g->arraylen[VUDAT],
              g->dataptr[RADII],
              g->dataptr[VUDAT],
              &(g->visible[VUDAT]),
              g->color[VUDAT],
              devicetype );
   if (devicetype == HARDCOPY && g->arraylen[VUDAT])
   {
      int   indx = g->arraylen[VUDAT] - 1;
      tx = g->dataptr[RADII][indx];
      ty = g->dataptr[VUDAT][indx];
      pgptxt_c( &tx, &ty, &textangle, &textjust, tofchar("V\\du") );
   }


   plotcurve( g->arraylen[VTDAT],
              g->dataptr[RADII],
              g->dataptr[VTDAT],
              &(g->visible[VTDAT]),
              g->color[VTDAT],
              devicetype );
   if (devicetype == HARDCOPY && g->arraylen[VTDAT])
   {
      int   indx = g->arraylen[VTDAT] - 1;
      tx = g->dataptr[RADII][indx];
      ty = g->dataptr[VTDAT][indx];
      pgptxt_c( &tx, &ty, &textangle, &textjust, tofchar("V\\dt") );
   }



   /* Plot labels */
   if (devicetype == SCREEN)
   {
      for (i = 0; i < DATCURVES; i++)
      {
         if (g->arraylen[i])
            plotcolorlabel( g, i );
      }
      if (g->arraylen[VUDAT]) plotcolorlabel( g, VUDAT );
      if (g->arraylen[VTDAT]) plotcolorlabel( g, VTDAT );
   }

   plotpoints( g->arraylen[OBSERVED],
               g->dataptr[RADII],
               g->dataptr[OBSERVED],
               BIGCIRCLE,
               g->color[OBSERVED] );

   ploterrors( g->arraylen[OBSERR],
               g->dataptr[RADII],
               g->dataptr[OBSERVED],
               g->dataptr[OBSERR],
               g->color[OBSERR] );
}




static void progress( int count,
                      int maxcount )
/*------------------------------------------------------------*/
/* PURPOSE: */
/*------------------------------------------------------------*/
{
   float perc = (float) count / (float) maxcount;
   char  mes[80];

   sprintf( mes, "Chi-2 landscape progress: %d %%", (int) (100.0*perc) );
   error_status( "", mes, "" );
}




static void chi2landscape(  globaltype  *g,
                            float       xlo,
                            float       ylo,
                            float       xhi,
                            float       yhi )
/*------------------------------------------------------------*/
/* PURPOSE: Do the chi2 calculations and plotting.            */
/*                                                            */
/* What must be done to calculate Chi2?  First we must        */
/* collect the data for which a velocity expression must be   */
/* evaluated. To get a Chi2 landscape which represents a      */
/* realistic model from which error ranges can be read we fit */
/* free parameters in the velocity expression for each        */
/* combination of the parameters along the landscape axes.    */
/* These parameters are ofcourse fixed in the fit.            */
/*------------------------------------------------------------*/
{
   fint   nxsub, nysub;
   float  xtick, ytick;
   float  dx, dy;
   fint   ndat;
   int    sdat;
   int    row, col;
   int    count;
   float  maxval = FLT_MIN;
   float  minval = FLT_MAX;
   float  x, y;
   float  ch = 1.0;
   float  nu = 0.0;
   fint   xdim = NUMCOMP+1;
   int    contrib = 0;
   int    nfree;
   int    freecount;
   int    indx1, indx2;
   fint   elapse;
   double cputime,   realtime;                         /* Variables for timer */
   int    indxmin;


   static int   oldmode = -1;



   /* LSQFIT related */
   float      *par;
   fint       *mpar;
   float      *err;
   int         i;
   fint        npar;


   indx1 = g->chi2index[0];
   indx2 = g->chi2index[1];
   setwindow( xlo, ylo, xhi, yhi );
   xtick = ytick = 0.0;
   nxsub = nysub = 0;

   getcharheight( &ch );
   setcharheight( 1.2*ch );
   pgbox_c( tofchar("BCNST" ), &xtick, &nxsub,
            tofchar("BCNSTV"), &ytick, &nysub );

   /*--------------------------------------------------*/
   /* Set the axis labels on top and to the right of   */
   /* the plot.                                        */
   /*--------------------------------------------------*/
   {
      float    disp, coord, fjust;
      coord = 0.5;
      fjust = 0.5;
      disp  = 1.5;
      pgmtxt_c( tofchar("R") , &disp, &coord, &fjust, tofchar(g->parname[indx2]) );
      coord = 0.5;
      fjust = 0.5;
      disp  = 1.0;
      pgmtxt_c( tofchar("T") , &disp, &coord, &fjust, tofchar(g->parname[indx1]) );
   }

   ndat = g->arraylen[RADII];
   npar = g->numdervs;
   par  = (float *) calloc( npar, sizeof(float) );
   err  = (float *) calloc( npar, sizeof(float) );
   mpar = (fint *)  calloc( npar, sizeof(fint) );
   if (par == NULL || err == NULL || mpar == NULL)
   {
      error_status( "Cannot allocate memory for work arrays",
                    "Rerun program", "" );
      return;
   }

   if (g->VdVbVgVxR != NULL)
      free( g->VdVbVgVxR );

   g->VdVbVgVxR = (float *) calloc( ndat*xdim, sizeof(float) );
   if (g->VdVbVgVxR == NULL)
   {
      error_status( "Cannot allocate memory for LSQFIT work array",
                    "Rerun program", "" );
      return;
   }

   /* Set the weights */
   {
      int warningdummy;
      updateweights( g, &warningdummy );
   }
   /*------------------------------------------------------------*/
   /* Set parameters FIXED/FREE. Note that the parameters along  */
   /* the x and y axis of the chi2-landscape must be fixed       */
   /* parameters. The other parameters keep their original       */
   /* FIXED/FREE status. To obtain a low chi2 and therefore a    */
   /* more realistic value for the errors on the parameters, one */
   /* should select the FREE status for as much parameters as    */
   /* possible.                                                  */
   /*------------------------------------------------------------*/
   for (i = 0; i < npar; i++)
   {
      mpar[i] = g->freepar[i];
   }
   mpar[indx1] = FIXED;
   mpar[indx2] = FIXED;
   freecount = 0;
   for (i = 0; i < npar; i++)
   {
      if (mpar[i] == FREE)
         freecount++;
   }

   /* Calculate */
   dx = (xhi - xlo) / (float) (g->chi2stepx-1);
   dy = (yhi - ylo) / (float) (g->chi2stepy-1);
   sdat = g->chi2stepx * g->chi2stepy;

   if (g->chi2data != NULL)
   {
      free( g->chi2data );
      free( g->chi2X );
      free( g->chi2Y );
   }

   g->chi2data = (float *) calloc( (int) sdat, sizeof(float) );
   g->chi2X = (float *) calloc( (int) sdat, sizeof(float) );
   g->chi2Y = (float *) calloc( (int) sdat, sizeof(float) );      

   if (g->chi2data == NULL || g->chi2X == NULL || g->chi2Y == NULL)
   {
      error_status( "Cannot allocate memory for chi^2 arrays.",
                    "Restart program?", "" );
      return;
   }

   filllsqfitdata( g->VdVbVgVxR, xdim, g );


   elapse = 0;
   timer_c( &cputime, &realtime, &elapse );                 /* Reset timer */

   y = ylo;
   for (count = 0, row = 0; row < g->chi2stepy; row++)
   {
      x = xlo;
      for (col = 0; col < g->chi2stepx; col++)
      {
         float   chi, chi2 = 0.0;
         int     its;

         /* Put progress message in status line for each 10 sample points */
         /* Correct for the fact that count starts at 0. */
         if (!(count%10))
            progress( count+1, g->chi2stepx*g->chi2stepy );

         /* Handle the event queue, i.e. check the GO button  */
         /* if there are events queued. */
         if (GgiHandleEvents())
         {
            if (!UserLog("GO="))
            {
               error_status( "", "User abort in chi-2 landscape calculations", "" );
               return;
            }
         }


         for (i = 0; i < npar; i++)
         {
            par[i] = g->parval[i];
         }
         par[indx1] = x;
         par[indx2] = y;

         if (freecount > 0)
         {
            its = lsqfit_c(  g->VdVbVgVxR,
                             &xdim,
                             g->dataptr[OBSERVED],
                             g->dataptr[WEIGHTS],
                             &ndat,
                             par,
                             err,
                             mpar,
                             &npar,
                             &(g->tol),
                             &(g->maxits),
                             &(g->lab),
                             g->partid );
         }
         else
         {
            /* dummy */
            its = 1;
         }

         g->chi2X[count] = x;
         g->chi2Y[count] = y;
         if (its < 0)
         {
            g->chi2data[count] = 0.0;
         }
         else
         {
            contrib = 0;
            for (i = 0; i < ndat; i++)
            {
               float V;

               fint  dummyid = 0;

               /* Calculate V_total for these velocities &  radius */
               V = func_c( &(g->VdVbVgVxR[i*xdim]),
                           par,
                           &npar,
                           &dummyid );
               if (V != blank)
               {
                  chi = g->dataptr[OBSERVED][i] - V;
               }
               else
                  chi = blank;
               /* Calculate sum 'chi' */
               {
                  float sigma;
                  if (g->weights == WEIGHTS_UNI || g->arraylen[OBSERR] == 0)
                  {
                     sigma = 1.0;
                  }
                  else
                  {
                     sigma = g->dataptr[OBSERR][i];
                  }
                  if (sigma != 0.0)
                  {
                     chi /= sigma;
                     contrib++;
                  }
               }
               if (chi != blank)
               {                
                  chi2 += chi * chi;                  
               }
            }
            g->chi2data[count] = chi2;
         }
         x += dx;
         count++;
      }
      y += dy;
   }

   /* How long did it take to calculate the chi2 samples? */
   elapse = 1;
   timer_c( &cputime, &realtime, &elapse );

   /* Calculate number of valid points minus degrees of freedom */
   nfree = 2;
   nu = (float) MYMAX( 0, (contrib-nfree-1) );


   g->chi2datalen = count;

   if (g->chi2mode < 0)
      g->chi2mode = 0;
   if (g->chi2mode > CONFIDENCE )
      g->chi2mode = CONFIDENCE;

   /* determine min, max chi2 */
   indxmin = 0;
   for (i = 0; i < count; i++)
   {
      if (g->chi2data[i] != blank)
      {
         if (g->chi2data[i] > maxval)
            maxval = g->chi2data[i];
         if (g->chi2data[i] < minval)
         {
            minval = g->chi2data[i];
            indxmin = i;
         }
      }
   }          
   anyoutf( DEBUG, "chi2 plot: minval=%f, maxval=%f", minval, maxval );
   
  
   free( par );
   free( err );
   free( mpar );


   /*--------------------------------------------------*/
   /* Make a contour plot of the chi2 data.            */
   /*--------------------------------------------------*/
   {
      fint    nx = g->chi2stepx;
      fint    ny = g->chi2stepy;
      fint    one = 1;
      float   trans[6];
      float   levels[MAXLEVELS];
      fint    nc;
      fint    nitems = 1;
      fint    dfault = HIDDEN;

      /* Are there already levels defined? */
      nitems = MAXLEVELS;
      nc = userreal_c( levels,
                       &nitems,
                       &dfault,
                       tofchar("LEVELS="),
                       tofchar(" ") );
      /* No levels, create a default and display in input field */
      if (nc == 0 || g->chi2mode != oldmode)
      {
         /*----------------------------------------*/
         /* Levels were expressed in sigma's.      */
         /* Convert levels to new set of chi2's.   */
         /*----------------------------------------*/
         int     k;
         float   freedom = 2;
         float   deltachi2;
         char    mes[80];

         for (k = 0; k < 5; k++)
         {
            levels[k] = (float) (k+1);
            if (g->chi2mode == CHI2LANDSCAPE)
            {
               deltachi2 = confidence( freedom, levels[k], 0.000001, mes );
               if (deltachi2 == blank)
                  error_status( "Problems converting confidence levels!", mes, "" );
               else
                  levels[k] = minval + deltachi2;
            }
         }
         if (g->chi2mode == CHI2LANDSCAPE)
         {
            /* wkeyf( "LEVELS=%.2f 10**(log(%.2f)*(0:10)/10)", 1.1*minval, maxval ); */
            wkeyf( "LEVELS=%g %g %g %g %g",
                    levels[0], levels[1], levels[2], levels[3], levels[4] );
         }
         if (g->chi2mode == CONFIDENCE)
            wkeyf( "LEVELS=1 2 3 4 5" );
      }
      oldmode = g->chi2mode;
      /* read the LEVELS= input field. */
      nc = userreal_c( levels,
                       &nitems,
                       &dfault,
                       tofchar("LEVELS="),
                       tofchar(" ") );

      if (g->chi2mode == CONFIDENCE)
      {
         /*----------------------------------------*/
         /* Levels were expressed in sigma's.      */
         /* Convert levels to new set of chi2's.   */
         /*----------------------------------------*/
         int     k;
         float   freedom = 2;
         float   deltachi2;
         char    mes[80];

         for (k = 0; k < nc; k++)
         {
            deltachi2 = confidence( freedom, levels[k], 0.000001, mes );
            if (deltachi2 == blank)
               error_status( "Problems converting confidence levels!", mes, "" );
            else
               levels[k] = minval + deltachi2;
         }
      }


      /*--------------------------------------------------*/
      /* This is the transformation matrix for PGPLOT.    */
      /* Note that PGPLOT uses Fortran indices which      */
      /* start with 1. Therefore subtract dx and dy       */
      /* for the correct position of the first pixel.     */
      /*--------------------------------------------------*/
      trans[0] = xlo-dx; trans[1] = dx;  trans[2] = 0.0;
      trans[3] = ylo-dy; trans[4] = 0.0; trans[5] = dy;

      /* Put cross at position of minimum */
      setcolor( GREEN );
      setmarker( g->chi2X[indxmin], g->chi2Y[indxmin], 5 );

      /* Plot contour corresponding to FIRST level in RED */
      setcolor( RED );      
      pgconb_c( g->chi2data, &nx, &ny, &one, &nx, &one, &ny,
                &levels[0], &one, trans, &blank );
      /* Now we have one contour less */
      nc--;
      setcolor( YELLOW );
      pgconb_c( g->chi2data, &nx, &ny, &one, &nx, &one, &ny,
                &levels[1], &nc, trans, &blank );
   }
   setcharheight( ch );

   /* Put finish message on status lines */
   {
      char timemes[80];
      sprintf( timemes, "Landscape data calculated in %g cpu seconds.", cputime );
      error_status( "", "Ready with chi-2 landscape.", timemes );
   }
}




static void chi2plot( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: GO= keyword handler. Before plotting a chi^2      */
/*          landscape find out which parameters are involved. */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool         gochi2 = UserLog(key);
   fint         varval[2];
   fint         nitems  = 1;
   fint         dfault  = HIDDEN;
   fint         r;
   int          varsok = YES;


   if (!gochi2)
      return;

   /*--------------------------------------------------*/
   /* First set a window. But in order to set the      */
   /* window we need the plot limits. These are set by */
   /* the selected variables. Find the indices of the  */
   /* variables first by reading keywords VAR1= and    */
   /* VAR2=                                            */
   /* Report an omission of keyword VAR2= first because*/
   /* if VAR1= also has no value then the last one     */
   /* pops up in an error message.                     */
   /*--------------------------------------------------*/
   {
      int     k;
      char    mes[2][FITSLEN];

      strcpy( mes[0], "VAR1=" );
      strcpy( mes[1], "VAR2=" );

      for (k = 0; k < 2; k++)
      {
         char    axis[2];
         axis[0] = 'x';
         axis[1] = 'y';
         varsok = YES;
         r = userint_c( &varval[k],
                        &nitems,
                        &dfault,
                        tofchar(mes[k]),
                        tofchar(" ") );
         if (r < 1 || r > g->numdervs)
         {
            char    str[STRLEN];
            sprintf( str, "No parameter for %c axis selected!", axis[k] );
            error_status(  str, "Use menu to select variable", "" );
            varsok = NO;
         }
         if (!varsok)
         {
            wkeyf( key );                                /* Reset 'GO' button */
            return;                                     /* and leave function */
         }
      }
   }

   /*--------------------------------------------------*/
   /* With the base keywords, read the MIN, MAX        */
   /* keywords and create the chi2 landscape.          */
   /*--------------------------------------------------*/
   {
      int   i;
      char  str[STRLEN];
      float xymin[2], xymax[2];

      error_status( "", "", "" );
      for (i = 0; i < 2; i++)
      {
         char    mes[STRLEN];
         int     indx = varval[i] - 1;

         /* Store the chi2 landscape axisnames for later use */
         /* e.g. update of keyword values in cursor routine. */

         g->chi2axisnames[i] = g->parname[indx];
         strcpy( str, g->parname[indx] );

         sprintf( mes, "%s_MIN=", str );
         (void) userreal_c( &xymin[i],
                            &nitems,
                            &dfault,
                            tofchar(mes),
                            tofchar(" ") );
         sprintf( mes, "%s_MAX=", str );
         (void) userreal_c( &xymax[i],
                            &nitems,
                            &dfault,
                            tofchar(mes),
                            tofchar(" ") );
      }

      /* Store old window parameters */
      {
         float xloold, xhiold, yloold, yhiold;

         pgqwin_c( &xloold, &xhiold, &yloold, &yhiold );
         pgend_c();                              /* Close current plot device */
         initplot( "CHI2", CHI2VIEWPORT,1,1 );/* open CHI2 screen device */
         if (g->chi2cursorid)
         {
            DescheduleGgiPlotCursor( &(g->chi2cursorid) );
         }
         g->chi2cursorid = ScheduleGgiPlotCursor( chi2cursor,
                                                  GgiPlotField("CHI2",0,0),
                                                  g );
         g->chi2index[0] = varval[0] - 1;
         g->chi2index[1] = varval[1] - 1;
         chi2landscape( g,
                        xymin[0], xymin[1],
                        xymax[0], xymax[1] );

         pgend_c();                                 /* Close CHI2 plot device */
         initplot( "GRAPHS//APPEND", MAINVIEWPORT,1,1 ); /* Reopen main plot */
         setwindow( xloold, yloold, xhiold, yhiold );      /* Set scale again */
      }
   }
   wkeyf( key );                                         /* Reset 'GO' button */
}




static void resizeplot( ident id,
                        char  *key,
                        int   code,
                        void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: BOX= keyword handler                              */
/* Set a different window on the RV plot. The BOX= keyword is */
/* read in the initplot() function.                           */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;

   if (g->onlyboxtxt)
   {
      g->onlyboxtxt = NO;
      return;
   }
   pgend_c();                                    /* Close current plot device */
   initplot( "GRAPHS", MAINVIEWPORT,1,1 );         /* Reopen main plot device */
   clearscreen();
   resetvisibility( g );
   /* Read BOX= and plot (new) frame before curves */
   plotallcurves( g, SCREEN );
}




static void plotxvmap(  ident id,
                        char  *key,
                        int   code,
                        void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: XV_GO= keyword handler.                           */
/*------------------------------------------------------------*/
{
   settype  *inset = (settype *) arg;
   bool     goxv = UserLog(key);
   fint     nxsub, nysub;
   float    xtick, ytick;
   float    xlo, xhi, ylo, yhi;
   float    xloold, xhiold, yloold, yhiold;
   float    Vlohi[2];
   float    Xlohi[2];
   int      xvtohardcopy = NO;


   if (goxv)
      wkeyf( key );    /* Reset GO button */

   /*--------------------------------------------------*/
   /* If the function is called in a pseudo event in   */
   /* the plotoutput function then bypass the value of */
   /* XV_GO=                                           */
   /*--------------------------------------------------*/
   if (id == NULL)
   {
      goxv = YES;
      xvtohardcopy = YES;
   }

   if (xvup() && goxv && inset->validbox)
   {
      /* Store old window parameters */
      pgqwin_c( &xloold, &xhiold, &yloold, &yhiold );
      if (xvtohardcopy)
      {
         /* A plot device is opened in the calling environment */
      }
      else
      {
         /* A plot device must be opened */
         initplot( "XVPLOT", XVVIEWPORT,1,1 );       /* open XV plot screen */
         clearscreen();
         inset->visibleVT = inset->visibleVTmir = NO;
      }
      xlo = inset->blo[0]; xhi = inset->bhi[0];
      ylo = inset->blo[1]; yhi = inset->bhi[1];
      setwindow( xlo, ylo, xhi, yhi );
      xtick = ytick = 0.0;
      nxsub = nysub = 0;


      /* Plot two axis with pixel labels in a small font */
      setcharheight( 0.6 );
      pgbox_c( tofchar("CMST" ), &xtick, &nxsub,
               tofchar("CMSTV"), &ytick, &nysub );
      setcharheight( 1.0 );

      /* Plot contours */
      {
         fint  cwlo, cwhi;
         fint  tid = 0;
         fint  pixelsread;
         float *image = NULL;
         fint  idim = (inset->bhi[0] - inset->blo[0] + 1);
         fint  jdim = (inset->bhi[1] - inset->blo[1] + 1);
         fint  buflen = idim * jdim;


         cwlo   = gdsc_fill_c( inset->name, &(inset->subin[0]), inset->blo );
         cwhi   = gdsc_fill_c( inset->name, &(inset->subin[0]), inset->bhi );
         image = (float *) calloc( (int) buflen, sizeof(float) );
         if (image == NULL)
         {
            error_status( "Cannot allocate memory to plot contours", "", "" );
         }
         else
         {
            float trans[6];
            fint  startindexX = 1;
            fint  startindexY = 1;
            fint  endindexX   = idim;
            fint  endindexY   = jdim;

            trans[0] = inset->blo[0] - 1.0;           /* Fortran indices in pgconb from 1..n */
            trans[1] = 1.0;
            trans[2] = 0.0;
            trans[3] = inset->blo[1] - 1.0;
            trans[4] = 0.0;
            trans[5] = 1.0;

            gdsi_read_c( inset->name,
                         &cwlo, &cwhi,
                         image,
                         &buflen,
                         &pixelsread,
                         &tid );
            pgconb_c( image,
                      &idim,
                      &jdim,
                      &startindexX,
                      &endindexX,
                      &startindexY,
                      &endindexY,
                      inset->levels,
                      &(inset->numlevels),
                      trans,
                      &blank );

            free( image );
         }
      }
      /* Set frame and window in physical coordinates */
      /*--------------------------------------------------*/
      /* Determine the minimum and maximum physical       */
      /* values for the V axis (must be in km/s).         */
      /*--------------------------------------------------*/
      {
         fint     r;
         double   grids[2];
         double   phys[2];

         grids[0] = 0.0;
         grids[1] = (double) ylo;
         r = grtoph_c( inset->name, &(inset->subin[0]), grids, phys );
         Vlohi[0] = (float) (phys[1] * inset->Vtokms);
         grids[0] = 0.0;
         grids[1] = (double) yhi;
         r = grtoph_c( inset->name, &(inset->subin[0]), grids, phys );
         Vlohi[1] = (float) (phys[1] * inset->Vtokms);
         anyoutf( DEBUG, "Vlo=%f, Vhi=%f (km/s)", Vlohi[0], Vlohi[1] );
      }
      /*--------------------------------------------------*/
      /* Determine the minimum and maximum offset position*/
      /* of the first spatial axis.                       */
      /*--------------------------------------------------*/
      {
         Xlohi[0] = xlo * (float) inset->offsetcdelt;
         Xlohi[1] = xhi * (float) inset->offsetcdelt;
         anyoutf( DEBUG, "Xlo=%f, Xhi=%f (ARCMIN)", Xlohi[0], Xlohi[1] );
         /* Convert from arcmin to kpc */
         Xlohi[0] *= 0.290888 * inset->galaxydist;
         Xlohi[1] *= 0.290888 * inset->galaxydist;
         anyoutf( DEBUG, "Xlo=%f, Xhi=%f (kpc)", Xlohi[0], Xlohi[1] );
         inset->xlo = Xlohi[0];
         inset->xhi = Xlohi[1];
         inset->vlo = Vlohi[0];
         inset->vhi = Vlohi[1];
      }

      setwindow( Xlohi[0], Vlohi[0], Xlohi[1], Vlohi[1] );
      pgbox_c( tofchar("BNST" ), &xtick, &nxsub,
               tofchar("BNSTV"), &ytick, &nysub );
      pglab_c( tofchar("R (kpc)"), tofchar("V (km/s)"), inset->name );

      linestyle( DOTTED );
      plmove(  inset->xlo, inset->Vsys );
      pldraw(  inset->xhi, inset->Vsys );
      plmove( 0.0, inset->vlo );
      pldraw( 0.0, inset->vhi );
      linestyle( FULL_LINE );

      if (xvtohardcopy)
      {
         int    dummy;
         int    lw;

         getlinewidth( &lw );
         setlinewidth( 4 );
         plotcurve( globals.arraylen[RADII],
                    inset->convertedR,
                    inset->convertedV,
                    &(dummy),
                    CYAN,
                    HARDCOPY );
         plotcurve( globals.arraylen[RADII],
                    inset->mirrorR,
                    inset->mirrorV,
                    &(dummy),
                    CYAN,
                    HARDCOPY );
         setlinewidth( lw );                        /* Restore line width */
      }
      /* Return to main window */
      if (!xvtohardcopy)
      {
         initplot( "GRAPHS//APPEND", MAINVIEWPORT,1,1 );
         setwindow( xloold, yloold, xhiold, yhiold );
         plotinXV( inset,
                   globals.arraylen[VTDAT],
                   globals.dataptr[RADII],
                   globals.dataptr[VTDAT],
                   globals.color[VTDAT] );
      }
   }
}




static void plotoutput( ident id,
                        char  *key,
                        int   code,
                        void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: PLOT= keyword handler                             */
/* It reads the PLOT= keywords which holds the new plot       */
/* destination. Then all curves are plotted, the dark halo    */
/* expression etc. At last, return to the RV plot.            */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint        dfault = HIDDEN;
   fint        r;
   char        buf[STRLEN];
   char        mes[STRLEN];
   char        mes1[STRLEN];
   fchar       Device;
   float       disp, coord, fjust;
   int         i;
   float       xloold, xhiold, yloold, yhiold;


   Device.a = buf; Device.l = STRLEN;
   r = usertext_c( Device,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );


   Device.a[nelc_c(Device)] = '\0';
   pgqwin_c( &xloold, &xhiold, &yloold, &yhiold );
   pgend_c();
   initplot( Device.a, VIEWPORTPLOT,2,1 );
   pgpage_c();
   plotallcurves( g, HARDCOPY );

   coord = 0.0;
   fjust = 0.0;
   setcharheight( 0.7 );
   if (g->Vu_id >= 0)
   {
      disp  = 8.0;
      sprintf( mes, "Vu(R) = %.*s", ANYLEN(g->darkhalo), g->darkhalo );
      pgmtxt_c( tofchar("B") , &disp, &coord, &fjust, tofchar(mes) );
   }

   if (g->Vt_id >= 0)
   {
      disp  = 10.0;
      sprintf( mes, "Vt(R) = %.*s", ANYLEN(g->vtotal), g->vtotal );
      pgmtxt_c( tofchar("B") , &disp, &coord, &fjust, tofchar(mes) );
   }

   strcpy( mes, "" );
   for (i = 0; i < g->numdervs; i++)
   {
      /* Hersey 2233 is a plusminus chararacter */
      sprintf( mes1, "%s= %g \\(2233) %g  ", g->parname[i], g->parval[i], g->parerr[i] );
      strcat( mes, mes1 );
   }
   disp  = 12.0;
   pgmtxt_c( tofchar("B") , &disp, &coord, &fjust, tofchar(mes) );

   /*--------------------------------------------------*/
   /* Include also the XV plot if any.                 */
   /* Advance to second sub page first and generate a  */
   /* pseudo event for XV_GO=.                         */
   /*--------------------------------------------------*/
   if ( xvup() )
   {
      pgpage_c();
      plotxvmap( NULL, "XV_GO=", KEYCHANGE, &xvset );          /*pseudo event */
   }
   pgiden_c();                                              /* Identification */

   pgend_c();                                            /* Close plot device */
   error_status( "", "Plot is ready", "If saved to file then look in GIPSY log file for its name" );


   initplot( "GRAPHS//APPEND", MAINVIEWPORT,1,1 );        /* Reopen main plot */
   setwindow( xloold, yloold, xhiold, yhiold );            /* Set scale again */
}




static void  getxvinc( ident id,
                       char  *key,
                       int   code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: XV_INC=  keyword handler.                         */
/*------------------------------------------------------------*/
{
   settype    *inset = (settype *) arg;
   fint       nitems = globals.arraylen[RADII];
   fint       dfault = HIDDEN;
   fint       r;

   if (nitems == 0 || inset->inc == NULL)
   {
      rejectf( key, "No radii entered!" );
      error_status( "No radii entered!", "Use INPUTS screen to enter radii", "" );
      return;
   }
   r =  userreal_c( inset->inc,
                    &nitems,
                    &dfault,
                    tofchar(key),
                    tofchar(" ") );

   if (r == 0)
   {
      inset->inclen = 0;
      return;
   }
   if (r < nitems)
   {
      int    k;
      for (k = r; k < nitems; k++)
      {
         inset->inc[k] = inset->inc[k-1];
      }
   }
   inset->inclen = nitems;
   if ( xvup() )
   {
      plotinXV( inset,
                globals.arraylen[VTDAT],
                globals.dataptr[RADII],
                globals.dataptr[VTDAT],
                globals.color[VTDAT] );
   }
}




static void  getxvpa( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: XV_PA=  keyword handler.                          */
/*------------------------------------------------------------*/
{
   settype    *inset = (settype *) arg;
   fint       nitems = globals.arraylen[RADII];
   fint       dfault = HIDDEN;
   fint       r;

   if (nitems == 0 || inset->pa == NULL)
   {
      rejectf( key, "No radii entered!" );
      error_status( "No radii entered!", "Use INPUTS screen to enter radii", "" );
      return;
   }
   r =  userreal_c( inset->pa,
                    &nitems,
                    &dfault,
                    tofchar(key),
                    tofchar(" ") );

   if (r == 0)
   {
      inset->palen = 0;
      return;
   }
   if (r < nitems)
   {
      int    k;
      for (k = r; k < nitems; k++)
      {
         inset->pa[k] = inset->pa[k-1];
      }
   }
   inset->palen = nitems;
   if ( xvup() )
   {
      plotinXV( inset,
                globals.arraylen[VTDAT],
                globals.dataptr[RADII],
                globals.dataptr[VTDAT],
                globals.color[VTDAT] );
   }
}




static void getxvcont( ident id,
                       char  *key,
                       int   code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: XV_LEVELS= keyword handler.                       */
/*------------------------------------------------------------*/
{
   settype    *inset = (settype *) arg;
   fint       nitems = MAXLEVELS;
   fint       dfault = HIDDEN;

   inset->numlevels = userreal_c( inset->levels,
                                  &nitems,
                                  &dfault,
                                  tofchar(key),
                                  tofchar(" ") );
}




static void getxvbox(  ident id,
                       char  *key,
                       int   code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: XV_BOX= handler.                                  */
/*------------------------------------------------------------*/
{
   fint     boxopt = 0;
   fint     showdev = DEBUG;
   fint     dfault = HIDDEN;
   settype  *inset = (settype *) arg;


   if (!inset->validset)
   {
      rejectf( key, "No set available!" );
      error_status( "Enter a set first!", "", "" );
      inset->validbox = NO;
      return;
   }
   gdsbox_c( inset->blo,
             inset->bhi,
             inset->name,
             inset->subin,
             &dfault,
             tofchar( key ),
             tofchar( " " ),
             &showdev,
             &boxopt );

   if (boxopt == -1)
   {
      error_status( "Cannot apply box", "", "" );
      inset->validbox = NO;
      return;
   }
   inset->validbox = YES;
}




static void getxvset(  ident id,
                       char  *key,
                       int   code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: XV_INSET= handler.                                */
/*------------------------------------------------------------*/
{
   fint     maxsubs = 1;
   fint     maxaxes = MAXAXES;           /* Max num. of axes the program can deal with.*/
   fint     class   = 1;                 /* Class 1 is for applications which repeat */
   fint     showdev = DEBUG;
   fint     dfault = HIDDEN + 100;
   settype  *inset = (settype *) arg;


   error_status( "", "", "" );           /* Clear status area */

   inset->name.a = inset->buf;
   inset->name.l = STRLEN-1;
   inset->subdim = 2;                    /* Allow only 2-dim structures */
   inset->nsubs =
           gdsinp_c( inset->name,        /* Name of input set. */
                     inset->subin,       /* Array containing subsets coordinate words. */
                     &maxsubs,           /* Maximum number of subsets in 'subin'.*/
                     &dfault,            /* Default code as is USERxxx. */
                     tofchar(key),       /* Keyword prompt. */
                     tofchar(" "),       /* Keyword message for the user. */
                     &showdev,           /* Device number (as in ANYOUT). */
                     inset->axnum,       /* Array of size 'maxaxes' containing the axes numbers. */
                                         /* The first elements (upto the dimension of the subset) */
                                         /* contain the axes numbers of the subset, */
                                         /* the other ones contain the axes numbers */
                                         /* outside the subset ordered according to the */
                                         /* specification by the user. */
                     inset->axcount,     /* Number of grids on axes in 'axnum' */
                     &maxaxes,           /* Max. number of axes. */
                                         /* the operation for each subset. */
                     &class,             /* Class 1 is for applications which repeat */
                     &(inset->subdim) ); /* Dimensionality of the subsets for class 1 */
   if (inset->nsubs == 0)
   {
      error_status( "Cannot read this set", "", "" );
      inset->validset = NO;
      return;
   }
   else
   {
      inset->validset = YES;
   }


   inset->setdim  = gdsc_ndims_c( inset->name, &setlevel );

   /*-------------------------------*/
   /* Determine edges of this frame */
   /*-------------------------------*/
   {
      fint cwlo, cwhi;                          /* Local coordinate words */
      int  m;
      fint r2, r1 = 0;
      gdsc_range_c( inset->name, &setlevel, &cwlo, &cwhi, &r1 );
      r1 = r2 = 0;
      for (m = 0; m < (int) inset->subdim; m++)
      {
         inset->flo[m] = gdsc_grid_c( inset->name, &(inset->axnum[m]), &cwlo, &r1 );
         inset->fhi[m] = gdsc_grid_c( inset->name, &(inset->axnum[m]), &cwhi, &r2 );
      }
      /*--------------------------------------------------*/
      /* If there was no box specified at startup,        */
      /* substitute a default and trigger the box routine.*/
      /*--------------------------------------------------*/
      {
         char     dum[STRLEN+1];
         fchar    Dummy;
         fint     dfault = HIDDEN;

         Dummy.a = dum;  Dummy.l = STRLEN;
         /* Substitute a default box for the XV_BOX keyword */
         for (m = 0; m < 2; m++)
         {
           inset->blo[m] = inset->flo[m];
           inset->bhi[m] = inset->fhi[m];
         }
         /* Substitute default box if none was given */
         if (!(usertext_c( Dummy, &dfault, tofchar("XV_BOX="), tofchar("") ) ))
         {
            wkeyf( "XV_BOX=%d %d %d %d", inset->blo[0], inset->blo[1],
                   inset->bhi[0], inset->bhi[1] );
         }
      }
   }
   /*--------------------------------------------------*/
   /* Get the header units of the 2nd subset axis.     */
   /*--------------------------------------------------*/
   {
      fint r;
      inset->Vunits.a = inset->vunits;
      inset->Vunits.l = FITSLEN;
      clearstr( inset->Vunits );
      r = axunit_c( inset->name, &(inset->axnum[1]), inset->Vunits );
      r = factor_c( inset->Vunits, tofchar("km/s"), &(inset->Vtokms) );
      if (r != 0)
      {
         rejectf( key, "Cannot transform V to km/s!" );
         error_status( "Invalid velocity axis!",
                       "The 2nd axis of this set cannot be transformed to km/s",
                       "" );
         return;
      }
      anyoutf( DEBUG, "Transformation factor to km/s = %f", inset->Vtokms );
   }
   /*--------------------------------------------------*/
   /* Get the cdelt of the first (spatial) axis.       */
   /*--------------------------------------------------*/
   {
      fint r;
      char   cbuf[FITSLEN];
      fchar  Xunits;
      sprintf( cbuf, "CDELT%d", inset->axnum[0] );
      r = 0;
      gdsd_rdble_c( inset->name,
                    tofchar(cbuf),
                    &setlevel,
                    &(inset->offsetcdelt),   /* Cdelt in header units */
                    &r );
      if (r < 0)
      {
         error_status( "Cannot find grid spacing for spatial axis!",
                       "Value 1.0 arcmin is substituted.", "" );
         inset->offsetcdelt = 1.0;
      }
      Xunits.a = cbuf;
      Xunits.l = FITSLEN;
      clearstr( Xunits );
      r = axunit_c( inset->name, &(inset->axnum[0]), Xunits );
      r = factor_c( Xunits, tofchar("ARCMIN"), &(inset->Xtoarcmin) );
      if (r != 0)
      {
         rejectf( key, "Cannot convert X to arcmin!" );
         error_status( "Invalid spatial axis!", "", "" );
         return;
      }
      inset->offsetcdelt *= inset->Xtoarcmin;
      anyoutf( DEBUG, "Transformation factor to arcmin = %f", inset->Xtoarcmin );
      anyoutf( DEBUG, "One pixel is %lf arcmin", inset->offsetcdelt );
   }
}




static void getsavename( ident id,
                         char  *key,
                         int   code,
                         void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: OUTFILE= and CHI2FILE= keyword handler.           */
/*------------------------------------------------------------*/
{
   char        *filename = (char *) arg;
   globaltype  *g = (globaltype*) arg;
   fchar       Dummy;
   fint        nitems = 1;
   fint        dfault = HIDDEN;


   Dummy.a = filename;
   Dummy.l = FILENAME_MAX - 1;
   (void) userchar_c( Dummy,
                      &nitems,
                      &dfault,
                      tofchar(key),
                      tofchar(" ") );

   /*--------------------------------------------------*/
   /* The struct member 'filename' is the buffer for   */
   /* dummy. We want to keep the entered string as a C */
   /* string and therefore we have to add the zero     */
   /* terminator.                                      */
   /*--------------------------------------------------*/
   filename[nelc_c(Dummy)] = '\0';
}




static void savedata( ident id,
                      char  *key,
                      int   code,
                      void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: SAVE= keyword handler.                            */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool        save = UserLog(key);
   bool        saveover = YES;
   char        buf[STRLEN];
   char        mes[STRLEN];
   FILE        *fp;
   int         ndat = g->arraylen[RADII];
   int         i;
   float       *aptr[NUMSAVEARRAYS];  /* Pointers to arrays */



   if (!save)
      return;

   if (g->arraylen[RADII] == 0)
   {
      error_status( "Nothing to save!", "", "" );
      wkeyf( "SAVE=NO" );
      return;
   }

   /*--------------------------------------------------*/
   /* At this moment, it could be that the global      */
   /*  filename is not yet set. Therefore read the     */
   /*  OUTFILE= contents first.                        */
   /*--------------------------------------------------*/
   getsavename( NULL, "OUTFILE=", KEYCHANGE, g->filename );   /* Pseudo event */


   fp = fopen( g->filename, "r" );
   if (fp != NULL)
   {
      /* It can be opened to read, so it exists */
      saveover = UserLog( "SAVE_OVER=" );
      fclose( fp );
   }
   if (!saveover)
   {
      ask_overwrite();
      return;
   }


   fp = fopen( g->filename, "w" ); /* Open text file for read/write */
   if (fp == NULL)
   {
      char    mes[512];
      sprintf( mes, "Cannot open file [%s] on disk to save data!", g->filename );
      error_status( mes, "", "" );
      wkeyf( "SAVE=NO" );
      return;
   }

   /* Fill the comment fields */
   stamp( mes );
   fprintf( fp, "!# Results of ROTMAS saved at %s\n", mes );
   fprintf( fp, "!# User velocity         : Vu=%s\n", g->darkhalo );
   fprintf( fp, "!# Total velocity        : Vt=%s\n", g->vtotal );
   fprintf( fp, "!# Chi-square            : %g\n", g->chi2.chi2 );
   fprintf( fp, "!# Red. Chi-square (N=%d,n=%d) : %f\n", 
                                             g->chi2.ndat,
                                             g->chi2.nfree,
                                             g->chi2.redchi2 );

   strcpy( buf, "!# Parameter name  : " );
   for (i = 0; i < g->numdervs; i++)
   {
      sprintf( mes, "%12s", g->parname[i] );
      strcat( buf, mes );
   }
   fprintf( fp, "%s\n", buf );

   strcpy( buf, "!# Parameter value : " );
   for (i = 0; i < g->numdervs; i++)
   {
      sprintf( mes, "%12f ", g->parval[i] );
      strcat( buf, mes );
   }
   fprintf( fp, "%s\n", buf );

   strcpy( buf, "!# Parameter error : " );
   for (i = 0; i < g->numdervs; i++)
   {
      sprintf( mes, "%12f ", g->parerr[i] );
      strcat( buf, mes );
   }
   fprintf( fp, "%s\n", buf );


   fprintf( fp, "!#\n" );

   /* Build the header line for the velocities */
   /*              1234567 | 1234567 | 1234567 | 1234567 | 1234567 | 1234567 | 1234567 | 1234567 | 1234567 | 1234567 | 1234567 | */
   fprintf( fp, "!# Radius |  vgas   |  vdisk  |  vbulge |  vother |  vobs   | err vobs|   Vu    |   Vt    |   Rxv   |   Vxy   |\n" );
   fprintf( fp, "!# kpc       km/s      km/s       km/s     km/s      km/s      km/s      km/s      km/s       kpc       km/s   \n" );
   fprintf( fp, "!#============================================================================================================\n" );

   /* Save the velocities in columns */
   aptr[0] = g->dataptr[RADII];
   aptr[1] = g->dataptr[GAS+SCALED];
   aptr[2] = g->dataptr[DISK+SCALED];
   aptr[3] = g->dataptr[BULGE+SCALED];
   aptr[4] = g->dataptr[OTHER+SCALED];
   aptr[5] = g->dataptr[OBSERVED];
   aptr[6] = g->dataptr[OBSERR];
   aptr[7] = g->dataptr[VUDAT];
   aptr[8] = g->dataptr[VTDAT];
   aptr[9] = xvset.convertedR;
   aptr[10] = xvset.convertedV;


   for (i = 0; i < ndat; i++)
   {
      int   j;
      /* Build one line containing the velocities */
      strcpy( buf, "  " );
      for (j = 0; j < NUMSAVEARRAYS; j++)
      {
         sprintf( mes, "%7g   ", aptr[j][i] );
         strcat( buf, mes );
      }
      fprintf( fp, "%s\n", buf );
   }
   fclose( fp );
   g->datasaved = YES;
   wkeyf( "SAVE=NO" );
}




static void savechi2( ident id,
                      char  *key,
                      int   code,
                      void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: SAVECHI2= keyword handler.                        */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool        save = UserLog(key);
   bool        saveover = YES;
   FILE        *fp;


   if (!save)
      return;

   if (g->chi2datalen == 0)
   {
      error_status( "No chi2 data to save!", "", "" );
      wkeyf( "SAVECHI2=NO" );
      return;
   }

   /*--------------------------------------------------*/
   /* At this moment, it could be that the global      */
   /* filename is not yet set. Therefore read the      */
   /* CHI2FILE= contents first.                        */
   /*--------------------------------------------------*/
   getsavename( NULL, "CHI2FILE=", KEYCHANGE, g->chi2file );  /* Pseudo event */

   fp = fopen( g->chi2file, "r" );
   if (fp != NULL)
   {
      /* It can be opened to read, so it exists */
      saveover = UserLog( "OVERCHI2=" );
      fclose( fp );
   }
   if (!saveover)
   {
      ask_chi2over();
      return;
   }

   fp = fopen( g->chi2file, "w" );           /* Open text file for read/write */
   if (fp == NULL)
   {
      char    mes[512];
      sprintf( mes, "Cannot open file [%s] on disk to save data!", g->chi2file );
      error_status( mes, "", "" );
      wkeyf( "SAVECHI2=NO" );
      return;
   }


   /* Write data to this Ascii file */
   {
      char        mes[STRLEN];
      int         i;
  
      /* Print a header */
      stamp( mes );
      fprintf( fp, "!# Results of ROTMAS chi2 data saved at %s\n", mes );
      fprintf( fp, "!# chi2 landscape data from %d x %d sample \n",      
               g->chi2stepx, g->chi2stepy );
      fprintf( fp, "!#  %10s  %12s %12s\n",
               g->parname[g->chi2index[0]],
               g->parname[g->chi2index[1]],
               "value of chi-square" );
               
      /* save the data */
      for (i = 0; i < g->chi2datalen; i++)
      {
         if (g->chi2data[i] != blank)
            fprintf( fp, "%12f  %12f  %12f\n", 
                     g->chi2X[i], g->chi2Y[i], g->chi2data[i] );
         else
            fprintf( fp, "%f     %f        blank\n", 
                     g->chi2X[i], g->chi2Y[i] );
      }
   }

   fclose( fp );
   wkeyf( "SAVECHI2=NO" );
}




static void readmenufromfile( char **name,
                              char **expr,
                              char *key,
                              char **defnames,
                              char **defexpr,
                              int  numdef )
/*------------------------------------------------------------*/
/* PURPOSE: Create a menu with Vt functions and pars.         */
/*------------------------------------------------------------*/
{
   int    i;
   int    kn, ke;
   fint   len;
   fint   dfault = HIDDEN;
   fchar  Filename;
   char   filename[STRLEN];



   /* Store the defaults first */
   kn = ke = 0;
   for (i = 0; i < numdef; i++)
   {
     name[kn] = (char *) calloc( strlen(defnames[i])+1, sizeof(char) );
     strcpy( name[kn], defnames[i] );
     kn++;
     expr[ke] = (char *) calloc( strlen(defexpr[i])+1, sizeof(char) );
     strcpy( expr[ke], defexpr[i] );
     ke++;
   }

   Filename.a = filename; Filename.l = STRLEN - 1;
   strcpy( filename, "" );
   len = usertext_c( Filename, &dfault, tofchar(key), tofchar("") );


   /* Append menu items from user's file */
   if (len)
   {
      /* User entered a name of a file from which he wants to */
      /* read items for a menu */
      FILE   *fp;

      Filename.a[len] = '\0';
      fp = fopen( filename, "r" );
      if (fp != NULL)
      {
         int  toname = YES;
         while (!feof(fp))
         {
            char    buf[1023];
            fgets( buf, 1024, fp );
            if (!feof(fp))
            {
               int  l = strlen( buf );
               if (l > 0)
                  buf[l-1] = '\0';         /* Get rid of newline character */
               if (toname)
               {
                  name[kn] = (char *) calloc( l, sizeof(char) );
                  strcpy( name[kn], buf );
                  kn++;
                  toname = NO;
               }
               else
               {
                  expr[ke] = (char *) calloc( l, sizeof(char) );
                  strcpy( expr[ke], buf );
                  ke++;
                  toname = YES;
               }
            }
         }
      }
   }
   name[kn] = NULL;
   expr[ke] = NULL;
}



static void quit( ident id,
                  char  *key,
                  int   code,
                  void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: QUIT= keyword handler.                            */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool        quit = UserLog(key);
   int         i;


   if (!quit)
      return;

   if (!g->datasaved)
   {

      ggiverify( "Data not saved, quit anyway?", key, &(g->datasaved) );
      return;
   }

   for (i = 0; i < NUMARRAYS; i++)
   {
      if (g->dataptr[i] != NULL)
      {
         free( g->dataptr[i] );
      }
   }

   if (g->indata != NULL)
      free( g->indata );


   /*-------------------------------------------------------*/
   /* To end the program, make sure files opened with fopen */
   /* are closed, allocated memory is released, PGPLOT is   */
   /* closed and HERMES is instructed to stop.              */
   /*-------------------------------------------------------*/
   {
      cancel_c( tofchar("QUIT=") );   /* For restart with macro (!ROTMAS) */
      cancel_c( tofchar("FIT=") );
      cancel_c( tofchar("VAR1=") );
      cancel_c( tofchar("VAR2=") );
      cancel_c( tofchar("HELP=") );
      cancel_c( tofchar("FILEMENU=") );
      cancel_c( tofchar("FILEFORM=") );
      cancel_c( tofchar("SAVE=") );
      cancel_c( tofchar("SAVE_OVER=") );
      pgend_c();
      finis_c();
   }
}




static void showhelp( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: HELP= keyword handler.                            */
/* Extract part of the dc1 document. Put in file and read     */
/* with document viewer.                                      */
/*------------------------------------------------------------*/
{
/*    globaltype  *g = (globaltype*) arg;*/
   fint         indx = -1;
   fint         nitems  = 1;
   fint         dfault  = HIDDEN;



   (void) userint_c( &indx,
                     &nitems,
                     &dfault,
                     tofchar(key),
                     tofchar(" ") );

   if (indx < 0)                                                   /* No item */
      return;
   if (indx == 0)
      GgiShowDoc(NULL);                                       /* Close viewer */

   /*--------------------------------------------------*/
   /* Note that the line in the menu, generates also   */
   /* an item number. This is item nr 1. If a user     */
   /* selects this, nothing happens. Correct the index */
   /* for the help items for including the menu line.  */
   /*--------------------------------------------------*/
   else if (indx == 1)                                 /* Border line in menu */
      return;
   else
      printhelp( indx-1 );                         /* Help on this section nr */
}




static void refresh( ident id,
                     char  *key,
                     int   code,
                     void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: REFRESH= keyword handler. Reread some keywords.   */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool         refresh = UserLog(key);


   if (!refresh)
      return;
   initplot( "GRAPHS", MAINVIEWPORT,1,1 );
   clearscreen();
   resetvisibility( g );

   xvset.visibleVT = NO;
   xvset.visibleVTmir = NO;

   TriggerKey( g->keys[RADII]    );
   TriggerKey( g->keys[OBSERVED] );
   TriggerKey( g->keys[OBSERR]   );
   TriggerKey( g->keys[BULGE]    );
   TriggerKey( g->keys[DISK]     );
   TriggerKey( g->keys[GAS]      );
   TriggerKey( g->keys[OTHER]    );
   TriggerKey( "VTFUN=" );

   /*--------------------------------------------------*/
   /* This reset clears all the arrays which were      */
   /* allocated after (new) radii were given. The inli-*/
   /* nations and position angles must therefore also  */
   /* be updated.                                      */
   /*--------------------------------------------------*/
   TriggerKey( "XV_INC=" );
   TriggerKey( "XV_PA=" );

   wkeyf( "XV_GO=Y" );       /* Push button cannot be triggered */


   wkeyf( key );
}




static void initializestruct( globaltype *g,
                              settype    *xvset )
/*------------------------------------------------------------*/
/* PURPOSE: Initialize values for current status.             */
/*------------------------------------------------------------*/
{
   int i;

   for (i = 0; i < NUMARRAYS; i++)
   {
      g->dataptr[i] = NULL;           /* Set pointers to NULL */
      g->arraylen[i] = 0;
      g->visible[i] = NO;
   }

   g->radiimin    = g->radiimax    = 0.0;
   g->observedmax = g->observedmin = 0.0;

   g->numdervs = 0;
   for (i = 0; i < MAXPAR; i++)
   {
      g->parval[i]  = 1.0;             /* Initialize scale factors */
      g->freepar[i] = FREE;            /* Fix as long as there is no data */
      g->partid[i] = -1;               /* -1 indicates NOT initialized */
   }
   g->Vt_id = g->Vu_id = -1;
   strcpy( g->keys[BULGE],    "BDATA="  );
   strcpy( g->keys[DISK],     "DDATA="  );
   strcpy( g->keys[GAS],      "GDATA="  );
   strcpy( g->keys[OTHER],    "XDATA="  );
   strcpy( g->keys[RADII],    "RADII="  );
   strcpy( g->keys[OBSERVED], "ODATA="  );
   strcpy( g->keys[OBSERR],   "ERRORS=" );

   /* The Radii keywords */
   strcpy( g->radkeys[BRADII],   "BRADII=" );
   strcpy( g->radkeys[DRADII],   "DRADII=" );
   strcpy( g->radkeys[GRADII],   "GRADII=" );
   strcpy( g->radkeys[XRADII],   "XRADII=" );

   /* Special variable parameters used as mass scaling factors */
   strcpy( g->mscalename[BULGE], "MB" );
   strcpy( g->mscalename[DISK], "MD" );
   strcpy( g->mscalename[GAS], "MG" );
   strcpy( g->mscalename[OTHER], "MX" );

   /* Set the colors */

   g->color[BULGE]    = RED;
   g->color[DISK]     = YELLOW;
   g->color[GAS]      = GREEN;
   g->color[OTHER]    = ORANGE;
   g->color[OBSERVED] = CYAN;
   g->color[OBSERR]   = CYAN;
   g->color[VTDAT]    = MAGENTA;
   g->color[VUDAT]    = BLUE;

   g->chi2.chi2 = 0.0;
   g->chi2.redchi2 = 0.0;
   g->chi2mode = CONFIDENCE;
   g->chi2stepx = 20;
   g->chi2stepy = 20;
   g->chi2data  = NULL;
   g->chi2X = NULL;
   g->chi2Y = NULL;   
   g->chi2datalen = 0;

   g->tol    = 0.0;        /* Lsqfit tolerance set to maximum accuracy */
   g->maxits = 100;        /* Lsqfit max. iterartions allowed */
   g->lab    = 0.01;       /* Lsqfit mixing factor */
   g->lsqiters = 0;

   g->indata = NULL;
   g->plotcursorid = NULL;
   g->savedataid = NULL;

   g->emptyVU = YES;
   g->datasaved = NO;
   g->onlyboxtxt = NO;
   g->VdVbVgVxR = NULL;


   xvset->validbox = NO;
   xvset->validset = NO;
   xvset->convertedV = NULL;
   xvset->convertedR = NULL;
   xvset->mirrorV = NULL;
   xvset->mirrorR = NULL;
   xvset->pa  = NULL;
   xvset->inc = NULL;
   xvset->numlevels = 0;
   xvset->palen = 0;
   xvset->inclen = 0;
   xvset->blo[0] = xvset->bhi[0] = 0;    /* Dummy box */
   xvset->blo[1] = xvset->bhi[1] = 0;
   xvset->galaxydist = 1.0;              /* D in Mpc */
   xvset->visibleVT = NO;
   xvset->visibleVTmir = NO;
}




MAIN_PROGRAM_ENTRY
/*-------------------------------------------------------------------------*/
/* The macro MAIN_PROGRAM_ENTRY replaces the C-call main() to start the    */
/* main body of your GIPSY application. Variables defined as 'fchar' start */
/* with a capital.                                                         */
/*-------------------------------------------------------------------------*/
{
   int          i;
   char         *vtnames[100];
   char         *vtexpr[100];
   char         *vunames[100];
   char         *vuexpr[100];

   /*--------------------------------------------------*/
   /* INIT declares the task running to HERMES and     */
   /* does the necessary initializations. All input    */
   /* fields are related to keywords an follow the     */
   /* GIPSY syntax for keywords.                       */
   /*--------------------------------------------------*/
   init_c();
   anyoutf( 8, "ROTMAS release %s", RELEASE );       /* Show task and version */


   /*--------------------------------------------------*/
   /* Call the graphical user interface. This routine  */
   /* creates the application window and defines the   */
   /* interaction and is therefore unique to this      */
   /* application.                                     */
   /*--------------------------------------------------*/
   gui();

   setfblank_c( &blank );
   initializestruct( &globals, &xvset );       /* Initialize global status */

   (void) ScheduleKeyevent( quit,        "QUIT=" ,     KEYCHANGE, &globals );

   (void) ScheduleKeyevent( getbulgedat,  globals.keys[BULGE],    KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getdiskdat,   globals.keys[DISK],     KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getgasdat,    globals.keys[GAS],      KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getotherdat,  globals.keys[OTHER],    KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getradii,     globals.keys[RADII],    KEYCHANGE, &globals );

   (void) ScheduleKeyevent( getobsdat,    globals.keys[OBSERVED], KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getobserrdat, globals.keys[OBSERR],   KEYCHANGE, &globals );

   (void) ScheduleKeyevent( getBradii,   "BRADII=",     KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getDradii,   "DRADII=",     KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getGradii,   "GRADII=",     KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getXradii,   "XRADII=",     KEYCHANGE, &globals );
   
   (void) ScheduleKeyevent( scalebulge,  "MB=",         KEYCHANGE, &globals );
   (void) ScheduleKeyevent( scaledisk,   "MD=",         KEYCHANGE, &globals );
   (void) ScheduleKeyevent( scalegas,    "MG=",         KEYCHANGE, &globals );
   (void) ScheduleKeyevent( scaleother,  "MX=",         KEYCHANGE, &globals );

   (void) ScheduleKeyevent( Vtotal,      "VUFUN=",      KEYCHANGE, &globals );
   (void) ScheduleKeyevent( Vtotal,      "VTFUN=",      KEYCHANGE, &globals );
   (void) ScheduleKeyevent( fit,         "FIT=",        KEYCHANGE, &globals );
   (void) ScheduleKeyevent( fittolog,    "FITTOLOG=",   KEYCHANGE, &globals );

   (void) ScheduleKeyevent( plotoutput,  "PLOTDEV=",    KEYCHANGE, &globals );

   (void) ScheduleKeyevent( getfloat,    "TOL=",        KEYCHANGE, &(globals.tol) );
   (void) ScheduleKeyevent( getfloat,    "LAB=",        KEYCHANGE, &(globals.lab) );
   (void) ScheduleKeyevent( getint,      "MAXITS=",     KEYCHANGE, &(globals.maxits) );

   (void) ScheduleKeyevent( resizeplot , "BOX=",        KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getweight,   "WEIGHTS=",    KEYCHANGE, &globals );

   (void) ScheduleKeyevent( chi2plot,    "GO=",         KEYCHANGE, &globals );
   (void) ScheduleKeyevent( showhelp,    "HELP=",       KEYCHANGE, NULL );
   (void) ScheduleKeyevent( getxvset,    "XV_INSET=",   KEYCHANGE, &xvset );
   (void) ScheduleKeyevent( getxvbox,    "XV_BOX=",     KEYCHANGE, &xvset );
   (void) ScheduleKeyevent( plotxvmap,   "XV_GO=",      KEYCHANGE, &xvset );
   (void) ScheduleKeyevent( getxvcont,   "XV_LEVELS=",  KEYCHANGE, &xvset );
   (void) ScheduleKeyevent( getxvinc,    "XV_INC=",     KEYCHANGE, &xvset );
   (void) ScheduleKeyevent( getxvpa,     "XV_PA=",      KEYCHANGE, &xvset );

   (void) ScheduleKeyevent( getandupdate, "XV_SYSV=",    KEYCHANGE, &(xvset.Vsys) );
   (void) ScheduleKeyevent( getandupdate, "XV_SLICEPA=", KEYCHANGE, &(xvset.slicePA) );
   (void) ScheduleKeyevent( getandupdate, "XV_DISTANCE=",KEYCHANGE, &(xvset.galaxydist) );

   globals.savedataid = ScheduleKeyevent( savedata,    "SAVE=",       KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getsavename, "OUTFILE=",   KEYCHANGE, globals.filename );
   (void) ScheduleKeyevent( getsavename, "CHI2FILE=",  KEYCHANGE, globals.chi2file );   

   (void) ScheduleKeyevent( refresh,     "REFRESH=",   KEYCHANGE, &globals );
   (void) ScheduleKeyevent( getint,      "CHI2MODE=",  KEYCHANGE, &(globals.chi2mode) );

   (void) ScheduleKeyevent( getint,      "CHI2STEPX=", KEYCHANGE, &(globals.chi2stepx) );
   (void) ScheduleKeyevent( getint,      "CHI2STEPY=", KEYCHANGE, &(globals.chi2stepy) );

   (void) ScheduleKeyevent( savechi2,    "SAVECHI2=",  KEYCHANGE, &globals );

   (void) ScheduleKeyevent( getcol, "COLVB=",  KEYCHANGE, &(globals.color[BULGE]) );
   (void) ScheduleKeyevent( getcol, "COLVD=",  KEYCHANGE, &(globals.color[DISK]) );
   (void) ScheduleKeyevent( getcol, "COLVG=",  KEYCHANGE, &(globals.color[GAS]) );
   (void) ScheduleKeyevent( getcol, "COLVOT=", KEYCHANGE, &(globals.color[OTHER]) );
   (void) ScheduleKeyevent( getcol, "COLVO=",  KEYCHANGE, &(globals.color[OBSERVED]) );
   (void) ScheduleKeyevent( getcol, "COLVOE=", KEYCHANGE, &(globals.color[OBSERR]) );
   (void) ScheduleKeyevent( getcol, "COLVT=",  KEYCHANGE, &(globals.color[VTDAT]) );
   (void) ScheduleKeyevent( getcol, "COLVU=",  KEYCHANGE, &(globals.color[VUDAT]) );

   (void) ScheduleKeyevent( readeventsfile, "PARLOAD=", KEYCHANGE, &globals ); 
                                                 

   /* Trigger the _FIX keywords for BULGE, DISK and GAS */
   for (i = 0; i < DATCURVES; i++)
   {
      char    mes[STRLEN];
      sprintf( mes, "%s_FIX=", globals.parname[i] );
      (void) ScheduleKeyevent( fixfree, mes, KEYCHANGE, &(globals.freepar[i]) );
      TriggerKey( mes );
   }

   /* initialization of MAIN plot */
   initplot( "GRAPHS", MAINVIEWPORT, 1, 1 );

   /* Create a menu with well known dark halo functions and pars. */
   {
      char *defnames[]={ "Hernquist",
                         "Isotherm",
                         "Exponential disk",
                         "Navarro-F-W",
                          NULL };

      char *defexpr[] = { HERNQUIST,
                          ISOTHERM,
                          EXPONENTIAL,
                          NFW,
                          NULL };

      readmenufromfile( vunames, vuexpr, "VUMENUFILE=", defnames, defexpr, 4 );
      vumenu( vunames, vuexpr );
   }

   {
      char *defnames[] = { "Standard",
                           "Standard with Vx",
                           "Standard without bulge",
                           "Mond",
                            NULL };

      char *defexpr[] = { STANDARDVT,
                          STANDARDOTHER,
                          STANDARDNOVB,
                          MOND, 
                          NULL };

      readmenufromfile( vtnames, vtexpr, "VTMENUFILE=", defnames, defexpr, 4 );
      vtmenu( vtnames, vtexpr );
   }


   /* Create a menu for the chi2 landscape */
   {
      static char *chi2names[] = { "chi2 landscape",
                                   "Confidence intervals",
                                    NULL };

      chi2menu( chi2names );
   }

   /* Clear the chi2 plot levels */
   wkeyf( "LEVELS=" );

   TriggerKey( globals.keys[RADII]    );
   TriggerKey( globals.keys[OBSERVED] );
   TriggerKey( globals.keys[OBSERR]   );
   TriggerKey( globals.keys[BULGE]    );
   TriggerKey( globals.keys[DISK]     );
   TriggerKey( globals.keys[GAS]      );
   TriggerKey( globals.keys[OTHER]    );

   /*----------------------------------------*/
   /* Make the lsqfit options visible in the */
   /* options menu but only if no prespecifi-*/
   /* cation exists.                         */
   /*----------------------------------------*/
   if (!TriggerKey( "TOL=" ))
      wkeyf("TOL=%f", globals.tol);
   if (!TriggerKey( "LAB=" ))
      wkeyf("LAB=%f", globals.lab);
   if (!TriggerKey( "MAXITS=" ))
      wkeyf("MAXITS=%d", globals.maxits);

   if (!TriggerKey( "CHI2STEPX=" ))
      wkeyf("CHI2STEPX=%d", globals.chi2stepx);
   if (!TriggerKey( "CHI2STEPY=" ))
      wkeyf("CHI2STEPY=%d", globals.chi2stepy);
   if (!TriggerKey( "CHI2MODE=" ))
      wkeyf("CHI2MODE=%d", globals.chi2mode);



   TriggerKey( "VTFUN=" );


   TriggerKey( "XV_DISTANCE=" );
   TriggerKey( "XV_INSET=" );
   TriggerKey( "XV_BOX=" );
   TriggerKey( "XV_LEVELS=" );
   TriggerKey( "XV_INC=" );
   TriggerKey( "XV_PA=" );
   TriggerKey( "XV_SLICEPA=" );
   TriggerKey( "XV_SYSV=" );
   TriggerKey( "CHI2STEPX=" );
   TriggerKey( "CHI2STEPY=" );   
   TriggerKey( "CHI2MODE=" );
   TriggerKey( "COLVB=" );
   TriggerKey( "COLVD=" );   
   TriggerKey( "COLVG=" );
   TriggerKey( "COLVO=" );
   TriggerKey( "COLVOE=" );
   TriggerKey( "COLVT=" );
   TriggerKey( "COLVU=" );


   /* Do not trigger OUTFILE= because it will prompt you to save */
   /* before you have done anything. */
   /* TriggerKey( "OUTFILE=" ); */


   MainLoop();                     /* Start processing events */

   if (globals.VdVbVgVxR != NULL)    /* Release allocated memory */
      free( globals.VdVbVgVxR );

   if (globals.chi2data != NULL)
   {
      free( globals.chi2data );
      free( globals.chi2X );
      free( globals.chi2Y );      
   }

   return( EXIT_SUCCESS );    /* Dummy return */
}
#<

#>            gui.c
/* gui.c -XT
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define SLIDER2

#define GRAPH_NX 700  /* default size of main plot window */
#define GRAPH_NY 535

#define CHI2_LW 100   /* width of chi-sqared output field */

#define STATUSLINES 2 /* number of status lines */

#define MAXDEVLEN 20  /* constants for grdevices */
#define MAXDEVS   20

#include "stddef.h"
#include "stdio.h"
#include "stdlib.h" 
#include "string.h"
#include "math.h"
#include "gipsyc.h"
#include "srvreq.h"
#include "userfio.h"
#include "pgplot.h"
#include "grexec.h"
#include "ggi.h"               /* "GIPSY graphical user interface" */
#include "inputs.h"
#include "inpmod.h"
#include "xvplot.h"
#include "chi2plot.h"
#include "hidden.h"
#include "fileform.h"
#include "chi2form.h"
#include "paramform.h"
#include "colormenus.h"
#include "gui.h"               /* own prototypes */

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

typedef struct _Amplitude {
   ident fix;       /* fix button */
   ident val;       /* value text field */
   ident gauge;     /* value gauge */
   ident min;       /* minimum text field */
   ident max;       /* maximum text field */
   char  *minkey;
   char  *maxkey;
} _Amplitude, *Amplitude;
   
typedef struct _Param {
   struct _Param *next;    /* next Param in linked list */
   char    key[KEYLEN];    /* value keyword */
   char    fixkey[KEYLEN]; /* fix button keyword */
   char    minkey[KEYLEN]; /* range minimum keyword */
   char    maxkey[KEYLEN]; /* range maximum keyword */
   ident   min_h;          /* minimum keyword handler */
   ident   max_h;          /* maximum keyword handler */
   ident   fix_h;          /* fixed keyword handler */
   ident   fix_text_h;     /* fixed keyword text handler */
   ident   valfield;       /* value input field */
   ident   fixbutton;      /* fix button */
   ident   minfield;       /* range minimum input field */
   ident   maxfield;       /* range maximum input field */
   ident   gauge;          /* value gauge */
   float   leftlimit;      /* gauge's left limit */
   float   rightlimit;     /* gauge's right limit */
} _Param, *Param;

static char **plotters;

/* buttons */
static ident b_inputs, b_rotmod, b_xvplot, b_chi2plot, b_colors,
             b_fit, b_hidden, b_doplot, b_refresh;

/* labels */
static ident l_gipsy;
static ident l_chi2, l_temp;
static ident l_status[STATUSLINES], l_error;
static ident l_weights;

/* plotters */
static ident p_graphs;

/* text fields */
static ident t_vufun, t_vtfun;
static ident t_box;

/* gauges */

/* menus */
static ident m_file, m_weights, m_plotters, m_help;

/* reference elements */
ident topref, leftref, partop, parleft, bottom;

typedef enum                { SAVE,
                              PARSAVE,
                              PARLOAD,
                              CHI2SAVE,
                              LINE1,
                              QUIT
                            } filechoice;
static char *file_entries[]={"Save data",
                             "Save parameters",
                             "Load parameters",
                             "Save Chi^2 data",
                             "_LINE",
                             "Exit",
                             NULL};

static char *helplabels[]={
   "Global description",
   "Expressions",
   "List of functions",
   "chi2 landscape",
   "XV plot",
   "Input fields and buttons",
   "Configuration",
   "Hardcopy",
   "About",
   "Graphical user interface",
   "ROTMOD (.dc1) documentation",
   NULL
};

static char *helpdocs[]={
   "rotmas.dc1#1",
   "rotmas.dc1#2",
   "rotmas.dc1#3",
   "rotmas.dc1#4",
   "rotmas.dc1#5",
   "rotmas.dc1#6",
   "rotmas.dc1#7",
   "rotmas.dc1#8",
   "rotmas.dc1#9",
   "ggi.doc",
   "rotmod.dc1"
};

static char *fixedlabels[]={"", NULL};
static char *menulabels[20];
static fint plotsize[2]={GRAPH_NX, GRAPH_NY};

static Param parlist=NULL;

static fint fint1=1, fint2=2;    /* 'convenience' variables */


#if 0 /* tot het nodig is */
/* -------------------------------------------------------------------------- */
/*                                 StrDup                                     */
/* -------------------------------------------------------------------------- */
/*  String duplication function.
 */
static char *StrDup(char *text)
{
   char *result=NULL; 
   
   if (text) {
      result = NNew(strlen(text)+1,char);
      strcpy(result,text);
   }
   return result;
}
#endif

/* -------------------------------------------------------------------------- */
/*                                 UserReal                                   */
/* -------------------------------------------------------------------------- */
static float UserReal(char *key)
{
   float result=0.0;

   (void)userreal_c(&result, &fint1, &fint2, tofchar(key), tofchar(" "));
   return result;
}

/* -------------------------------------------------------------------------- */
/*                                 UserInt                                    */
/* -------------------------------------------------------------------------- */
static int UserInt(char *key)
{
   fint result=0;

   (void)userint_c(&result, &fint1, &fint2, tofchar(key), tofchar(" "));
   return (int)result; 
}

/* -------------------------------------------------------------------------- */
/*                                 UserBool                                   */
/* -------------------------------------------------------------------------- */
static bool UserBool(char *key)
{
   bool result=toflog(FALSE);

   (void)userlog_c(&result, &fint1, &fint2, tofchar(key), tofchar(" "));
   return tobool(result);
}

/* -------------------------------------------------------------------------- */
/*                                 RealDefault                                */
/* -------------------------------------------------------------------------- */
/*  RealDefault() attempts to read the input keyword associated with
 *  'key' and stores it in '*value'.
 *  If it is not present, it writes the supplied default value -the character
 *  value 'cvalue', if this is not NULL, otherwise the argument '*value'
 */
static void RealDefault(char *key, char* cvalue, float *value)
{
   fint nread;   

   nread = userreal_c(value, &fint1, &fint2, tofchar(key), tofchar(" "));
   if (!nread) {   
      char buffer[40];
      if (cvalue) {
         sprintf(buffer, "%s%s", key, cvalue);
          wkey_c(tofchar(buffer));
          *value = UserReal(key);
      } else {
         sprintf(buffer, "%s%f", key, *value);
         wkey_c(tofchar(buffer));
      }
   }
}

#if 1 /* TEST PHASE - remove later */

static void handle_event(ident id, Event event, void *arg)
{
   switch (event->code) {
      case KEYCHANGE: {
         KeyEvent ke=(KeyEvent)event;
         int nc;
         char  ctext[61];
         fchar text;
         text.a = ctext; text.l = 60;
         nc = userftext(text, 2, ke->key, " ");
         ctext[nc]= '\0';
         anyoutf(0, "Event: keyword %s changed: %s", ke->key, ctext);
         break;
      }
      case KEYCANCEL: {
         KeyEvent ke=(KeyEvent)event;
         anyoutf(0, "Event: keyword %s cancelled", ke->key);
         break;
      }
      case KEYREJECT: {
         KeyEvent ke=(KeyEvent)event;
         anyoutf(0, "Event: keyword %s rejected", ke->key);
         break;
      }
      case RESEVENT: {
         anyoutf(0,"Event: resume after pause");
         break;
      }
      default: {
         anyoutf(0,"Event: undefined event code=%d",event->code);
      }
   }
}

/* ========================================================================== */
/*                                 EventMonitor                               */
/* -------------------------------------------------------------------------- */
bool EventMonitor(bool newstate)
{
   static ident id;
   static bool oldstate=FALSE;
   bool result=oldstate;
    
   if (newstate & !oldstate) {
      id = ScheduleHerevent(handle_event, -1, NULL);
   } else if (oldstate & !newstate) {
      DescheduleHerevent(&id);
   }
   oldstate = newstate;
   return result;
}

static void monitor(ident id, char *key, int code, void *arg)
{
   (void)EventMonitor(UserBool(key));
}
#endif

/* -------------------------------------------------------------------------- */
/*                                 parmrange                                  */
/* -------------------------------------------------------------------------- */
/*  Modify the range of a parameter's gauge.
 */
static void parmrange(ident id, char *key, int code, void *arg)
{
   Param current=(Param)arg;
   float min, max;
    
   min = UserReal(current->minkey);
   max = UserReal(current->maxkey);
   if (fabs(min-max)<1.0e-6) {
      reject_c(tofchar(key),tofchar("zero range"));
   } else {
      (void)GgiSetRange(current->gauge, min, max);
   } 
}

/* -------------------------------------------------------------------------- */
/*                                 selectplotter                              */
/* -------------------------------------------------------------------------- */
/*  PLOTTER= keyword handler. Sensitizes the PLOT button once and deschedules
 *  itself.
 */
void selectplotter(ident id, char *key, int code, void *arg)
{
   DescheduleKeyevent(&id);
   (void)GgiActivate((ident)arg);
}

/* -------------------------------------------------------------------------- */
/*                                 makeplot                                   */
/* -------------------------------------------------------------------------- */
/*  PLOT= keyword handler. Reads the current plot device and writes
 *  keyword PLOTDEV= to be catched by the application code.
 */
void makeplot(ident id, char *key, int code, void *arg)
{
   char buffer[80];
    
   if (UserBool(key)) {
      sprintf(buffer, "PLOTDEV=%s", plotters[UserInt("PLOTTER=")] );
      wkey_c(tofchar(key));
      wkey_c(tofchar(buffer));
   }
}

/* -------------------------------------------------------------------------- */
/*                                 toggle_fixed                               */
/* -------------------------------------------------------------------------- */
/*  Keyword handler. Adjusts button's appearance to reflect
 *  its state.
 */
static void toggle_fixed(ident id, char *key, int code, void *arg)
{
   ident button=(ident)arg;

   if (UserBool(key)) {
      GgiSetLabel(button,"Fixed",40);
      GgiHelpText(button,"Press to free parameter");
   } else {
      GgiSetLabel(button,"Free",40);
      GgiHelpText(button,"Press to fix parameter");
   }
}


/* -------------------------------------------------------------------------- */
/*                                 grdevices                                  */
/* -------------------------------------------------------------------------- */
/*  make list of graphics devices
 */
static char **grdevices(char kind)
{
   fint   ndevs, idev, ifunc, nbuf, lchr;
   float  rbuf;
   fchar  chr;
   int    mdevs=0;                           /* number of matching devices */
   char   capabilities[MAXDEVLEN];
   char   **devnames=(char**)calloc(MAXDEVS+1,sizeof(char**));
    
   idev = 0; ifunc = 0; nbuf  = 1; lchr  = 1;
   grexec_c(&idev, &ifunc, &rbuf, &nbuf, chr, &lchr);
   ndevs = (fint)rbuf;
   chr.l = MAXDEVLEN;
   for (idev=1; idev<=ndevs && mdevs<MAXDEVS; idev++) {
      chr.a = capabilities;
      ifunc = 4; nbuf  = 1; lchr  = 1;
      grexec_c(&idev, &ifunc, &rbuf, &nbuf, chr, &lchr);
      if (capabilities[0]==kind) {
         mdevs++;
         chr.a = (char*)calloc(MAXDEVLEN+1,1);
         ifunc = 1; nbuf  = 1; lchr  = 1;
         grexec_c(&idev, &ifunc, &rbuf, &nbuf, chr, &lchr);
         chr.a[lchr] = '\0';
         devnames[mdevs-1] = chr.a;
      }
   }
   devnames[mdevs] = NULL;
   return devnames;
}

/* -------------------------------------------------------------------------- */
/*                                 filemenu                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for FILEMENU=
 */
static void filemenu(ident id, char *key, int code, void *arg)
{
   switch (UserInt(key)) {
      case SAVE: {
         wkeyf("FILEFORM=Y");
         break;
      }
      case PARSAVE: {
         wkeyf("PARAMFORM=Y");
         break;
      }
      case PARLOAD: {
         ident browser=GgiFileBrowser(ggiIdent, "PARLOAD=");
         if (browser) {
            (void)GgiFileBrowser(ggiDelete, browser);
         } else {
            (void)GgiFileBrowser(ggiCreate, "PARLOAD=",
                                 "Parameter file to be loaded", NULL);
         }
         break;
      }
      case CHI2SAVE: {
         wkeyf("CHI2FORM=Y");
         break;
      }
      case QUIT: {
         wkeyf("QUIT=Y");
         break;
      }
      default: {
         return;
      }
   }
   wkeyf("%s-1", key);
}

/* -------------------------------------------------------------------------- */
/*                                 weightsmenu                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for WEIGHTS=
 */
static void weightsmenu(ident id, char *key, int code, void *arg)
{
   switch (UserInt(key)) {
      case 0: {
         GgiSetLabel(l_weights, "Uniform weights", 0);
         break;
      }
      case 1: {
         GgiSetLabel(l_weights, "Errors as weights", 0);
         break;
      }
      default: {
         GgiSetLabel(l_weights, " ", 0);
         break;
      }
   }
}

#if 0 /* obsolete */
/* -------------------------------------------------------------------------- */
/*                                 chi2cursor                                 */
/* -------------------------------------------------------------------------- */
/*  Cursor handler for navigation through chi-squared plot.
 */
static void chi2cursor(ident id, GgiPlotInfo info, void *arg)
{
   char   buffer[256];
   float  x=info->x, y=info->y;
   int    button=info->button, state=info->state;
   float  factor=0.0;

   if (!chi2valid) return;
                                     /* button 1: update parameters */
   if (button&ggiButn1 || state&ggiButn1) {
      sprintf(buffer, "%s=%f %s=%f", var1, x, var2, y);
      wkey_c(tofchar(buffer));
   }
                                     /* button 2 release: zoom in */
   else if (button&ggiButn2 && state&ggiButn2) {
      factor = sqrt(2.0)/4.0;
   }
                                     /* button 3 release: zoom out */
   else if (button&ggiButn3 && state&ggiButn3) {
      factor = sqrt(2.0)/2.0;
   }
   if (factor) {
      sprintf(buffer, "%s_MIN=%.2g %s_MAX=%.2g %s_MIN=%.2g %s_MAX=%.2g GO=YES",
              var1, x-factor*(var1max-var1min),
              var1, x+factor*(var1max-var1min),
              var2, y-factor*(var2max-var2min),
              var2, y+factor*(var2max-var2min) );
      wkey_c(tofchar(buffer));
   }
}
#endif

/* ========================================================================== */
/*                                 gui                                        */
/* -------------------------------------------------------------------------- */
/*  Interface routine to initialize the graphical user interface.
 */
void gui(void)
{

static char *my_resources[] = {
   "*error.foreground: red",
   "*fit.font: *courier*bold-r*12*",
   "*fiterror.font: *courier*bold-r*12*",
   "*outfield.font: *courier*bold-r*12*",
   "*outfield.background: ivory3",
   "*error.font: *helvetica*bold-r*14*",
   "*status.font: *helvetica*bold-r*14*",
   NULL
};

   int i;
   
   GgiAutoLayout(FALSE);
   GgiPostponeRealize(TRUE);
   GgiSetResources(my_resources);
   
   m_file  = GgiMenu("FILEMENU=", NULL, file_entries);
   GgiSetLabel(m_file, "FILE", 0);
   (void)ScheduleKeyevent(filemenu, "FILEMENU=", KEYCHANGE, NULL);
   b_fit   = GgiButton("FIT=", "Make fit");
   {
      char *labels[]={"Uniform", "Errors", NULL};
      m_weights = GgiMenu("WEIGHTS=", "Weights for fit", labels);
      (void)ScheduleKeyevent(weightsmenu, "WEIGHTS=", KEYCHANGE, NULL);
   }
   b_hidden = GgiSetLabel(GgiButton("HIDDEN=", "Miscellaneous options"),
                          "OPTIONS", 0);
   {
      char *labels[]={"", NULL};
      m_help = GgiHelpMenu("_HELP=", "HELP", NULL, helplabels, helpdocs);
   }
   l_gipsy = GgiLogo(NULL, 0, 0);
    
   (void)userfint(plotsize, 2, 2, "PLOTSIZE=", " ");
   p_graphs = GgiPlotField("GRAPHS", plotsize[0], plotsize[1]);
   l_temp  = GgiLabel(" ");
   {
#define chi2n_width 14
#define chi2n_height 20
static unsigned char chi2n_bits[] = {
  0x00, 0x0c, 0x00, 0x12, 0x00, 0x10, 0x00, 0x08, 0x00, 0x08, 0x00, 0x04,
  0xc3, 0x1e, 0x65, 0x00, 0x24, 0x00, 0x3c, 0x00, 0x18, 0x00, 0x1c, 0x00,
  0x14, 0x00, 0x26, 0x00, 0xa2, 0x00, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, };
   GgiSetBitmap(l_temp, chi2n_width, chi2n_height, chi2n_bits);
   }
   l_chi2    = GgiSetLabel(GgiAlignLabel(GgiLabel("outfield"), ggiRight),
                          " ", CHI2_LW);
   l_weights = GgiSetLabel(GgiAlignLabel(GgiLabel("weights"), ggiRight),
                          " ", 150);
   t_box  = GgiSetLabel(GgiTextField("BOX=",
"Limits of the RV plot. Numbers are entered as lower left to upper right.\n\
An empty field restores the default values.", 35), "Box    ", 70);
   b_refresh = GgiButton("REFRESH=", NULL);
    
   GgiSetPosition(m_file,    0, NULL,     0, NULL);
   GgiSetPosition(b_fit,   150,  p_graphs, 0, NULL);
   GgiSetPosition(m_weights, 0, b_fit,  0, NULL);
   GgiSetPosition(b_hidden, 20, m_weights, 0, NULL);
   GgiSetPosition(m_help, 485+plotsize[0]-GgiWidth(m_help) , NULL, 0, NULL);
   GgiSetPosition(p_graphs, 20, NULL, 0, m_file);
   GgiSetPosition(b_refresh, -GgiWidth(p_graphs), p_graphs, 0, p_graphs);
   GgiSetPosition(t_box    , 0, NULL, 0, b_refresh);
   GgiSetPosition(l_chi2,  -GgiWidth(l_chi2),  p_graphs, 0, p_graphs);
   GgiSetPosition(l_weights, -GgiWidth(l_chi2)-GgiWidth(l_weights)-5, l_chi2,
                             0, p_graphs);
   GgiSetPosition(l_temp, -GgiWidth(l_temp)-GgiWidth(l_chi2)-5, l_chi2,
                          0, p_graphs);
    
   t_vufun  = GgiSetLabel(GgiTextField("VUFUN=",
                        "User-supplied rotation function",
                         75), "Vu(r) =", 70);
   t_vtfun = GgiSetLabel(GgiTextField("VTFUN=",
                         "Total velocity function",
                         75), "Vt(r) =", 70);


   
   GgiSetPosition(t_vufun,  0, NULL,     10, t_box);
   GgiSetPosition(t_vtfun,  0, NULL,      0, t_vufun);
   
   partop  = m_file;
   parleft = p_graphs;
   
   topref  = t_vtfun;
   leftref = NULL;
   l_error  = GgiSetLabel(GgiLabel("error"), " ", 0);
   GgiSetPosition(l_error,   20, leftref, 0, topref);
   topref = l_error;
   for (i=0; i<STATUSLINES; i++) {
      l_status[i] = GgiSetLabel(GgiLabel("status"), " ", 0);
      GgiSetPosition(l_status[i], 20, leftref, 0, topref);
      topref = l_status[i];
   }
   bottom = topref;

   (void)Xvplot("XVPLOT="); /* plotfields must be created before grdevices() */
   for (i=0; fixedlabels[i]; i++) menulabels[i] = fixedlabels[i];
   menulabels[i] = NULL;
   (void)Chi2plot("CHI2PLOT=", menulabels);
   {
      fchar prestest;
      char  prestest_c[1];
      prestest.a = prestest_c; prestest.l = 1;
      plotters = grdevices('H');
      m_plotters = GgiMenu("PLOTTER=", "Select hardcopy plot device", plotters);
      b_doplot   = GgiButton("PLOT=", "Send plot to plotter");
      b_inputs   = GgiButton("INPUTS=", "Input specification window");
      b_rotmod   = GgiButton("ROTMOD=", "Engage ROTMOD to calculate inputs");
      b_xvplot   = GgiButton("XVPLOT=", NULL);
      b_chi2plot = GgiButton("CHI2PLOT=", NULL);
      b_colors   = GgiButton("COLORS=", NULL);
      GgiSetPosition(m_plotters, 20, m_file,     0, NULL);
      GgiSetPosition(b_doplot,    0, m_plotters, 0, NULL);
      GgiSetPosition(b_inputs,   20, b_doplot,   0, NULL);
      GgiSetPosition(b_rotmod,    0, b_inputs,   0, NULL);
      GgiSetPosition(b_xvplot,    0, b_rotmod,   0, NULL);
      GgiSetPosition(b_chi2plot,  0, b_xvplot,   0, NULL);
      GgiSetPosition(b_colors,   20, b_chi2plot, 0, NULL);
      if (usertext_c(prestest, &fint2, tofchar("PLOTTER="), tofchar(" "))==0)
         GgiDeactivate(b_doplot);
      (void)ScheduleKeyevent(selectplotter, "PLOTTER=", KEYCHANGE, b_doplot);
      (void)ScheduleKeyevent(makeplot, "PLOT=", KEYCHANGE, NULL);
   }
   
   { /* temporarily create "dark parameter element" (for layout) */
      char *names[]={"DUMMY", NULL};
      float vals[]={1.0};
      float mins[]={0.5};
      float maxs[]={1.5};
      funcpar(1, names, vals, mins, maxs);
   }
   GgiRealize();
   funcpar(0, NULL, NULL, NULL, NULL);
   status_c(tofchar("Fit components to rotation curve"));
#if 1 /* TEST PHASE - remove later */
   ScheduleKeyevent(monitor, "MONITOR=", KEYCHANGE, NULL);
   (void)TriggerKey("MONITOR=");
#endif

   GgiSetPosition(l_gipsy, -GgiWidth(l_gipsy),  m_help,
                           -GgiHeight(l_gipsy), bottom);
   (void)Inputs("INPUTS=");
   (void)Inpmod("ROTMOD=");
   (void)Hidden("HIDDEN=");
   (void)Fileform("FILEFORM=");
   (void)Chi2form("CHI2FORM=");
   (void)Paramform("PARAMFORM=");
   (void)ColorMenus("COLORS=");
}

/* -------------------------------------------------------------------------- */
/*                                 stdfun                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for user function menu.
 *  Transfers chosen function to text field.
 */
static void stdfun(ident id, char *key, int code, void *arg)
{
   wkeyf("%s%s",
      strcmp(key,"VUMENU=")?"VTFUN=":"VUFUN=", ((char**)arg)[UserInt(key)]);
#if defined(TESTBED)
   {
      char *names[]={"A", "BULGE", "C", "EPSILON", "OMEGA", NULL};
      float vals[]={1, 2, 3, 2, 3};
      float mins[]={0.5, 1.5, 2.5, 1.5, 2.5};
      float maxs[]={1.5, 2.5, 3.5, 2.5, 3.5};
      funcpar(4, names, vals, mins, maxs);
   }
#endif
}

/* ========================================================================== */
/*                                 vumenu                                     */
/* -------------------------------------------------------------------------- */
/*  Set up a menu with predefined dark matter functions.
 */
void vumenu( char** names, char** expr)
{
   static ident menu=NULL;
    
   if (menu) return; /* call only once */
   (void)GgiUseShell(NULL);
   menu = GgiMenu("VUMENU=", "Select predefined function", names);
   GgiSetLabel(menu, "Function Menu", 0);
   GgiSetPosition(menu, 0, t_vufun, -GgiHeight(menu), t_vufun);
   GgiSetPosition(GgiCanvas(" ", 1, 1), 0, menu, 0, menu);
   ScheduleKeyevent(stdfun, "VUMENU=", KEYCHANGE, expr);
}

/* ========================================================================== */
/*                                 vtmenu                                     */
/* -------------------------------------------------------------------------- */
/*  Set up a menu with predefined dark matter functions.
 */
void vtmenu( char** names, char** expr)
{
   static ident menu=NULL;
    
   if (menu) return; /* call only once */
   (void)GgiUseShell(NULL);
   menu = GgiMenu("VTMENU=", "Select predefined function", names);
   GgiSetLabel(menu, "Function Menu", 0);
   GgiSetPosition(menu, 0, t_vtfun, -GgiHeight(menu), t_vtfun);
   GgiSetPosition(GgiCanvas(" ", 1, 1), 0, menu, 0, menu);
   ScheduleKeyevent(stdfun, "VTMENU=", KEYCHANGE, expr);
}

/* ========================================================================== */
/*                                 gui_status                                 */
/* -------------------------------------------------------------------------- */
/*  Interface routine to display a status message.
 */
void gui_status(char *message, int lineno)
{
   char buffer[512];
   
   sprintf(buffer,(lineno%STATUSLINES)?"             %s":"Status: %s",message);
   GgiSetLabel(l_status[lineno%STATUSLINES], buffer, 0);
}

/* ========================================================================== */
/*                                 gui_error                                  */
/* -------------------------------------------------------------------------- */
/*  Interface routine to display an error message.
 */
void gui_error(char *message)
{  
   char buffer[1024];
 
   if (*message) {
      sprintf(buffer,"Error: %s",message);
      GgiSetLabel(l_error, buffer, 0);
   } else {
      GgiSetLabel(l_error, " ", 0);
   }
}  

static void chi2_timer(ident id, void *arg)
{
   static ident timer=NULL;
   static char previous[20]="";
   static bool   changed=FALSE;
   char   *current=(char*)arg;
   
   if (id) {
      if (changed) {
         GgiSetLabel(l_chi2, current, CHI2_LW);
         changed = FALSE;
      } else {
         Deschedule(&timer);
      }
   } else {
      if (timer) {
         bool different=strcmp(previous, current);
         changed = changed || different;
         if (different) strcpy(previous, current);
      } else {
         while (*current==' ') current++;
         GgiSetLabel(l_chi2, current, CHI2_LW);
         timer = ScheduleTimer(chi2_timer, 200, previous);
      }
   }
}

/* ========================================================================== */
/*                                 gui_chi2                                   */
/* -------------------------------------------------------------------------- */
/*  Interface routine to display the chi-squared value.
 */
void gui_chi2(char *value)
{
   chi2_timer(NULL, value);
}

/* ========================================================================== */
/*                                 funcpar                                    */
/* -------------------------------------------------------------------------- */
/*  Create interface elements for dark matter function parameters.
 */
void funcpar(int nnames, 
             char **names, float *values, float *minima, float *maxima)
{
   int   i,j;
   Param current;
   char buffer[4*(KEYLEN+40)];
   ident top=partop;
   int   d=15;
    
   while (parlist) {
      current = parlist;
      parlist = current->next;
      DescheduleKeyevent(&(current->min_h));
      DescheduleKeyevent(&(current->max_h));
      DescheduleKeyevent(&(current->fix_h));
      DescheduleKeyevent(&(current->fix_text_h));
      GgiDelete(&(current->valfield));
      GgiDelete(&(current->fixbutton));
      GgiDelete(&(current->minfield));
      GgiDelete(&(current->maxfield));
      GgiDelete(&(current->gauge));
      Delete(current);
   }
   
   for (i=0; fixedlabels[i]; i++) menulabels[i] = fixedlabels[i];
   menulabels[i] = NULL;
   
   if (!names) SetChi2Labels();
   
   for (j=0; j<nnames; j++) menulabels[i+j] = names[j];
   menulabels[i+j] = NULL;
   SetChi2Labels();

   for (i=0; i<nnames; i++) {
      current = New(_Param);
      current->next = parlist;
      parlist = current;
      sprintf(current->key,"%s=", names[i]);
      sprintf(current->fixkey,"%s_FIX=", names[i]);
      sprintf(current->minkey,"%s_MIN=", names[i]);
      sprintf(current->maxkey,"%s_MAX=", names[i]);

      RealDefault(current->key,    NULL, &values[i]);
      RealDefault(current->minkey, NULL, &minima[i]);
      RealDefault(current->maxkey, NULL, &maxima[i]);

      sprintf(buffer, "%s%f %s%g %s%g %s%s", current->key,    values[i],
                                             current->minkey, minima[i],
                                             current->maxkey, maxima[i],
                                             current->fixkey, "NO");
      wkey_c(tofchar(buffer));

      current->valfield  = GgiTextField(current->key, "Parameter value", 10);
      GgiSetLabel(current->valfield, names[i], 70);
      
      current->fixbutton = GgiButton(current->fixkey, NULL);
      
      current->fix_text_h = ScheduleKeyevent(toggle_fixed, current->fixkey,
                            KEYCHANGE, current->fixbutton);
      toggle_fixed(NULL, current->fixkey, KEYCHANGE, current->fixbutton);
      
      current->minfield  = GgiTextField(current->minkey,
                                        "parameter minimum", 5);
      GgiSetLabel(current->minfield, " ", 1);
      
      current->gauge = GgiGauge(current->key, "Parameter value", 150,
                       UserReal(current->minkey), UserReal(current->maxkey));
      GgiSetLabel(current->gauge, " ", 1);
       
      current->maxfield  = GgiTextField(current->maxkey,
                                        "parameter maximum", 5);
      GgiSetLabel(current->maxfield, " ", 1);
       
      GgiSetPosition(current->valfield,  0, parleft,            d, top);
      GgiSetPosition(current->fixbutton, 0, current->valfield,  d, top);
      GgiSetPosition(current->minfield,  0, current->fixbutton, d, top);
      GgiSetPosition(current->gauge,     0, current->minfield,  d, top);
      GgiSetPosition(current->maxfield,  0, current->gauge,     d, top);
      d = 1;
      top = current->valfield;
       
      current->min_h =
         ScheduleKeyevent(parmrange, current->minkey, KEYCHANGE, current);
      current->max_h =
         ScheduleKeyevent(parmrange, current->maxkey, KEYCHANGE, current);
   }
}
   
#if defined(TESTBED)  /* ++++++++++++++++++++++++++++++++++++++++++++++++++ */
#include "init.h"
#include "finis.h"
#include "cmain.h"

#define RED    2
#define GREEN  3
#define BLUE   4
#define YELLOW 7

static float float0=0.0, float1=1.0;
static fint colors[]={RED, GREEN, YELLOW};
static float values[]={1.2, 1.0, 0.8};
static char* keys[]={"BULGE=", "DISK=", "GAS="};
static char* mins[]={"BULGE_MIN=", "DISK_MIN=", "GAS_MIN="};
static char* maxs[]={"BULGE_MAX=", "DISK_MAX=", "GAS_MAX="};

static void quit(ident id, char *key, int code, void *arg)
{
   static int doit=0;
   if (doit) {
      finis_c();
   } else {
      ggiverify(
"You didn't save your data.\n\
Do you want to quit anyway?", key, &doit);
   }
}

static void adjust(ident id, char *key, int code, void *arg)
{
   fint index=(fint)arg;
   float value=UserReal(key);
   bool  curmode;
    
   curmode = GgiPlotXor(TRUE);
   pgsci_c(&colors[index]);
   pgmove_c(&float0, &float0);
   pgdraw_c(&float1, &values[index]);
   pgmove_c(&float0, &float0);
   pgdraw_c(&float1, &value);
   values[index] = value;
   if (xvup()) {
      char buffer[80];
      fint zero=0, one=1, min2=-2;
      float fzero=0.0, fone=1.0, ffive=5.0;
      pgend_c();
      pgbeg_c(&zero, tofchar("XVPLOT"), &one, &one);
      sprintf(buffer, "Value= %g", value);
      pgsch_c(&ffive);
      pgtext_c(&fzero, &fzero, tofchar(buffer));
      pgbeg_c(&zero, tofchar("GRAPHS//APPEND"), &one, &one);
   }
   (void)GgiPlotXor(curmode);
}

static void cursor(ident id, GgiPlotInfo info, void *arg)
{
   float dif=1.0e6, cdif;
   int   i;
   float x=info->x, y=info->y;
   int   button=info->button, state=info->state;
   static int index;
   char buffer[40];
    
                                     /* push button: select graph */
   if ((button&ggiButn1) && !(state&ggiButn1)) {
      for (i=0; i<3; i++) {
         cdif = fabs((double)(x*values[i]-y));
         if (cdif<dif) {
            dif = cdif;
            index = i;
         }
      }
   }
                                     /* update amplitude */
   sprintf(buffer, "%s%f", keys[index], y/x);
   wkey_c(tofchar(buffer));
   sprintf(buffer, "%f", y/x);
   gui_chi2(buffer);
                                     /* release button: adjust gauge's range */
   if ((button&ggiButn1) && (state&ggiButn1)) {
      sprintf(buffer, "%s%-4.2f %s%-4.2f",
                      mins[index], y/x-0.05, maxs[index], y/x+0.05);
      wkey_c(tofchar(buffer));
   }
}

static void setmessage(ident id, void *arg)
{
   static int mesno=0;
   static float chi2=1.23456;
   char message[80];
   
   sprintf(message,"Status message %d (%o Oct, %X Hex)", mesno, mesno, mesno);
   gui_status(message,mesno);
   sprintf(message,"%f", chi2); chi2 += 0.01234;
/*   gui_chi2(message); */

   mesno++;
}
   
static void seterror(ident id, void *arg)
{
   static int mesno=1;
   char message[80];
   
   sprintf(message,"Error message %d (%o Oct, %X Hex)", mesno, mesno, mesno);
   mesno++;
   if (mesno%2) gui_error(message); else gui_error("");
}

static void plotnow(ident id, char *key, int code, void *arg)
{
   fint fint0=0;
   
   pgend_c();
   pgbeg_c(&fint0, tofchar("GRAPHS//APPEND"), &fint1, &fint1);
}

MAIN_PROGRAM_ENTRY
{
   fint fint0=0;
   int i;
   
/*   for (;;) ; */
   init_c();
   gui();
   (void)ScheduleKeyevent(quit, "QUIT=", KEYCHANGE, NULL);
   (void)ScheduleKeyevent(adjust, "BULGE=", KEYCHANGE, (void*)0);
   (void)ScheduleKeyevent(adjust, "DISK=",  KEYCHANGE, (void*)1);
   (void)ScheduleKeyevent(adjust, "GAS=",   KEYCHANGE, (void*)2);
   (void)ScheduleKeyevent(plotnow,"PLOTDEV=",   KEYCHANGE, NULL);
   (void)ScheduleGgiPlotCursor(cursor, GgiPlotField("GRAPHS",0,0), NULL);
   pgbox_c(tofchar("ABCINTS"), &float0, &fint0, tofchar("ABCINTSV"), &float0,
           &fint0);
   pgbeg_c(&fint0, tofchar("GRAPHS"), &fint1, &fint1);
   pgbox_c(tofchar("ABCINTS"), &float0, &fint0, tofchar("ABCINTSV"), &float0,
           &fint0);
   for (i=0; i<3; i++) {
      pgsci_c(&colors[i]);
      pgmove_c(&float0, &float0);
      pgdraw_c(&float1, &values[i]);
   }
   wkey_c(tofchar("BULGE=1.2 GAS=0.8"));
   if (1) {
      char *names[]={"A", "BULGE", "C", "EPSILON", "OMEGA", NULL};
      float vals[]={1, 2, 3, 2, 3};
      float mins[]={0.5, 1.5, 2.5, 1.5, 2.5};
      float maxs[]={1.5, 2.5, 3.5, 2.5, 3.5};
      funcpar(4, names, vals, mins, maxs);
   }
   if (1) {
      char *names[]={"Linear", "Exponential", "Logarithmic", NULL};
      static char *expr[] ={"A*r+B A=0.5 A_MIN=-1 A_MAX=1 B=0 B_MIN=0 B_MAX=10",
                            "A*EXP(B*r)", "A*LN(r+B)", NULL};
      vumenu(names,expr);
      vtmenu(names,expr);
      chi2menu(names);
   }
#if 0
   pgbeg_c(&fint0, tofchar("XVPLOT"), &fint1, &fint1);
   pgbox_c(tofchar("ABCINTS"), &float0, &fint0, tofchar("ABCINTSV"), &float0,
              &fint0);
#endif
   (void)ScheduleTimer(setmessage, 4 SECONDS, NULL);
   (void)ScheduleTimer(seterror,   5 SECONDS, NULL);
/*   (void)ScheduleTimer(setchi2,   10, NULL); */
   (void)TriggerKey("TABSET=");
   MainLoop();
   return 0;
}
#endif
#<

#>            hidden.c
/* hidden.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "ROTMAS: miscellaneous options"

#include "stddef.h"
#include "stdio.h"
#include "gipsyc.h"
#include "userfio.h"
#include "wkey.h"
#include "ggi.h"
#include "hidden.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

static bool  initialized=FALSE;         /* initialized flag */
static ident s_hidden;                  /* hidden keywords shell     */
static ident i_box;

/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut;
   ident tol, lab, mxit;
#if 0
   ident box;
#endif

   s_hidden = GgiShell(NAME);
   (void)GgiUseShell(s_hidden);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   i_box = GgiForm(NAME, 2);
   (void)GgiUseShell(i_box);
   tol  = GgiSetLabel(GgiTextField("TOL=", "Convergence criterion", 9),
                      "Tolerance",70);
   lab  = GgiSetLabel(GgiTextField("LAB=", "Mixing parameter", 9),
                      "Lambda", 0);
   mxit = GgiSetLabel(GgiTextField("MAXITS=",
                                   "Max. number of iterations in lsq. fit", 5),
                      "Max. Its.",0);
#if 0
   box  = GgiSetLabel(GgiTextField("BOX=",
"Limits of the RV plot. Numbers are entered as lower left to upper right.\n\
An empty field restores the default values.", 35), "Box", 70);
#endif

   GgiSetPosition(tol,  0, NULL,  0, NULL);
   GgiSetPosition(lab,  0, tol,   0, NULL);
   GgiSetPosition(mxit, 0, lab,   0, NULL);
#if 0
   GgiSetPosition(box,  0, NULL, 15, tol);
#endif
   (void)GgiUseShell(s_hidden);
   GgiSetPosition(i_box,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, i_box);
   (void)GgiUseShell(NULL);
   initialized = TRUE;
}

/* -------------------------------------------------------------------------- */
/*                                 hidden                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void hidden(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_hidden, !state);
      state = !state;
      wkey_c(tofchar(key));
   }
}

/* ========================================================================== */
/*                                 Hidden                                     */
/* -------------------------------------------------------------------------- */
/*  Hidden() creates a pop-up shell for hidden keywords. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern ident Hidden(char *key)
{
   initialize(key);
   ScheduleKeyevent(hidden, key, KEYCHANGE, NULL); 
   return s_hidden;
}

#<

#>            inpmod.c
/* inpmod.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#include "stddef.h"
#include "stdlib.h" 
#include "stdio.h"
#include "string.h"
#include "math.h"
#include "gipsyc.h"
#include "taskcom.h"
#include "srvreq.h"
#include "userfio.h"
#include "nelc.h"
#include "units.h"
#include "ggi.h"
#include "inpmod.h"

#define NAME "rotmod"
#define UNILEN 20

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

#define CONCAT(a,b) strcat(strcpy(keybuf,a),b)
#define KEY(k) CONCAT(prefix,k)
#define FAILED GgiSetLabel(current->message, "-- cannot run --", 110); return;

typedef enum {DISK,BULGE} paneltype;

typedef struct {
   paneltype type;                /* DISK or BULGE */
   bool      user;                /* user-supplied data */
   char      *prefix;             /* keyword and filename prefix */
   char      runit[UNILEN+1];     /* radius units */
   char      dunit[UNILEN+1];     /* density units */

   ident radii_id;                /* Ggi element identifiers */
   ident mass_id;
      ident zlaw_id;
         ident z0_id;
      ident accuracy_id;
      ident extra_id;
      ident user_id;
         ident data_form;
         ident radius_id;
         ident runit_id;
         ident density_id;
         ident dunit_id;
            ident distance_id;
         ident param_form;
         ident dens0_id;
         ident h_id;
         ident rcut_id;
         ident delta_id;
   ident ok_id;

   char *radii_key;               /* User input keywords */
   char *mass_key;
      char *zlaw_key;
         char *z0_key;
      char *accuracy_key;
      char *extra_key;
      char *user_key;
         char *radius_key;
         char *runit_key;
         char *density_key;
         char *dunit_key;
            char *distance_key;
         char *dens0_key;
         char *h_key;
         char *rcut_key;
         char *delta_key;
   char *ok_key;
   char *param_key;

   int   zlaw_index;             /* Current z-law menu entry */
   bool  z0_req;                 /* z0 required? */
   bool  z0_ok;                  /* z0 valid? */
   bool  distance_req;           /* distance required? */
   bool  distance_ok;            /* distance valid? */
   bool  runit_ok;               /* radius unit valid? */
   bool  runit_angle;            /* radius in angle? */
   bool  dunit_ok;               /* density unit valid? */
   bool  dunit_mag;              /* densities in magnitudes? */
   bool  dens0_ok;               /* central density valid? */
   bool  h_ok;                   /* scale length valid? */ 
   bool  rcut_ok;                /* cutoff radius valid? */
   bool  delta_ok;               /* softening parameter valid? */
   ident param_id;               /* parameter button */
   ident message;                /* ROTMOD status message */
   int   expect;                 /* expect user/param events */

} _panel, *panel;

int getpid(void);

static char *laws[]={"NONE","SECH-SQUARED","EXPONENTIAL","SIMPLE-SECH",NULL};
static char *lawf[]={"NONE",
                     "D(Z) = sech(Z/Z0)**2/Z0",
                     "D(Z) = exp(-Z/Z0)/Z0",
                     "D(Z) = 2*sech(Z/Z0)/Z0/PI",
                     NULL};

static bool  initialized=FALSE;         /* initialized flag */
static ident s_inputs;                  /* inputs shell     */


/* -------------------------------------------------------------------------- */
/*                                 StrDup                                     */
/* -------------------------------------------------------------------------- */
/*  String duplication function.
 */
static char *StrDup(char *text)
{  
   char *result=NULL;
   
   if (text) {
      result = NNew(strlen(text)+1,char);
      strcpy(result,text);
   }
   return result;
}

/* -------------------------------------------------------------------------- */
/*                                 keypresent                                 */
/* -------------------------------------------------------------------------- */
/*  Check whether keyword has been defined.
 */
static int keypresent(char *key)
{
   char  cbuf[1];
   fchar fbuf;
    
   fbuf.a = cbuf; fbuf.l = 1;
   return userftext(fbuf, 2, key, " ");
}

/* -------------------------------------------------------------------------- */
/*                                 substkey                                   */
/* -------------------------------------------------------------------------- */
/*  easy subst_c front-end.
 */
static void substkey(char *key1, char *key2)
{
   char  cbuf[SUBLEN];
   fchar fbuf;
   fint  irc;
    
   sprintf(cbuf, "%s%s", key1, key2);
   fbuf.a = cbuf; fbuf.l = strlen(cbuf);
   subst_c(fbuf, &irc);
   if (irc<0 ) errorf(4, "Substitution error %d", irc);
}

/* -------------------------------------------------------------------------- */
/*                                 inputs                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void inputs(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;
                 
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_inputs, !state);
      state = !state;
      wkeyf(key);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_user                                */
/* -------------------------------------------------------------------------- */
/*  handler for USER= keyword derivatives
 */
static void handle_user(ident id, char *key, int code, void *arg)
{
   panel current=(panel)arg;
    
   if (current->expect) {
      current->expect--;
   } else {
      current->user = TRUE;
      wkeyf("%sYES %sNO", key, current->param_key);
      current->expect +=2;
      GgiActivate(current->data_form);
      GgiDeactivate(current->param_form);
   }      
}

/* -------------------------------------------------------------------------- */
/*                                 handle_param                               */
/* -------------------------------------------------------------------------- */
/*  handler for PARAM= keyword derivatives
 */
static void handle_param(ident id, char *key, int code, void *arg)
{
   panel current=(panel)arg;
    
   if (current->expect) {
      current->expect--;
   } else {
      current->user = FALSE;
      wkeyf("%sYES %sNO", key, current->user_key);
      current->expect +=2;
      GgiActivate(current->param_form);
      GgiDeactivate(current->data_form);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_zlaw                                */
/* -------------------------------------------------------------------------- */
/*   handler for Z-law keywords
 */
static void handle_zlaw(ident id, char *key, int code, void *arg)
{
   fint index=0;
   panel current=(panel)arg;

   if (userfint(&index, 1, 2, key, " ")==1) {
      current->zlaw_index = index;
      if (index) {
         current->z0_req = TRUE;
         GgiActivate(current->z0_id);
      } else {
         current->z0_req = FALSE;
         GgiDeactivate(current->z0_id);
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_z0                                  */
/* -------------------------------------------------------------------------- */
/*  handler for Z0= keyword derivatives
 */
static void handle_z0(ident id, char *key, int code, void *arg)
{
   float value=0.0;
   panel current=(panel)arg;
    
   (void)userfreal(&value, 1, 2, key, " ");
   current->z0_ok = value>0.0;
   if (!current->z0_ok) rejectf(key, "Illegal value");
}
   
/* -------------------------------------------------------------------------- */
/*                                 handle_distance                            */
/* -------------------------------------------------------------------------- */
/*  handler for DISTANCE= keyword derivatives
 */
static void handle_distance(ident id, char *key, int code, void *arg)
{
   float value=0.0;
   panel current=(panel)arg;

   (void)userfreal(&value, 1, 2, key, " ");
   current->distance_ok = value>0.0;
   if (!current->distance_ok) rejectf(key, "Wrong distance");
}
   
/* -------------------------------------------------------------------------- */
/*                                 handle_dens0                               */
/* -------------------------------------------------------------------------- */
/*  handler for DENS0= keyword derivatives
 */
static void handle_dens0(ident id, char *key, int code, void *arg)
{
   float value=0.0;
   panel current=(panel)arg;

   (void)userfreal(&value, 1, 2, key, " ");
   if (!keystatus()) {
      current->dens0_ok = value>0.0;
      if (!current->dens0_ok) rejectf(key, "Wrong central surface density");
   } else {
      current->dens0_ok = FALSE;
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_h                                   */
/* -------------------------------------------------------------------------- */
/*  handler for H= keyword derivatives
 */
static void handle_h(ident id, char *key, int code, void *arg)
{
   float value=0.0;
   panel current=(panel)arg;

   (void)userfreal(&value, 1, 2, key, " ");
   if (!keystatus()) {
      current->h_ok = value>0.0;
      if (!current->h_ok) rejectf(key, "Wrong scale length");
   } else {
      current->h_ok = FALSE;
   }
}
   
/* -------------------------------------------------------------------------- */
/*                                 handle_rcut                                */
/* -------------------------------------------------------------------------- */
/*  handler for RCUT= keyword derivatives
 */
static void handle_rcut(ident id, char *key, int code, void *arg)
{
   float value=0.0;
   panel current=(panel)arg;
   fint  n;


   n = userfreal(&value, 1, 2, key, " ");
   if (!keystatus()) {
      current->rcut_ok = (value>0.0 || n==0);
      if (!current->rcut_ok) rejectf(key, "Wrong cutoff radius");
   } else {
      current->rcut_ok = FALSE;
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_delta                               */
/* -------------------------------------------------------------------------- */
/*  handler for DELTA= keyword derivatives
 */
static void handle_delta(ident id, char *key, int code, void *arg)
{
   float value=0.0;
   panel current=(panel)arg;

   (void)userfreal(&value, 1, 2, key, " ");
   if (!keystatus()) {
      current->delta_ok = value>=0.0;
      if (!current->delta_ok) rejectf(key, "Wrong softening parameter");
   } else {
      current->delta_ok = FALSE;
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_runit                               */
/* -------------------------------------------------------------------------- */
/*  handler for radius units keywords
 */
static void handle_runit(ident id, char *key, int code, void *arg)
{
   fchar units;
   fint  nc;
   panel current=(panel)arg;
   char runit[UNILEN+1];

   units.a = runit;
   units.l = UNILEN;
   (void)userfcharu(units, 1, 2, key, " ");
   nc = nelc_c(units);
   runit[nc] = '\0';
   strcpy(current->runit, runit);
   units.l = nc;
   switch (units_c(units)) {
      case 1: {
         current->distance_req  = TRUE;
         current->runit_angle   = TRUE;
         GgiActivate(current->distance_id);
         current->runit_ok = TRUE;
         break;
      }
      case 2: {
         if (!current->dunit_mag) {
            current->distance_req  = FALSE;
            GgiDeactivate(current->distance_id);
         }
         current->runit_ok = TRUE;
         current->runit_angle = FALSE;
         break;
      }
      default: {
         rejectf(key, "Wrong units");
         current->runit_ok = FALSE;
      }
   }
   
}

/* -------------------------------------------------------------------------- */
/*                                 handle_dunit                               */
/* -------------------------------------------------------------------------- */
/*   handler for density units keywords
 */
static void handle_dunit(ident id, char *key, int code, void *arg)
{
   fchar units;
   fint  nc;
   char  *p;
   panel current=(panel)arg;
   char dunit[UNILEN+1];

   units.a = dunit;
   units.l = UNILEN;
   (void)userfcharu(units, 1, 2, key, " ");
   nc = nelc_c(units);
   dunit[nc] = '\0';
   strcpy(current->dunit, dunit);
   units.l = nc;
   if (strcmp( &units.a[nc-3], "**2" )) {
      rejectf(key, "Wrong units");
      current->dunit_ok = FALSE;
      return;
   }
   dunit[nc-3] = '\0';
   p = strchr( units.a, '/' );
   if (!p) {
      rejectf(key, "Wrong units");
      current->dunit_ok = FALSE;
      return;
   }
   *p = '\0';
   current->dunit_mag = !strcmp( units.a, "MAG" );
   if (current->dunit_mag) {
      GgiActivate(current->distance_id);
      current->distance_req  = TRUE;
   } else if (!current->runit_angle) {
      GgiDeactivate(current->distance_id);
   }
   current->dunit_ok = TRUE;
}

/* -------------------------------------------------------------------------- */
/*                                 handle_ok                                  */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for OK=
 */
static void handle_ok(ident id, char *key, int code, void *arg)
{
   panel current=(panel)arg;
   bool state=toflog(FALSE);
   char  *radkey;
   fint  irc;

   (void)userflog(&state, 1, 2, key, " ");
   if (tobool(state)) {
      GgiSetLabel(current->message, "(running)", 110);
      {
         double radii[100];
         fint   nr;
         int    i;
         
         if (keypresent(current->radii_key)) {
            radkey = current->radii_key;
         } else {
            if (!keypresent("RADII=")) {
               wkeyf("%s %s", current->radii_key, key);
               FAILED
            }
            radkey = "RADII=";
         }
         nr = userfdble(radii, 100, 2, radkey, " ");
         if (!nr) {
            wkeyf(key);
            FAILED
         }
         for (i=0; i<nr; i++) {
            if (radii[i]<0.0) {
               wkeyf(key);
               rejectf(radkey, "Wrong radii (<0.0): element %d", i+1);
               FAILED
            }
         }
      }
      if (current->type==DISK) {
                                                             /* DISK branch */
         wkeyf("ZLAW=%s", laws[current->zlaw_index]);
         wkeyf("MOD_TYPE=DISK"); 
         if (current->z0_req && !current->z0_ok) {
            wkeyf("%s %s",current->z0_key, key);
            FAILED
         }
         if (current->user) {
            if (!current->runit_ok) {
               wkeyf("%s %s",current->runit_key, key);
               FAILED
            }
            if (current->distance_req && !current->distance_ok) {
               wkeyf("%s %s", current->distance_key, key);
               FAILED
            }
            {
                double radii[200], densities[200];
                fint   nr,         nd;
                double radius,     density;
                int    i;
                FILE   *raddens;
                char   filename[40];
                
                nr = userfdble(radii, 200, 2, current->radius_key, " ");
                if (!nr) {
                   wkeyf(key);
                   rejectf(current->radius_key, "Missing or invalid input");
                   FAILED
                }
                nd = userfdble(densities, 200, 2, current->density_key, " ");
                if (!nd) {
                   wkeyf(key);
                   rejectf(current->density_key, "Missing or invalid input");
                   FAILED
                }
                if (nr != nd) {
                   wkeyf(key);
                   rejectf(current->density_key, "Number different from Radii");
                   FAILED
                }
                for (i=0; i<nd; i++) {
                   density = densities[i];
                   radius  = radii[i];
                   if (current->dunit_mag) {
                      density = pow( 10.0, -0.4 *  density);
                   }
                   if (density<0.0) {
                      wkeyf(key);
                      rejectf(current->density_key,
                              "Bad density: element %d", i+1);
                      FAILED
                   }
                   if (radius<0.0) {
                      wkeyf(key);
                      rejectf(current->radius_key,
                              "Weird radius: element %d", i+1);
                      FAILED
                   }
                }
                sprintf(filename, "tmp_rotmas_%d.rcl", getpid());
                raddens = fopen(filename, "w");
                for (i=0; i<nd; i++) {
                   fprintf(raddens, "%g %g\n", radii[i], densities[i]);
                }
                fprintf(raddens, "\n");
                (void)fclose(raddens);
                wkeyf("PAIRS=Y RADDENS=<tmp_rotmas_%d", getpid());
                wkeyf("MOD_UNITS=%s %s", current->runit, current->dunit);
            }
         } else {
            if (!current->dens0_ok) {
               wkeyf("%s %s", current->dens0_key, key);
               FAILED
            }
            if (!current->h_ok) {
               wkeyf("%s %s", current->h_key, key);
               FAILED
            }
            if (!current->rcut_ok) {
               wkeyf(key);
               rejectf(current->rcut_key, "Invalid input");
               FAILED
            }
            if (!current->delta_ok) {
               wkeyf(key);
               rejectf(current->delta_key, "Invalid input");
               FAILED
            }
         }
      } else {
                                                           /* BULGE branch */
         double radii[200], densities[200];
         fint   nr,         nd;
         double radius,     density;
         int    i;
         FILE   *raddens;
         char   filename[40];

         wkeyf("MOD_TYPE=BULGE"); 
         nr = userfdble(radii, 200, 2, current->radius_key, " ");
         if (!nr) {
            wkeyf(key);
            rejectf(current->radius_key, "Missing or invalid input");
            FAILED
         }
         nd = userfdble(densities, 200, 2, current->density_key, " ");
         if (!nd) {
            wkeyf(key);
            rejectf(current->density_key, "Missing or invalid input");
            FAILED
         }
         if (nr != nd) {
            wkeyf(key);
            rejectf(current->density_key, "Number different from Radii");
            FAILED
         }
         for (i=0; i<nd; i++) {
            density = densities[i];
            radius  = radii[i];
            if (current->dunit_mag) {
               density = pow( 10.0, -0.4 *  density);
            }
            if (density<0.0) {
               wkeyf(key);
               rejectf(current->density_key,
                       "Bad density: element %d", i+1);
               FAILED
            }
            if (radius<0.0) {
               wkeyf(key);
               rejectf(current->radius_key,
                       "Weird radius: element %d", i+1);
               FAILED
            }
         }
         sprintf(filename, "tmp_rotmas_%d.rcl", getpid());
         raddens = fopen(filename, "w");
         for (i=0; i<nd; i++) {
            fprintf(raddens, "%g %g\n", radii[i], densities[i]);
         }
         fprintf(raddens, "\n");
         (void)fclose(raddens);
         wkeyf("PAIRS=Y RADDENS=<tmp_rotmas_%d", getpid());
         wkeyf("MOD_UNITS=%s %s", current->runit, current->dunit);
      }

      wkeyf("MOD_FILE=ROT_%s.tmp", current->prefix);

      substkey("TYPE=",    "MOD_TYPE=");
      substkey("UNITS=",   "MOD_UNITS=");
      substkey("FILE=",    "MOD_FILE=");
      substkey("RADII=",    radkey);
      substkey("USER=",     current->user_key);
      substkey("Z0=",       current->z0_key);
      substkey("MASS=",     current->mass_key);
      substkey("ACCURACY=", current->accuracy_key);
      substkey("DENS0=",    current->dens0_key);
      substkey("H=",        current->h_key);
      substkey("RCUT=",     current->rcut_key);
      substkey("DELTA=",    current->delta_key);
      substkey("DISTANCE=", current->distance_key);

      deputy_c(tofchar("ROTMOD"), &irc);
      if (irc==1) {
         GgiSetLabel(current->message, "+++ success +++", 110);
         wkeyf("%sDATA=file(ROT_%s.tmp,3,:)",
                current->prefix, current->prefix);
      } else {
         char *message;
         switch (irc) {
            case DEPFATAL: message = "fatal error";    break;
            case DEPABORT: message = "user abort";     break;
            case DEPCRASH: message = "crashed";        break;
            case DEPNODEF: message = "userinp error";  break;
            default:       message = "--- failed ---"; break;
         }
         GgiSetLabel(current->message, message, 110);
      }
      wkeyf(key);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 NewPanel                                   */
/* -------------------------------------------------------------------------- */
/*  Create GUI panel for rotmod.
 *  Arguments:
 *              type:   DISK or BULGE
 *              prefix: "B" - stellar bulge;
 *                      "D" - stellar disk;
 *                      "G" - gaseous disk.
 *              title:  title label to be displayed
 */
static ident NewPanel(paneltype type, char *prefix, char *title)
{
   panel current=New(_panel);
   ident result=GgiForm("panel", 2);
   ident prvfrm=GgiUseShell(result);
   ident title_label, sub_label;
   char  keybuf[KEYLEN];
   fint  n;
    
   title_label = GgiLabel(title);
   GgiSetPosition(title_label, 0, NULL, 0, NULL);
   current->type = type;
   current->prefix = StrDup(prefix);

   current->radii_key = StrDup(KEY("RADII="));
   current->mass_key = StrDup(KEY("_MOD_MASS="));
   current->zlaw_key = StrDup(KEY("_MOD_ZLAW="));
   current->z0_key = StrDup(KEY("_MOD_Z0="));
   current->accuracy_key = StrDup(KEY("_MOD_ACCURACY="));
   current->user_key = StrDup(KEY("_MOD_USER="));
   current->param_key = StrDup(KEY("_MOD_PARAM="));
   current->radius_key = StrDup(KEY("_MOD_RADIUS="));
   current->runit_key = StrDup(KEY("_MOD_RUNIT="));
   current->distance_key = StrDup(KEY("_MOD_DISTANCE="));
   current->density_key = StrDup(KEY("_MOD_DENSITY="));
   current->dunit_key = StrDup(KEY("_MOD_DUNIT="));
   current->dens0_key = StrDup(KEY("_MOD_DENS0="));
   current->h_key = StrDup(KEY("_MOD_H="));
   current->rcut_key = StrDup(KEY("_MOD_RCUT="));   
   current->delta_key = StrDup(KEY("_MOD_DELTA="));
   current->ok_key = StrDup(KEY("_MOD_OK="));
      
   switch (type) {
      case DISK: {
         ScheduleKeyevent(handle_z0, current->z0_key, KEYCHANGE, current);
         current->z0_id =
             GgiSetLabel(
                          GgiTextField(current->z0_key,
                                       "Scale height (kpc)", 10),
                          "Z0", 20);
         current->radii_id =
             GgiSetLabel(
                          GgiTextField(current->radii_key,
         "Sampling radii (kpc)\ndefault: radii from observed curve", 20),
                          "Radii", 0);
         current->mass_id =
             GgiSetLabel(
                          GgiTextField(current->mass_key,
   "Wanted mass in 10^9 solar masses\ndefault: calculated from densities", 10),
                          "Mass", 0);
         ScheduleKeyevent(handle_zlaw, current->zlaw_key, KEYCHANGE, current);
         current->zlaw_id  =
             GgiSetLabel(
                          GgiMenu(current->zlaw_key,
                                  "Density distribution in z", lawf),
                          "Z law", 0);
         current->accuracy_id =
             GgiSetLabel(
                          GgiTextField(current->accuracy_key,
                                       "Accuracy of calculation (0-10) [1]", 3),
                           "Accuracy", 0);
         ScheduleKeyevent(handle_user, current->user_key, KEYCHANGE, current);
         current->user_id =
             GgiSetLabel(
                          GgiButton(current->user_key,
                                    "User-supplied density distribution"),
                           " DATA ", 0);

         current->param_id =
             GgiSetLabel(  
                          GgiButton(current->param_key, "Parametric disk"),
                          "PARAM", 0);
         ScheduleKeyevent(handle_param, current->param_key, KEYCHANGE, current);

         current->data_form = GgiForm("data", 1);
         (void)GgiUseShell(current->data_form);
         sub_label = GgiLabel("Disk data:");
         GgiSetPosition(sub_label, 0, NULL, 0, NULL);
         current->radius_id =
             GgiSetLabel(
                          GgiTextField(current->radius_key, NULL, 20),
                          "Radii", 60);
         ScheduleKeyevent(handle_runit, current->runit_key, KEYCHANGE, current);
         current->runit_id =
             GgiSetLabel(
                          GgiTextField(current->runit_key,
                                       "Radius units", 12),
                          "units", 40);
         ScheduleKeyevent(handle_distance, current->distance_key,
                          KEYCHANGE, current);
         current->distance_id =
             GgiSetLabel(
                          GgiTextField(current->distance_key,
                                       "Distance in Mpc", 10),
                          "distance", 0);
         current->density_id =
             GgiSetLabel(
                          GgiTextField(current->density_key, NULL, 20),
                          "Densities", 60);
         ScheduleKeyevent(handle_dunit, current->dunit_key, KEYCHANGE, current);
         current->dunit_id =
             GgiSetLabel(
                          GgiTextField(current->dunit_key,
                                       "Density units", 12),
                          "units", 40);
         GgiSetPosition(current->radius_id,
                         0, NULL,                0, sub_label);
         GgiSetPosition(current->runit_id,
                         0, current->radius_id,   0, sub_label);
         GgiSetPosition(current->distance_id,
                         0, current->runit_id,   0, sub_label);
         GgiSetPosition(current->density_id,
                         0,  NULL,               0, current->radius_id);
         GgiSetPosition(current->dunit_id,
                         0, current->density_id, 0, current->radius_id);
         
         (void)GgiUseShell(result);
         current->param_form = GgiForm("param", 1);
         (void)GgiUseShell(current->param_form);
         sub_label = GgiLabel("Disk parameters:");
         GgiSetPosition(sub_label, 0, NULL, 0, NULL);
         ScheduleKeyevent(handle_dens0, current->dens0_key, KEYCHANGE, current);
         current->dens0_id =
             GgiSetLabel(
                          GgiTextField(current->dens0_key,
                                       "Central density in solar masses/pc^2",
                                       10),
                          "Dens_0", 60);
         ScheduleKeyevent(handle_h, current->h_key, KEYCHANGE, current);
         current->h_id =
             GgiSetLabel(
                          GgiTextField(current->h_key,
                                       "Scale length in kpc", 10),
                          "H", 40);
         ScheduleKeyevent(handle_rcut, current->rcut_key, KEYCHANGE, current);
         current->rcut_id =
             GgiSetLabel(
                          GgiTextField(current->rcut_key,
                                       "Cutoff radius in kpc [no cutoff]", 10),
                          "R_cutoff", 60);
         ScheduleKeyevent(handle_delta, current->delta_key, KEYCHANGE, current);
         current->delta_id =
             GgiSetLabel(
                          GgiTextField(current->delta_key,
                                       "Softening parameter in kpc [0.0]", 10),
                          "Delta", 40);
         GgiSetPosition(current->dens0_id,
                        0, NULL,              0, sub_label);
         GgiSetPosition(current->h_id,
                        0, current->dens0_id, 0, sub_label);
         GgiSetPosition(current->rcut_id,
                        0, NULL,              0, current->h_id);
         GgiSetPosition(current->delta_id,
                        0, current->rcut_id,  0, current->h_id);
         
         (void)GgiUseShell(result);
          
         ScheduleKeyevent(handle_ok, current->ok_key, KEYCHANGE, current);
         current->ok_id =
             GgiSetLabel(
                         GgiButton(current->ok_key,
                                   "Run ROTMOD with supplied parameters"),
                         "OK", 0);
         current->message =
             GgiSetLabel(
                         GgiLabel("rotmod_message"),
                         " ", 0);
         GgiSetPosition(current->zlaw_id, 0, NULL, 0, title_label);
         GgiSetPosition(current->z0_id,   0, current->zlaw_id, 0, title_label);
         GgiSetPosition(current->radii_id, 30, NULL, 0, current->zlaw_id);
         GgiSetPosition(current->mass_id, 0, current->radii_id, 0, current->zlaw_id);
         GgiSetPosition(current->accuracy_id, 0, current->mass_id, 0, current->zlaw_id);
         GgiSetPosition(current->user_id, 0, NULL, 0, current->radii_id);
         GgiSetPosition(current->param_id, 0, current->user_id, 0, current->radii_id);
         GgiSetPosition(current->data_form, 0, NULL, 0, current->user_id);
         GgiSetPosition(current->param_form, 0, NULL, 0, current->data_form);
         GgiSetPosition(current->ok_id,
                        -GgiWidth(current->ok_id), current->data_form,
                        -GgiHeight(current->ok_id), current->param_form);
         GgiSetPosition(current->message,
                         -GgiWidth(current->ok_id)-110, current->ok_id,
                         -GgiHeight(current->message),  current->ok_id);

         n = userflog(&current->user, 1, 2, current->user_key, " ");
         if (!n || current->user) wkeyf(current->user_key);
         else                     wkeyf(current->param_key);
         if (!TriggerKey(current->zlaw_key))
            wkeyf("%s0", current->zlaw_key);
         if (!TriggerKey(current->runit_key))
            wkeyf("%sKPC", current->runit_key);
         if (!TriggerKey(current->dunit_key))
            wkeyf("%sMSUN/PC**2", current->dunit_key);
         (void)TriggerKey(current->distance_key);
         if (!TriggerKey(current->rcut_key))
            wkeyf("%s", current->rcut_key);
         if (!TriggerKey(current->delta_key))
            wkeyf("%s", current->delta_key); 
         if (!TriggerKey(current->mass_key))
            wkeyf("%s", current->mass_key);
         (void)TriggerKey(current->dens0_key);
         (void)TriggerKey(current->h_key);
         current->rcut_ok = TRUE;
         (void)TriggerKey(current->rcut_key);
         current->delta_ok = TRUE;
         (void)TriggerKey(current->delta_key);
         (void)TriggerKey(current->z0_key);
      
         break;
      }
      case BULGE: {
         current->radii_id =
             GgiSetLabel(
                          GgiTextField(current->radii_key,
             "Sampling radii (kpc)\ndefault: radii from observed curve", 20),
                          "Radii", 0);
         current->mass_id =
             GgiSetLabel(
                          GgiTextField(current->mass_key,
   "Wanted mass in 10^9 solar masses\ndefault: calculated from densities", 10),
                          "Mass", 0);
                          

         current->data_form = GgiForm("data", 1);
         (void)GgiUseShell(current->data_form);
         sub_label = GgiLabel("Bulge data:");
         GgiSetPosition(sub_label, 0, NULL, 0, NULL);
         current->radius_id =
             GgiSetLabel(
                          GgiTextField(current->radius_key, NULL, 20),
                          "Radii", 60);
         ScheduleKeyevent(handle_runit, current->runit_key, KEYCHANGE, current);
         current->runit_id =
             GgiSetLabel(
                          GgiTextField(current->runit_key,
                                       "Radius units", 12),
                          "units", 40);
         ScheduleKeyevent(handle_distance, current->distance_key,
                          KEYCHANGE, current);
         current->distance_id =
             GgiSetLabel(
                          GgiTextField(current->distance_key,
                                       "Distance in Mpc", 10),
                          "distance", 0);
         current->density_id =
             GgiSetLabel(
                          GgiTextField(current->density_key, NULL, 20),
                          "Densities", 60);
         ScheduleKeyevent(handle_dunit, current->dunit_key, KEYCHANGE, current);
         current->dunit_id =
             GgiSetLabel(
                          GgiTextField(current->dunit_key,
                                       "Density units", 12),
                          "units", 40);
         GgiSetPosition(current->radius_id,
                         0, NULL,                0, sub_label);
         GgiSetPosition(current->runit_id,
                         0, current->radius_id,   0, sub_label);
         GgiSetPosition(current->distance_id,
                         0, current->runit_id,   0, sub_label);
         GgiSetPosition(current->density_id,
                         0,  NULL,               0, current->radius_id);
         GgiSetPosition(current->dunit_id,
                         0, current->density_id, 0, current->radius_id);
         
         (void)GgiUseShell(result);
         ScheduleKeyevent(handle_ok, current->ok_key, KEYCHANGE, current);
         current->ok_id =
             GgiSetLabel(
                         GgiButton(current->ok_key,
                                   "Run ROTMOD with supplied parameters"),
                         "OK", 0);
         current->message =
             GgiSetLabel(
                         GgiLabel("rotmod_message"),
                         " ", 0);
         GgiSetPosition(current->radii_id, 30, NULL, 0, title_label);
         GgiSetPosition(current->mass_id, 0, current->radii_id, 0, title_label);
         GgiSetPosition(current->data_form, 0, NULL, 0, current->radii_id);
         GgiSetPosition(current->ok_id,
                        -GgiWidth(current->ok_id), current->data_form,
                         0,                        current->data_form);
         GgiSetPosition(current->message,
                         -GgiWidth(current->ok_id)-110, current->ok_id,
                         -GgiHeight(current->message),  current->ok_id);

         if (!TriggerKey(current->runit_key))
            wkeyf("%sKPC", current->runit_key);
         if (!TriggerKey(current->dunit_key))
            wkeyf("%sMSUN/PC**2", current->dunit_key);
         if (!TriggerKey(current->mass_key))
            wkeyf("%s", current->mass_key); 
         break;
      }
   }
   
   (void)GgiUseShell(prvfrm);
   return result;
}

static void initialize(char *key)
{
   ident bulge, disk, gas;
   ident closebut;
    
   s_inputs = GgiShell(NAME);
   (void)GgiUseShell(s_inputs);
   closebut = GgiSetLabel(
                 GgiButton(key, "Close window"),
                 "CLOSE", 0);
   bulge = NewPanel(BULGE, "B", "Stellar bulge");
   disk  = NewPanel(DISK, "D", "Stellar disk");
   gas   = NewPanel(DISK, "G", "Gaseous disk");
   GgiSetPosition(bulge, 0, NULL, 0, NULL);
   GgiSetPosition(disk,  0, NULL, 0, bulge);
   GgiSetPosition(gas,   0, NULL, 0, disk);
   GgiSetPosition(closebut, 0, NULL, 0, gas);
   (void)GgiUseShell(NULL);
   initialized = TRUE;
}


/* ========================================================================== */
/*                                 Inpmod                                     */
/* -------------------------------------------------------------------------- */
/*  Inputs() creates a pop-up shell for ROTMOD. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern ident Inpmod(char *key)
{
   initialize(key);
   ScheduleKeyevent(inputs, key, KEYCHANGE, NULL);
   return s_inputs;
}
#<

#>            fileform.c
/* fileform.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "ROTMAS: save to file"

#include "stddef.h"
#include "stdio.h"
#include "string.h"
#include "gipsyc.h"
#include "userfio.h"
#include "wkey.h"
#include "ggi.h"
#include "fileform.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

static char  popkey[KEYLEN];

static bool  initialized=FALSE;         /* initialized flag */
static ident s_fileform;                /* fileform keywords shell     */
static ident i_box;
static ident b_over;                    /* file overwrite button */  

static bool expect_save=FALSE;

/* -------------------------------------------------------------------------- */
/*                                 filechanged                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for OUTFILE=
 */
static void filechanged(ident id, char *key, int code, void *arg)
{
   wkeyf("SAVE=Y");
}
   
/* -------------------------------------------------------------------------- */
/*                                 handle_save                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for SAVE=
 */
static void handle_save(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (!tobool(button) && !expect_save) wkeyf("%sY",popkey);
   expect_save = FALSE;
}
      
     
/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut;
   ident out, okbut;

   strcpy(popkey, key);
   s_fileform = GgiDialog(NAME);
   (void)GgiUseShell(s_fileform);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CANCEL", 0);
   b_over = GgiSetLabel(GgiButton("SAVE_OVER=", NULL), "OK to overwrite?", 0);
   GgiDeactivate(b_over);
   i_box = GgiForm(NAME, 2);
   (void)GgiUseShell(i_box);
   out = GgiSetLabel(GgiTextField("OUTFILE=", "Output filename", 20),
                         "Outfile", 0);
   okbut = GgiSetLabel(GgiButton("SAVE=", NULL), "OK", 0);
   GgiSetPosition(out,   0, NULL, 0, NULL);
   GgiSetPosition(okbut, 0, out,  0, NULL);
   (void)GgiUseShell(s_fileform);
   GgiSetPosition(i_box,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, i_box);
   GgiSetPosition(b_over, -GgiWidth(b_over)-2, i_box, 0, i_box);
   (void)GgiUseShell(NULL);
   initialized = TRUE;
}

/* -------------------------------------------------------------------------- */
/*                                 fileform                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void fileform(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_fileform, !state);
      state = !state;
      wkeyf(key);
      if (!state) {
         GgiDeactivate(b_over);
         expect_save = TRUE;
         wkeyf("SAVE= SAVE_OVER=");
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 overwrite                                  */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for SAVE_OVER=
 */
static void overwrite(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;
    
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      (void)userflog(&state, 1, 2, "SAVE=", " ");
      if (state) {
         (void)TriggerKey("SAVE=");
      } else {
         wkeyf(key);
      }
   }
}

/* ========================================================================== */
/*                                 ask_overwrite                              */
/* -------------------------------------------------------------------------- */
extern void  ask_overwrite(void)
{
   GgiActivate(b_over);
}

/* ========================================================================== */
/*                                 Fileform                                     */
/* -------------------------------------------------------------------------- */
/*  Fileform() creates a pop-up shell for saving. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern ident Fileform(char *key)
{
   initialize(key);
   ScheduleKeyevent(fileform, key, KEYCHANGE, NULL); 
   ScheduleKeyevent(handle_save, "SAVE=", KEYCHANGE, NULL);
   ScheduleKeyevent(overwrite, "SAVE_OVER=", KEYCHANGE, NULL);
   ScheduleKeyevent(filechanged, "OUTFILE=", KEYCHANGE, NULL);
   return s_fileform;
}
#<

#>            inputs.c
/* inputs.c -XT
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "inputs"
#define FLAB "======================= Input from text file ======================="
#define TLAB "========================= Input from table ========================="
#define GLAB "======================= Generic input format ======================="
#define KLAB "============================ Top title ============================="
#define ROWHELP "Row numbers:\n\n first : last\n first :\n : last\n   :  (=all rows)"

#include "stddef.h"
#include "stdio.h"
#include "gipsyc.h"
#include "string.h"
#include "userfio.h"
#include "wkey.h"
#include "ggi.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

static char *datanames[]={"RADII",  "ODATA", "ERRORS",
                                    "BDATA",
                                    "DDATA",
                                    "GDATA", 
                                    "XDATA", NULL};

static bool  initialized=FALSE;         /* initialized flag */
static ident s_inputs;                  /* inputs shell     */
static ident f_box;

/* -------------------------------------------------------------------------- */
/*                                 pop_compose                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for popping up "inset composer"
 */
static void pop_compose(ident id, char *key, int code, void *arg)
{
   char *setkey=(char*)arg;
   char namekey[KEYLEN];
   bool button=toflog(FALSE);
   ident composer;
         
   (void)userflog(&button, 1, 2, key, " ");
   if (button) {
      wkeyf(key);
      sprintf(namekey, "NAME_%s", setkey);
      composer = GgiInset(ggiIdent, namekey);
      if (composer) {
         (void)GgiInset(ggiDelete, composer);
      } else {
         composer = GgiInset(ggiCreate, namekey, setkey, NULL,
                             "Set or subset containing table");
      }  
   }
}


/* -------------------------------------------------------------------------- */
/*                                 pop_browse                                 */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for popping up file browser.
 */
static void pop_browse(ident id, char *key, int code, void *arg)
{
   char *filekey=(char*)arg;
   bool button=toflog(FALSE);
   ident browser;
    
   (void)userflog(&button, 1, 2, key, " ");
   if (button) {
      wkeyf(key);
      browser = GgiFileBrowser(ggiIdent, filekey);
      if (browser) (void)GgiFileBrowser(ggiDelete, browser);
      else GgiFileBrowser(ggiCreate, filekey, "Select text file", NULL);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 filedata                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for FILE=, ROWS= and xxx_COL=.
 *  Convert file, row and column information to 'standard' keywords.
 */
static void filedata(ident id, char *key, int code, void *arg)
{
   static bool initialized=FALSE;
   static char file[64]="";
   static char rows[64]="";
   fchar  data;
   int    nc;
   char   **name;
   char   *dataname=(char*)arg;
   char keybuf[KEYLEN+1];
   char col[16+1];
   char buffer[128];
    
   data.l = 63;
   if (!initialized) {
      data.a = file;
      nc = userftext(data, 2, "FILE=", " ");
      data.a[nc] = '\0';
      data.a = rows;
      nc = userftext(data, 2, "ROWS=", " ");
      data.a[nc] = '\0';
      initialized = TRUE;
   }
   data.a = NULL;
   if (!strcmp(key,"FILE=")) {
      data.a = file;
   } else if (!strcmp(key,"ROWS=")) {
      data.a = rows;
   }
   if (data.a) {
                                          /* FILE= or ROWS= keyword seen */
      nc = userftext(data, 2, key, " ");
      data.a[nc] = '\0';
      if (*file && *rows) {
         data.l=16;
         data.a = col;
         for (name=datanames; *name; name++) {
            sprintf(keybuf,"%s_COL=", *name);
            nc = userftext(data, 2, keybuf, " ");
            if (nc) {
               col[nc] = '\0';
               sprintf(buffer, "%s=file(%s,%s,%s)", *name, file, col, rows);
               wkey_c(tofchar(buffer));
            }
         }
      }
   } else {
                                          /* xxx_COL= keyword seen */
      if (*file && *rows) {
         data.l=16;
         data.a = col;
         nc = userftext(data, 2, key, " ");
         if (nc) {
            col[nc] = '\0';
            sprintf(buffer, "%s=file(%s,%s,%s)", dataname, file, col, rows);
         } else {
            sprintf(buffer, "%s=", dataname);
         }
         wkey_c(tofchar(buffer));
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 schedulefile                               */
/* -------------------------------------------------------------------------- */
/*  Schedule all keywords appropriate for filedata().
 */
static void schedulefile(void)
{
   char **name;
   char keybuf[KEYLEN+1];
   
   (void)ScheduleKeyevent(filedata, "FILE=", KEYCHANGE, NULL);
   (void)ScheduleKeyevent(filedata, "ROWS=", KEYCHANGE, NULL);
   for (name=datanames; *name; name++) {
      sprintf(keybuf, "%s_COL=", *name);
      (void)ScheduleKeyevent(filedata, keybuf, KEYCHANGE, *name);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 tabledata                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for TABSET=, TABLE=, TROWS= and Txxx=.
 *  Convert set, table, row and column information to 'standard' keywords.
 */
static void tabledata(ident id, char *key, int code, void *arg)
{
   static bool initialized=FALSE;
   static char set[64]="";
   static char table[64]="";
   static char rows[64]="";
   fchar  data;
   int    nc;
   char   **name;
   char   *dataname=(char*)arg;
   char keybuf[KEYLEN+1];
   char col[16+1];
   char buffer[128];
    
   data.l = 63;
   if (!initialized) {
      data.a = set;
      nc = userftext(data, 2, "TABSET=", " ");
      data.a[nc] = '\0';
      data.a = table;
      nc = userftext(data, 2, "TABLE=", " ");
      data.a[nc] = '\0';
      data.a = rows;
      nc = userftext(data, 2, "TROWS=", " ");
      data.a[nc] = '\0';
      initialized = TRUE;
   }
   data.a = NULL;
   if (!strcmp(key,"TABSET=")) {
      data.a = set;
   } else if (!strcmp(key,"TABLE=")) {
      data.a = table;
   } else if (!strcmp(key,"TROWS=")) {
      data.a = rows;
   }
   if (data.a) {
                                   /* TABSET=, TABLE= or TROWS= keyword seen */
      nc = userftext(data, 2, key, " ");
      data.a[nc] = '\0';
      if (*set && *table && *rows) {
         data.l=16;
         data.a = col;
         for (name=datanames; *name; name++) {
            sprintf(keybuf,"T%s=", *name);
            nc = userftext(data, 2, keybuf, " ");
            if (nc) {
               col[nc] = '\0';
               sprintf(buffer, "%s=table(%s,%s,%s,%s)",
                                *name, set, table, col, rows);
               wkey_c(tofchar(buffer));
            }
         }
      }
   } else {
                                          /* Txxx= keyword seen */
      if (*set && *table && *rows) {
         data.l=16;
         data.a = col;
         nc = userftext(data, 2, key, " ");
         if (nc) {
            col[nc] = '\0';
            sprintf(buffer, "%s=table(%s,%s,%s,%s)",
                            dataname, set, table, col, rows);
         } else {
            sprintf(buffer, "%s=", dataname);
         }
         wkey_c(tofchar(buffer));
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 scheduletable                              */
/* -------------------------------------------------------------------------- */
/*  Schedule all keywords appropriate for tabledata().
 */
static void scheduletable(void)
{
   char **name;
   char keybuf[KEYLEN+1];
   
   (void)ScheduleKeyevent(tabledata, "TABSET=",   KEYCHANGE, NULL);
   (void)ScheduleKeyevent(tabledata, "TABLE=",    KEYCHANGE, NULL);
   (void)ScheduleKeyevent(tabledata, "TROWS=",    KEYCHANGE, NULL);
   for (name=datanames; *name; name++) {
      sprintf(keybuf, "T%s=", *name);
      (void)ScheduleKeyevent(tabledata, keybuf, KEYCHANGE, *name);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident topref=NULL;
   ident closebut, rotmod;
   ident filehead;
   ident file, browse, filerows, file_radii, file_errors;
   ident file_obs, file_bulge, file_disk, file_gas, file_other;
   
   ident tablehead;
   ident set, table, compose, tablerows, table_radii, table_errors;
   ident table_obs, table_bulge, table_disk, table_gas, table_other;
   
   ident gipsyhead;
   ident obslab, radii, obsdata, errors;
   ident blglab, bradii, bdata;
   ident dsklab, dradii, ddata;
   ident gaslab, gradii, gdata;
   ident xlab,   xradii, xdata;
   
   ident titlehead;
   ident toptitle;
   
   s_inputs = GgiShell(NAME);
   (void)GgiUseShell(s_inputs);
   closebut = GgiSetLabel(
                 GgiButton(key, "Close window"),
                 "CLOSE", 0);
   rotmod = GgiButton("ROTMOD=", "Engage ROTMOD to calculate inputs");
   f_box = GgiForm(NAME, 2);
   (void)GgiUseShell(f_box);
   filehead = GgiLabel(FLAB);
   file     = GgiSetLabel(
                 GgiTextField("FILE=", "text file name", 30),
                 "File", 65);
   browse = GgiButton("BROWSE=", NULL);
   (void)ScheduleKeyevent(pop_browse, "BROWSE=", KEYCHANGE, "FILE=");
   filerows = GgiSetLabel(
                 GgiTextField("ROWS=", ROWHELP, 8),
                 "Rows", 0);
   file_radii = GgiSetLabel(
                   GgiTextField("RADII_COL=", "Radii column #", 2), 
                   "Radii", 65);
   file_obs   = GgiSetLabel(
                   GgiTextField("ODATA_COL=", "Observed R-V column #", 2),
                   "Observed", 65);
   file_errors = GgiSetLabel(
                    GgiTextField("ERRORS_COL=", "Observed errors column #", 2),
                    "Errors", 65);
   file_bulge = GgiSetLabel(
                   GgiTextField("BDATA_COL=", "Bulge data column #", 2),
                   "Bulge", 65);
   file_disk  = GgiSetLabel(
                   GgiTextField("DDATA_COL=", "Disk data column #", 2), 
                   "Disk", 65);
   file_gas   = GgiSetLabel(
                   GgiTextField("GDATA_COL=", "Gas data column #", 2),
                   "Gas",  65);
   file_other   = GgiSetLabel(
                   GgiTextField("XDATA_COL=", "Other data column #", 2),
                   "Other",  65);
                   
   GgiSetPosition(filehead, 0, NULL, 0, topref);

   GgiSetPosition(file,        0, NULL,       0, filehead);
   GgiSetPosition(browse,      0, file,       0, filehead);
   GgiSetPosition(filerows,    0, browse,     0, filehead);

   GgiSetPosition(file_radii,  0, NULL,       0, filerows);
   GgiSetPosition(file_obs,    0, file_radii, 0, filerows); 
   GgiSetPosition(file_errors, 0, file_obs,   0, filerows);

   GgiSetPosition(file_bulge,  0, NULL,       0, file_radii);
   GgiSetPosition(file_disk,   0, file_bulge, 0, file_radii);
   GgiSetPosition(file_gas,    0, file_disk,  0, file_radii);
   GgiSetPosition(file_other,  0, file_gas,  0, file_radii);   
   topref = file_bulge;

   tablehead = GgiLabel(TLAB);
   set     = GgiSetLabel(
                 GgiTextField("TABSET=", "Set or subset containing table", 30),
                 "Set", 65);
   compose = GgiButton("COMPOSE=", NULL);
   (void)ScheduleKeyevent(pop_compose, "COMPOSE=", KEYCHANGE, "TABSET=");
   table   = GgiSetLabel(
                 GgiTextField("TABLE=", "Table name", 30),
                 "Table", 65);
   tablerows = GgiSetLabel(
                 GgiTextField("TROWS=", ROWHELP, 8),
                 "Rows", 0);
   table_radii = GgiSetLabel(
                    GgiTextField("TRADII=", "Radii column name", 8), 
                    "Radii", 65);
   table_obs   = GgiSetLabel(
                   GgiTextField("TODATA=", "Observed R-V column name", 8),
                   "Observed", 65);
   table_errors = GgiSetLabel(
                    GgiTextField("TERRORS=", "Observed errors column name", 8),
                    "Errors", 65);
   table_bulge = GgiSetLabel(
                   GgiTextField("TBDATA=", "Bulge data column name", 8),
                   "Bulge", 65);
   table_disk  = GgiSetLabel(
                   GgiTextField("TDDATA=", "Disk data column name", 8), 
                   "Disk", 65);
   table_gas   = GgiSetLabel(
                   GgiTextField("TGDATA=", "Gas data column name", 8),
                   "Gas",  65);
   table_other  = GgiSetLabel(
                   GgiTextField("TXDATA=", "Other data column name", 8),
                   "Other",  65);
   GgiSetPosition(tablehead, 0, NULL, 15, topref);

   GgiSetPosition(set,          0, NULL,        0, tablehead);
   GgiSetPosition(compose,      0, set,         0, tablehead);
   GgiSetPosition(table,        0, NULL,        0, set);
   GgiSetPosition(tablerows,    0, table,       0, set);

   GgiSetPosition(table_radii,  0, NULL,        0, tablerows);
   GgiSetPosition(table_obs,    0, table_radii, 0, tablerows); 
   GgiSetPosition(table_errors, 0, table_obs,   0, tablerows);

   GgiSetPosition(table_bulge,  0, NULL,        0, table_radii);
   GgiSetPosition(table_disk,   0, table_bulge, 0, table_radii);
   GgiSetPosition(table_gas,    0, table_disk,  0, table_radii);
   GgiSetPosition(table_other,  0, table_gas,   0, table_radii);
   topref = table_bulge;

   gipsyhead  = GgiLabel(GLAB);
   
   obslab     = GgiSetLabel(GgiAlignLabel(GgiLabel(" "), ggiRight), "Observed",  65);
   radii      = GgiSetLabel(GgiTextField("RADII=",  NULL, 20), "radii",  40);
   obsdata    = GgiSetLabel(GgiTextField("ODATA=",  NULL, 20), "data",   40);
   errors     = GgiSetLabel(GgiTextField("ERRORS=", NULL, 20), "errors", 40);

   blglab     = GgiSetLabel(GgiAlignLabel(GgiLabel(" "), ggiRight), "Bulge",  65);
   bradii     = GgiSetLabel(GgiTextField("BRADII=", NULL, 20), "radii",  40);
   bdata      = GgiSetLabel(GgiTextField("BDATA=",  NULL, 20), "data",   40);

   dsklab     = GgiSetLabel(GgiAlignLabel(GgiLabel(" "), ggiRight), "Disk",  65);
   dradii     = GgiSetLabel(GgiTextField("DRADII=", NULL, 20), "radii",  40);
   ddata      = GgiSetLabel(GgiTextField("DDATA=",  NULL, 20), "data",   40);

   gaslab     = GgiSetLabel(GgiAlignLabel(GgiLabel(" "), ggiRight), "Gas",  65);
   gradii     = GgiSetLabel(GgiTextField("GRADII=", NULL, 20), "radii",  40);
   gdata      = GgiSetLabel(GgiTextField("GDATA=",  NULL, 20), "data",   40);

   xlab       = GgiSetLabel(GgiAlignLabel(GgiLabel(" "), ggiRight), "Other",  65);
   xradii     = GgiSetLabel(GgiTextField("XRADII=", NULL, 20), "radii",  40);
   xdata      = GgiSetLabel(GgiTextField("XDATA=",  NULL, 20), "data",   40);
 
   GgiSetPosition(gipsyhead, 0, NULL, 15, topref);

   GgiSetPosition(obslab, 0, NULL,   0, gipsyhead);
   GgiSetPosition(radii,  0, obslab, 0, gipsyhead );
   GgiSetPosition(obsdata,0, radii,  0, gipsyhead);

   GgiSetPosition(errors, 0, radii,  0, obslab);

   GgiSetPosition(blglab, 0, NULL,   0, errors);
   GgiSetPosition(bradii, 0, blglab, 0, errors);
   GgiSetPosition(bdata,  0, bradii, 0, errors);
   
   GgiSetPosition(dsklab, 0, NULL,   0, blglab);
   GgiSetPosition(dradii, 0, dsklab, 0, blglab);
   GgiSetPosition(ddata,  0, dradii, 0, blglab);
   
   GgiSetPosition(gaslab, 0, NULL,   0, dsklab);
   GgiSetPosition(gradii, 0, gaslab, 0, dsklab);
   GgiSetPosition(gdata,  0, gradii, 0, dsklab);

   GgiSetPosition(xlab,   0, NULL,   0, gaslab);
   GgiSetPosition(xradii, 0, xlab, 0, gaslab);
   GgiSetPosition(xdata,  0, xradii, 0, gaslab);
   
   /*topref = gaslab;*/
   topref = xlab;
    
   titlehead = GgiLabel(KLAB);
   
   toptitle =  GgiSetLabel(GgiTextField("TOPTITLE=",  NULL, 60), " ",   1); 
   
   GgiSetPosition(titlehead, 0, NULL, 15, topref);
   GgiSetPosition(toptitle,  0, NULL,  0, titlehead);
   
   GgiUseShell(s_inputs);
   GgiSetPosition(closebut, 0, NULL, 0, f_box);
   GgiSetPosition(rotmod, -GgiWidth(rotmod)-2, f_box, 0, f_box);

   (void)GgiUseShell(NULL);
   schedulefile();
   scheduletable();
   initialized = TRUE;
}

/* -------------------------------------------------------------------------- */
/*                                 inputs                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void inputs(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_inputs, !state);
      state = !state;
      if (!state) {
         ident popup;
         popup = GgiInset(ggiIdent, "NAME_TABSET=");
         if (popup) (void)GgiInset(ggiDelete, popup);
         popup = GgiFileBrowser(ggiIdent, "FILE=");
         if (popup) (void)GgiFileBrowser(ggiDelete, popup);
      } 
      wkey_c(tofchar(key));
   }
}

/* ========================================================================== */
/*                                 Inputs                                     */
/* -------------------------------------------------------------------------- */
/*  Inputs() creates a pop-up shell for data input. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up op down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern ident Inputs(char *key)
{
   initialize(key);
   ScheduleKeyevent(inputs, key, KEYCHANGE, NULL);
   return s_inputs;
}
#<

#>            xvplot.c
/* xvplot.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "xvplot"

#include "stddef.h"
#include "stdio.h"
#include "gipsyc.h"
#include "userfio.h"
#include "wkey.h"
#include "ggi.h"
#include "xvplot.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

static bool state=FALSE;                /* up (TRUE) or down (FALSE) */

static bool  initialized=FALSE;         /* initialized flag */
static ident s_xvplot;                  /* xvplot shell     */
static ident i_box;                     /* inputs box       */


/* -------------------------------------------------------------------------- */
/*                                 pop_compose                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for popping up "inset composer"
 */
static void pop_compose(ident id, char *key, int code, void *arg)
{
   char *setkey=(char*)arg;
   char namekey[KEYLEN];
   bool button=toflog(FALSE);
   ident composer;

   (void)userflog(&button, 1, 2, key, " ");
   if (button) {
      wkeyf(key);
      sprintf(namekey, "NM_%s", setkey);
      composer = GgiInset(ggiIdent, namekey);
      if (composer) {
         (void)GgiInset(ggiDelete, composer);
      } else {
         composer = GgiInset(ggiCreate, namekey, setkey, "XV_BOX=",
                             "Two-dimensional (sub)set,\nrepresenting an"
                             " XV diagram.");
         (void)GgiInset(ggiNdims, composer, 2);
      }
   }
}
      
/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut;
    
   ident t_inset, b_comp, t_box, t_levels, t_inc, t_pa, t_sysv, t_slpa, t_dist;
   ident p_xvplot;
   ident b_go;
   
   s_xvplot = GgiShell(NAME);
   (void)GgiUseShell(s_xvplot);
   closebut = GgiSetLabel(
                 GgiButton(key, "Close window"),
                 "CLOSE", 0);
                 
   i_box = GgiForm(NAME, 1);
   (void)GgiUseShell(i_box);
   t_inset  = GgiTextField("XV_INSET=",    NULL, 40);
   b_comp   = GgiSetLabel(GgiButton("XV_COMP=", NULL), "COMPOSE", 0);
   (void)ScheduleKeyevent(pop_compose, "XV_COMP=", KEYCHANGE, "XV_INSET=");
   t_box    = GgiTextField("XV_BOX=",      NULL, 20);
   t_levels = GgiTextField("XV_LEVELS=",   NULL, 20);
   t_inc    = GgiTextField("XV_INC=",      NULL, 20);
   t_pa     = GgiTextField("XV_PA=",       NULL, 20);
   t_sysv   = GgiTextField("XV_SYSV=",     NULL, 20);
   t_slpa   = GgiTextField("XV_SLICEPA=",  NULL, 20);
   t_dist   = GgiTextField("XV_DISTANCE=", NULL, 20);
   b_go     = GgiSetLabel(GgiButton("XV_GO=", "Make plot"), "GO", 0);
   GgiSetLabel(t_inset,  "Inset",        70);
   GgiSetLabel(t_box,    "Box",          70);
   GgiSetLabel(t_levels, "Levels",       70);
   GgiSetLabel(t_inc,    "Inclinations", 70);
   GgiSetLabel(t_pa,     "Pos. angles",  70);
   GgiSetLabel(t_sysv,   "Syst. vel.",   70);
   GgiSetLabel(t_slpa,   "Slice Pa",     70);
   GgiSetLabel(t_dist,   "D (Mpc)",      70);
GgiHelpText(t_inset,
"Two-dimensional GIPSY (sub)set, representing an\n\
XV diagram. For input examples see HELP menu.");
GgiHelpText(t_box,
"Limits in X and V for contour plot.\n\
For input examples see HELP menu.");
GgiHelpText(t_levels, "Contour levels");
GgiHelpText(t_inc,
"'Tilted ring' inclinations in degrees. One per radius.\n\
If fewer are given, the last inclination is repeated.\n\
For input examples see HELP menu.");
GgiHelpText(t_pa,
"'Tilted ring' position angles in degrees. One per radius.\n\
If fewer are given, the last position angle is repeated.\n\
For input examples see HELP menu.");
GgiHelpText(t_sysv, "The systemic velocity in km/s");
GgiHelpText(t_slpa,
"Angle in degrees under which the slice was taken\n\
in the original data cube");
GgiHelpText(t_dist, "Distance in Mpc");
   GgiSetPosition(t_inset,  0, NULL,   0, NULL);
   GgiSetPosition(b_comp,   0, t_inset,0, NULL);
   GgiSetPosition(t_box,    0, NULL,   0, t_inset);
   GgiSetPosition(t_levels, 0, t_box,  0, t_inset);
   GgiSetPosition(t_inc,    0, NULL,   0, t_levels);
   GgiSetPosition(t_pa,     0, t_inc,  0, t_levels);
   GgiSetPosition(t_sysv,   0, NULL,   0, t_pa);
   GgiSetPosition(t_slpa,   0, t_sysv, 0, t_pa);
   GgiSetPosition(t_dist,   0, NULL,   0, t_sysv);
   GgiSetPosition(b_go, -GgiWidth(b_go)-3, t_slpa, 0, t_slpa);
   (void)GgiUseShell(s_xvplot);
   p_xvplot = GgiPlotField("XVPLOT", 455, 344);
   GgiSetPosition(p_xvplot, 0, NULL, 0, NULL);
   GgiSetPosition(i_box,    0, NULL, 0, p_xvplot);
   GgiSetPosition(closebut, 0, NULL, 0, i_box);
   (void)GgiUseShell(NULL);
   initialized = TRUE;
}

/* -------------------------------------------------------------------------- */
/*                                 xvplot                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void xvplot(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_xvplot, !state);
      state = !state;
      if (!state) {
         ident compose=GgiInset(ggiIdent, "NM_XV_INSET=");
         if (compose) GgiInset(ggiDelete, compose);
      }
      wkey_c(tofchar(key));
   }
}

/* ========================================================================== */
/*                                 Xvplot                                     */
/* -------------------------------------------------------------------------- */
/*  Xvplot() creates a pop-up shell for XV-plot display. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up op down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern ident Xvplot(char *key)
{
   initialize(key);
   ScheduleKeyevent(xvplot, key, KEYCHANGE, NULL);
   return s_xvplot;
}

/* ========================================================================== */
/*                                 xvup                                       */
/* -------------------------------------------------------------------------- */
/*  xvup() returns xvplot's up or down state.
 */
extern bool xvup(void)
{
   return state;
}
#<

#>            subsvar.c
#include "stdio.h"
#include "string.h"

#if defined(__cplusplus)
   extern "C" {
#endif
#if (defined(__cplusplus) || defined(__STDC__))
     extern int svyyreject();
     extern int svyywrap();
     extern int svyylook();
     extern int svyyback(int *, int);
     extern int svyyinput();
     extern void svyyoutput(int);
     extern void svyyunput(int);
     extern int svyylex();
     extern int svyyless(int);
#ifdef LEXDEBUG
     extern void allprint();
     extern void sprint();
#endif
#if defined(__cplusplus)
   }
#endif
#endif	/* __cplusplus or __STDC__ */
# define U(x) x
# define NLSTATE svyyprevious=YYNEWLINE
# define BEGIN svyybgin = svyysvec + 1 +
# define INITIAL 0
# define YYLERR svyysvec
# define YYSTATE (svyyestate-svyysvec-1)
# define YYOPTIM 1
# define YYLMAX 200
# define output(c) putc(c,svyyout)
# define input() (((svyytchar=svyysptr>svyysbuf?U(*--svyysptr):getc(svyyin))==10?(svyylineno++,svyytchar):svyytchar)==EOF?0:svyytchar)
# define unput(c) {svyytchar= (c);if(svyytchar=='\n')svyylineno--;*svyysptr++=svyytchar;}
# define svyymore() (svyymorfg=1)
# define ECHO fprintf(svyyout, "%s",svyytext)
# define REJECT { nstr = svyyreject(); goto svyyfussy;}
int svyyleng;
int svyylenguc;
extern unsigned char svyytextarr[];
# ifdef YYCHAR_ARRAY
extern char svyytext[];
# else
extern unsigned char svyytext[];
# endif
int svyyposix_point=0;
int svyynls16=0;
int svyynls_wchar=0;
char *svyylocale = "C C C C C C";
int svyymorfg;
extern unsigned char *svyysptr, svyysbuf[];
int svyytchar;
FILE *svyyin = {NULL}, *svyyout = {NULL};
extern int svyylineno;
struct svyysvf { 
	int svyystoff;
	struct svyysvf *svyyother;
	int *svyystops;};
struct svyysvf *svyyestate;
extern struct svyysvf svyysvec[], *svyybgin;
/* subsvar.l
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands

Variable substitution routine.
Author: J.P. Terlouw
*/

#include "stdio.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

#undef   input                    /* defined internally */
#undef   unput                    /* defined internally */
#undef   output                   /* defined internally */
#define  output(x)                /* no-op */

static void identifier();
static void other();
static char input(void);
static void unput(char);

static char  *bufptr, *varptr, *replptr, *resptr;
static char  ustack[YYLMAX];
static int   stkptr=0;
static int   errorcode=0;

# define YYNEWLINE 10
svyylex(){
   int nstr; extern int svyyprevious;
   while((nstr = svyylook()) >= 0)
svyyfussy: switch(nstr){
case 0:
   if(svyywrap()) return(0); break;
case 1:
    {other(); }
break;
case 2:
           {other(); }
break;
case 3:
   {identifier(); }
break;
case 4:
                   {other(); }
break;
case 5:
                   {other(); }
break;
case 6:
                   {other(); }
break;
case 7:
                   {other(); }
break;
case 8:
                   {}
break;
case 9:
                    {BEGIN 0;}
break;
case 10:
                      {errorcode++;}
break;
case -1:
break;
default:
   fprintf(svyyout,"bad switch svyylook %d",nstr);
} return(0); }
/* end of svyylex */

#ifndef __cplusplus
static void __svyy__unused() { main(); }
#endif


extern int subsvar(char *text, char *var, char *repl, char *result)
{
   errorcode = 0;
   bufptr = text;
   varptr = var;
   replptr= repl;
   resptr = result;
   result[0] = '\0';
   stkptr = 0;
   svyylex();
   return errorcode;
}

static char input(void)
{
   static int atend=0;
    
   if (atend) {
      atend = 0;
      return '\0';
   }
   if (stkptr) {
      return ustack[--stkptr];
   }
   if (errorcode || !*(bufptr)) {
      atend++;
      return '\01';
   } 
   return *(bufptr++);
}
 
static void unput(char c)
{
   if (stkptr<YYLMAX) {
      ustack[stkptr++] = c;
   }
}

static void identifier()
{
   if (strcmp((char*)svyytext, varptr)) {
      strcat(resptr, (char*)svyytext);
   } else {
      strcat(resptr,"(");
      strcat(resptr, replptr);
      strcat(resptr, ")");
   }
}

static void other()
{
   strcat(resptr, (char*)svyytext);
}

extern int svyywrap()
{
   return 1;
}
      
int svyyvstop[] = {
0,

8,
0,

8,
0,

9,
10,
0,

10,
0,

8,
10,
0,

5,
10,
0,

6,
10,
0,

4,
10,
0,

4,
10,
0,

10,
0,

1,
10,
0,

3,
10,
0,

8,
0,

7,
0,

2,
0,

1,
0,

1,
0,

3,
0,

1,
0,

2,
0,
0};
# define YYTYPE unsigned char
struct svyywork { YYTYPE verify, advance; } svyycrank[] = {
{0,0},	{0,0},	{1,3},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,0},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,5},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,6},	{1,7},	{1,8},	
{1,9},	{1,9},	{0,0},	{1,10},	
{1,9},	{1,11},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,12},	{5,13},	
{0,0},	{1,12},	{0,0},	{0,0},	
{0,0},	{0,0},	{8,14},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{10,15},	{10,15},	{10,15},	{10,15},	
{10,15},	{10,15},	{10,15},	{10,15},	
{10,15},	{10,15},	{0,0},	{0,0},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{18,21},	{0,0},	
{18,21},	{0,0},	{0,0},	{18,22},	
{18,22},	{18,22},	{18,22},	{18,22},	
{18,22},	{18,22},	{18,22},	{18,22},	
{18,22},	{21,22},	{21,22},	{21,22},	
{21,22},	{21,22},	{21,22},	{21,22},	
{21,22},	{21,22},	{21,22},	{0,0},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{1,4},	{1,4},	{1,4},	
{1,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,0},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{0,0},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{0,0},	
{0,0},	{0,0},	{0,0},	{2,9},	
{0,0},	{2,10},	{2,9},	{15,20},	
{15,20},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{11,16},	{0,0},	{11,17},	{11,17},	
{11,17},	{11,17},	{11,17},	{11,17},	
{11,17},	{11,17},	{11,17},	{11,17},	
{0,0},	{0,0},	{0,0},	{15,20},	
{15,20},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{11,18},	{11,18},	
{0,0},	{0,0},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{20,23},	{0,0},	{20,23},	{0,0},	
{0,0},	{20,24},	{20,24},	{20,24},	
{20,24},	{20,24},	{20,24},	{20,24},	
{20,24},	{20,24},	{20,24},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{11,18},	{11,18},	
{0,0},	{0,0},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{2,4},	
{2,4},	{2,4},	{2,4},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{12,19},	{12,19},	
{12,19},	{12,19},	{16,16},	{16,16},	
{16,16},	{16,16},	{16,16},	{16,16},	
{16,16},	{16,16},	{16,16},	{16,16},	
{23,24},	{23,24},	{23,24},	{23,24},	
{23,24},	{23,24},	{23,24},	{23,24},	
{23,24},	{23,24},	{16,18},	{16,18},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{0,0},	{0,0},	
{0,0},	{0,0},	{16,18},	{16,18},	
{0,0}};
struct svyysvf svyysvec[] = {
{0,	0,	0},
{-1,	0,		svyyvstop+1},
{-255,	svyysvec+1,	svyyvstop+3},
{0,	0,		svyyvstop+5},
{0,	0,		svyyvstop+8},
{35,	0,		svyyvstop+10},
{0,	0,		svyyvstop+13},
{0,	0,		svyyvstop+16},
{32,	0,		svyyvstop+19},
{0,	0,		svyyvstop+22},
{32,	0,		svyyvstop+25},
{274,	0,		svyyvstop+27},
{463,	0,		svyyvstop+30},
{0,	svyysvec+5,	svyyvstop+33},
{0,	0,		svyyvstop+35},
{235,	svyysvec+10,	svyyvstop+37},
{538,	0,		svyyvstop+39},
{0,	svyysvec+11,	svyyvstop+41},
{55,	0,		0},	
{0,	svyysvec+12,	svyyvstop+43},
{309,	0,		0},	
{65,	0,		0},	
{0,	svyysvec+21,	svyyvstop+45},
{548,	0,		0},	
{0,	svyysvec+23,	svyyvstop+47},
{0,	0,	0}};
struct svyywork *svyytop = svyycrank+639;
struct svyysvf *svyybgin = svyysvec+1;
unsigned char svyymatch[] = {
00  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,012 ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
040 ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
'(' ,')' ,'*' ,'+' ,'*' ,'+' ,01  ,'*' ,
'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,
'0' ,'0' ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,'A' ,'A' ,'A' ,'D' ,'D' ,'A' ,'A' ,
'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
'A' ,'A' ,'A' ,01  ,01  ,01  ,01  ,01  ,
01  ,'A' ,'A' ,'A' ,'D' ,'D' ,'A' ,'A' ,
'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,'A' ,
'A' ,'A' ,'A' ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
0};
unsigned char svyyextra[] = {
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0};
/* @(#) A.10.32.03 HP C LANGUAGE TOOL (NCFORM) 960517 $      */
int svyylineno =1;
# define YYU(x) x
# define NLSTATE svyyprevious=YYNEWLINE
 
#ifdef YYNLS16_WCHAR
unsigned char svyytextuc[YYLMAX * sizeof(wchar_t)];
# ifdef YY_PCT_POINT /* for %pointer */
wchar_t svyytextarr[YYLMAX];
wchar_t *svyytext;
# else               /* %array */
wchar_t svyytextarr[1];
wchar_t svyytext[YYLMAX];
# endif
#else
unsigned char svyytextuc;
# ifdef YY_PCT_POINT /* for %pointer */
unsigned char svyytextarr[YYLMAX];
unsigned char *svyytext;
# else               /* %array */
unsigned char svyytextarr[1];
# ifdef YYCHAR_ARRAY
char svyytext[YYLMAX];
# else
unsigned char svyytext[YYLMAX];
# endif
# endif
#endif

struct svyysvf *svyylstate [YYLMAX], **svyylsp, **svyyolsp;
unsigned char svyysbuf[YYLMAX];
unsigned char *svyysptr = svyysbuf;
int *svyyfnd;
extern struct svyysvf *svyyestate;
int svyyprevious = YYNEWLINE;
svyylook(){
	register struct svyysvf *svyystate, **lsp;
	register struct svyywork *svyyt;
	struct svyysvf *svyyz;
	int svyych, svyyfirst;
	struct svyywork *svyyr;
# ifdef LEXDEBUG
	int debug;
# endif
/*	char *svyylastch;
 * ***** nls8 ***** */
	unsigned char *svyylastch, sec, third, fourth;
	/* start off machines */
# ifdef LEXDEBUG
	debug = 0;
# endif
	svyyfirst=1;
	if (!svyymorfg)
#ifdef YYNLS16_WCHAR
		svyylastch = svyytextuc;
#else
# ifdef YYCHAR_ARRAY
		svyylastch = (unsigned char *)svyytext;
# else
		svyylastch = svyytext;
# endif
#endif
	else {
		svyymorfg=0;
#ifdef YYNLS16_WCHAR
		svyylastch = svyytextuc+svyylenguc;
#else
# ifdef YYCHAR_ARRAY
		svyylastch = (unsigned char *)svyytext+svyyleng;
# else
		svyylastch = svyytext+svyyleng;
# endif
#endif
		}
	for(;;){
		lsp = svyylstate;
		svyyestate = svyystate = svyybgin;
		if (svyyprevious==YYNEWLINE) svyystate++;
		for (;;){
# ifdef LEXDEBUG
			if(debug)fprintf(svyyout,"state %d\n",svyystate-svyysvec-1);
# endif
			svyyt = &svyycrank[svyystate->svyystoff];
			if(svyyt == svyycrank && !svyyfirst){  /* may not be any transitions */
				svyyz = svyystate->svyyother;
				if(svyyz == 0)break;
				if(svyyz->svyystoff == 0)break;
				}
			*svyylastch++ = svyych = input();
			svyyfirst=0;
		tryagain:
# ifdef LEXDEBUG
			if(debug){
				fprintf(svyyout,"char ");
				allprint(svyych);
				putchar('\n');
				}
# endif
			svyyr = svyyt;
			if ( (int)svyyt > (int)svyycrank){
				svyyt = svyyr + svyych;
				if (svyyt <= svyytop && svyyt->verify+svyysvec == svyystate){
					if(svyyt->advance+svyysvec == YYLERR)	/* error transitions */
						{unput(*--svyylastch);break;}
					*lsp++ = svyystate = svyyt->advance+svyysvec;
					goto contin;
					}
				}
# ifdef YYOPTIM
			else if((int)svyyt < (int)svyycrank) {		/* r < svyycrank */
				svyyt = svyyr = svyycrank+(svyycrank-svyyt);
# ifdef LEXDEBUG
				if(debug)fprintf(svyyout,"compressed state\n");
# endif
				svyyt = svyyt + svyych;
				if(svyyt <= svyytop && svyyt->verify+svyysvec == svyystate){
					if(svyyt->advance+svyysvec == YYLERR)	/* error transitions */
						{unput(*--svyylastch);break;}
					*lsp++ = svyystate = svyyt->advance+svyysvec;
					goto contin;
					}
				svyyt = svyyr + YYU(svyymatch[svyych]);
# ifdef LEXDEBUG
				if(debug){
					fprintf(svyyout,"try fall back character ");
					allprint(YYU(svyymatch[svyych]));
					putchar('\n');
					}
# endif
				if(svyyt <= svyytop && svyyt->verify+svyysvec == svyystate){
					if(svyyt->advance+svyysvec == YYLERR)	/* error transition */
						{unput(*--svyylastch);break;}
					*lsp++ = svyystate = svyyt->advance+svyysvec;
					goto contin;
					}
				}
			if ((svyystate = svyystate->svyyother) && (svyyt = &svyycrank[svyystate->svyystoff]) != svyycrank){
# ifdef LEXDEBUG
				if(debug)fprintf(svyyout,"fall back to state %d\n",svyystate-svyysvec-1);
# endif
				goto tryagain;
				}
# endif
			else
				{unput(*--svyylastch);break;}
		contin:
# ifdef LEXDEBUG
			if(debug){
				fprintf(svyyout,"state %d char ",svyystate-svyysvec-1);
				allprint(svyych);
				putchar('\n');
				}
# endif
			;
			}
# ifdef LEXDEBUG
		if(debug){
			fprintf(svyyout,"stopped at %d with ",*(lsp-1)-svyysvec-1);
			allprint(svyych);
			putchar('\n');
			}
# endif
		while (lsp-- > svyylstate){
			*svyylastch-- = 0;
			if (*lsp != 0 && (svyyfnd= (*lsp)->svyystops) && *svyyfnd > 0){
				svyyolsp = lsp;
				if(svyyextra[*svyyfnd]){		/* must backup */
					while(svyyback((*lsp)->svyystops,-*svyyfnd) != 1 && lsp > svyylstate){
						lsp--;
						unput(*svyylastch--);
						}
					}
				svyyprevious = YYU(*svyylastch);
				svyylsp = lsp;
#ifdef YYNLS16_WCHAR
				svyylenguc = svyylastch-svyytextuc+1;
				svyytextuc[svyylenguc] = 0;
#else
# ifdef YYCHAR_ARRAY
				svyyleng = svyylastch-(unsigned char*)svyytext+1;
# else
				svyyleng = svyylastch-svyytext+1;
# endif
				svyytext[svyyleng] = 0;
#endif
# ifdef LEXDEBUG
				if(debug){
					fprintf(svyyout,"\nmatch ");
#ifdef YYNLS16_WCHAR
					sprint(svyytextuc);
#else
					sprint(svyytext);
#endif
					fprintf(svyyout," action %d\n",*svyyfnd);
					}
# endif
				return(*svyyfnd++);
				}
			unput(*svyylastch);
			}
#ifdef YYNLS16_WCHAR
		if (svyytextuc[0] == 0  /* && feof(svyyin) */)
#else
		if (svyytext[0] == 0  /* && feof(svyyin) */)
#endif
			{
			svyysptr=svyysbuf;
			return(0);
			}
#ifdef YYNLS16_WCHAR
		svyyprevious = svyytextuc[0] = input();
#else
		svyyprevious = svyytext[0] = input();
#endif
		if (svyyprevious>0) {
			output(svyyprevious);
#ifdef YYNLS16
                        if (svyynls16) {
			int noBytes;
                        sec = input();
                        third = input();
                        fourth = input();
#ifdef YYNLS16_WCHAR
                        noBytes = MultiByte(svyytextuc[0],sec,third,fourth);
#else 
                        noBytes = MultiByte(svyytext[0],sec,third,fourth);
#endif          
     					switch(noBytes) {
     					case 2:
#ifdef YYNLS16_WCHAR
 						output(svyyprevious=svyytextuc[0]=sec);
#else
 						output(svyyprevious=svyytext[0]=sec);
#endif
                                                 unput(fourth);
                                                 unput(third);
                                                 break;
     					case 3:
#ifdef YYNLS16_WCHAR
 						output(svyyprevious=svyytextuc[0]=sec);
 						output(svyyprevious=svyytextuc[0]=third);
#else
 						output(svyyprevious=svyytext[0]=sec);
 						output(svyyprevious=svyytext[0]=third);
#endif
                                                 unput(fourth);
                                                 break; 
                                         case 4:
#ifdef YYNLS16_WCHAR
 						output(svyyprevious=svyytextuc[0]=sec);
 						output(svyyprevious=svyytextuc[0]=third);
 						output(svyyprevious=svyytextuc[0]=fourth);
#else
 						output(svyyprevious=svyytext[0]=sec);
 						output(svyyprevious=svyytext[0]=third);
 						output(svyyprevious=svyytext[0]=fourth);
#endif
                                                 break;                                                                                            
					default:
					        unput(fourth);
					        unput(third);
						unput(sec);
						break;
						}
					}
#endif
                }
#ifdef YYNLS16_WCHAR
		svyylastch=svyytextuc;
#else
# ifdef YYCHAR_ARRAY
		svyylastch=(unsigned char*)svyytext;
# else
		svyylastch=svyytext;
# endif
#endif
# ifdef LEXDEBUG
		if(debug)putchar('\n');
# endif
		}
	}

# ifdef __cplusplus
svyyback(int *p, int m)
# else
svyyback(p, m)
	int *p;
# endif
{
if (p==0) return(0);
while (*p)
	{
	if (*p++ == m)
		return(1);
	}
return(0);
}
	/* the following are only used in the lex library */
svyyinput(){
	return(input());
	
	}

#if (defined(__cplusplus) || defined(__STDC__))
void svyyoutput(int c)
#else
svyyoutput(c)
  int c;
# endif
{
	output(c);
}

#if (defined(__cplusplus) || defined(__STDC__))
void svyyunput(int c)
#else
svyyunput(c)
   int c;
#endif
{
	unput(c);
}
#<

#>            paramform.c
/* paramform.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "ROTMAS: save parameters to file"

#include "stddef.h"
#include "stdio.h"
#include "gipsyc.h"
#include "string.h"
#include "userfio.h"
#include "wkey.h"
#include "savepar.h"
#include "ggi.h"
#include "gui.h"
#include "paramform.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

static char  popkey[KEYLEN];

static bool  initialized=FALSE;         /* initialized flag */
static ident s_paramform;                /* paramform keywords shell     */
static ident i_box;
static ident b_over;                    /* file overwrite button */  

static bool expect_save=FALSE;


/* -------------------------------------------------------------------------- */
/*                                 filechanged                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for PARMFILE=
 */
static void filechanged(ident id, char *key, int code, void *arg)
{
   wkeyf("PARM_SAVE=Y");
}

/* -------------------------------------------------------------------------- */
/*                                 handle_save                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for PARM_SAVE=
 */
static void handle_save(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;
   char message[80];

   (void)userflog(&button, 1, 2, key, " ");
   if (!tobool(button) && !expect_save) {
      wkeyf("%sY",popkey);
   } else  if (!expect_save) {
      FILE  *parmfile;
      fchar f_file;
      char  c_file[EDTLEN];
      int   nc;
      
      f_file.a = c_file; f_file.l = EDTLEN-1;
      nc = userftext(f_file, 2, "PARMFILE=", " ");
      c_file[nc] = '\0';
      parmfile = fopen(c_file, "r");
      if (parmfile) {
         bool over=toflog(FALSE);

         (void)fclose(parmfile);
         (void)userflog(&over, 1, 2, "PARM_OVER=", " ");
         if (!tobool(over)) {
            GgiActivate(b_over);
            return;
         }
      }
      wkeyf(key);
      wkeyf("PARM_OVER=");
      if (savepar_c(tofchar(c_file))) {
         sprintf(message, "Failed to save parameters to file %s", c_file);
         gui_error(message);
      } else {
         sprintf(message, "Parameters saved to file %s", c_file);
         gui_status(message, 0);
      }
   }
   expect_save = FALSE;
}
      
     
/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut;
   ident out, okbut;

   strcpy(popkey, key);
   s_paramform = GgiDialog(NAME);
   (void)GgiUseShell(s_paramform);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CANCEL", 0);
   b_over = GgiSetLabel(GgiButton("PARM_OVER=", NULL), "OK to overwrite?", 0);
   GgiDeactivate(b_over);
   i_box = GgiForm(NAME, 2);
   (void)GgiUseShell(i_box);
   out = GgiSetLabel(GgiTextField("PARMFILE=",
                                  "File to save task's parameters", 20),
                     "Parameter file", 0);
   okbut = GgiSetLabel(GgiButton("PARM_SAVE=", NULL), "OK", 0);
   GgiSetPosition(out,   0, NULL, 0, NULL);
   GgiSetPosition(okbut, 0, out,  0, NULL);
   (void)GgiUseShell(s_paramform);
   GgiSetPosition(i_box,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, i_box);
   GgiSetPosition(b_over, -GgiWidth(b_over)-2, i_box, 0, i_box);
   (void)GgiUseShell(NULL);
   initialized = TRUE;
}

/* -------------------------------------------------------------------------- */
/*                                 paramform                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void paramform(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_paramform, !state);
      state = !state;
      wkeyf(key);
      if (!state) {
         GgiDeactivate(b_over);
         expect_save = TRUE;
         wkeyf("PARM_SAVE= PARM_OVER=");
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 overwrite                                  */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for PARM_OVER=
 */
static void overwrite(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;
    
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      (void)userflog(&state, 1, 2, "PARM_SAVE=", " ");
      if (state) {
         (void)TriggerKey("PARM_SAVE=");
      } else {
         wkeyf(key);
      }
   }
}

/* ========================================================================== */
/*                                 paramform                                  */
/* -------------------------------------------------------------------------- */
/*  paramform() creates a pop-up shell for saving all task parameters to a file.
 *  The argument 'key' is the GIPSY keyword (type LOGICAL) which, when set
 *  to "YES", will cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern ident Paramform(char *key)
{
   initialize(key);
   ScheduleKeyevent(paramform, key, KEYCHANGE, NULL); 
   ScheduleKeyevent(handle_save, "PARM_SAVE=", KEYCHANGE, NULL);
   ScheduleKeyevent(overwrite, "PARM_OVER=", KEYCHANGE, NULL);
   ScheduleKeyevent(filechanged, "PARMFILE=", KEYCHANGE, NULL);
   return s_paramform;
}
#<

#>            gammaq.c
/* gammaq.c
                      Copyright (c) 1998 
                  Kapteyn Institute Groningen
                     All Rights Reserved.
*/

/*
*/

/*
*/

#include    "gipsyc.h"
#include    "string.h"
#include    "math.h"
#include    "userfio.h"
#include    "setfblank.h" 

#define   ITMAX    100
#define   EPS      3.0e-7
#define   FPMIN    1.0e-30


static float  blank;



static float gammln( float xx )
/*-------------------------------------------------------------*/
/* PURPOSE: Return the value Ln(T(xx)) for xx > 0              */
/*-------------------------------------------------------------*/
{
   int       j;
   double    x, y;
   double    tmp, ser;
   double    cof[6] = {  76.18009172947146,
                        -86.50532032941677,
                         24.01409824083091,
                         -1.231739572450155,
                          0.1208650973866179e-2,
                         -0.5395239384953e-5 };
  
   y    = x = xx;
   tmp  = x + 5.5;
   tmp -= (x+0.5) * log(tmp);
   ser  = 1.000000000190015;
   for (j = 0; j < 6; j++)
   {
      ser += cof[j] /++y;      
   }
   return( -tmp+log(2.5066282746310005*ser/x) );
   
}


static void  gser( float *gamser,
                   float  a,
                   float  x, 
                   float *gln,
                   char  *errmes )
/*-------------------------------------------------------------*/
/* PURPOSE: returns the incomplete gamma function P(a,x)       */
/*          evaluated by its series representation as 'gamser' */
/*          Also returns ln(T(a)) as 'gln'.                    */
/*-------------------------------------------------------------*/
{
   int     n;
   float   sum, del, ap;
   
   
   *gln = gammln( a );
   if (x <= 0.0)
   {
      if (x < 0.0)
      {
         strcpy( errmes, "Problem in GAMMAQ: GSER: x less than 0" );
         *gamser = blank;
         return;
      }
      else
      {
         *gamser = 0.0;
         return;
      }      
   }
   else
   {
      ap = a;
      del = sum = 1.0 / a;
      for (n = 1; n <= ITMAX; n++)
      {
         ++ap;
         del *= x / ap;
         sum += del;
         if (fabs(del) < fabs(sum)*EPS)
         {
            *gamser = sum * exp(-x+a*log(x)-(*gln));
            return;
         }
      }
      strcpy( errmes, "GSER: a too large, ITMAX too small" );
      *gamser = blank;
      return;
   }
   
}                     


static void gcf( float *gammcf,
                 float  a,
                 float  x,
                 float *gln,
                 char  *errmes )
/*-------------------------------------------------------------*/
/* PURPOSE: returns the incomplete gamma function Q(a,x)       */
/*          evaluated by its series representation as gammcf'  */
/*          Also returns ln(T(a)) as 'gln'.                    */
/*-------------------------------------------------------------*/
{
   int      i;
   float    an, b, c, d, del, h;


   *gln = gammln( a );
   b = x + 1.0 - a;
   c = 1.0 / FPMIN;
   d = 1.0 / b;
   h = d;
   for (i = 1; i <= ITMAX; i++)
   {
      an = -i * (i-a);
      b += 2.0;
      d = an * d + b;
      if (fabs(d) < FPMIN)
         d = FPMIN;
      c = b + an / c;
      if (fabs(c) < FPMIN)
         c = FPMIN;
      d = 1.0 / d;
      del = d * c;
      h *= del;
      if (fabs(del-1.0) < EPS)
         break;         
   }
   if (i > ITMAX)
   {
      *gammcf = blank;
      strcpy( errmes, "GCF: a too large, ITMAX too small" );
      return;
   }
   *gammcf = exp( -x+a*log(x)-(*gln)) * h;
}



float gammaq( float   a,
              float   x,
              char    *errmes )
/*-------------------------------------------------------------*/
/* PURPOSE: Returns the incomplete gamma function Q(a,x)       */
/* The function returns a blank if something did go wrong.     */
/*-------------------------------------------------------------*/
{
   float   gamser, gammcf, gln;
   float   result;


   setfblank_c( &blank );
   if (x < 0.0 || a <= 0.0)
   {
      strcpy( errmes, "GAMMQ: Invalid arguments" );
      return( blank );
   }
   if (x < (a+1.0))
   {
      gser( &gamser, a, x, &gln, errmes );
      result = 1.0 - gamser;
   }
   else
   {
      gcf( &gammcf, a, x, &gln, errmes );
      result = gammcf;
   }
   return( result );
}




static float getgauss( float sigma )
{
   double z = (double) sigma;
   double term = 0.7071067812;
   double denom, sum, y2, result;


   if (z < 0)
      return( 0.0 );
      
   term *= z;
   sum = term;
   y2 = (z*z)/2.0;
   denom = 1.0;
   do
   {
      denom += 2.0;
      term *= 2.0 * y2/denom;
      sum += term;
   } while( term/sum > 1e-10);
   result = 1.128379167* sum * exp(-y2);
   return( (float) result );
}




float rtbis(   float nu,
               float p,
               float x1,
               float x2,
               float xacc,
               char  *errmes )
/*------------------------------------------------------------*/
/* PURPOSE: */
/*------------------------------------------------------------*/
{
   int    j;
   int    jmax = 40;
   float  dx, f, fmid, xmid, rtb;


   f=gammaq(nu,x1, errmes) - p;
   fmid=gammaq(nu,x2, errmes) - p;
   if (f*fmid >= 0.0) 
   {
      strcpy( errmes, "Root must be bracketed for bisection in RTBIS");
      return( blank );
   }
   rtb = f < 0.0 ? (dx=x2-x1,x1) : (dx=x1-x2,x2);
   for (j = 1; j <= jmax; j++) 
   {
      fmid = gammaq(nu,(xmid=rtb+(dx *= 0.5)), errmes) - p;
      if (fmid <= 0.0) 
         rtb=xmid;
      if (fabs(dx) < xacc || fmid == 0.0) 
         return rtb;
   }
   strcpy( errmes, "Too many bisections in RTBIS");
   return( blank );
}





float confidence( float  nu, 
                  float  sigma,
                  float  accu,
                  char   *errormes )
/*------------------------------------------------------------*/
/* PURPOSE: Calculate a step in chi-square to define          */
/*          confidence limits (for 'nu' parameters) with      */
/*          probability expressed in sigma's.                 */
/*                                                            */
/* 'accu' is the desired accuracy of the wanted chi-square    */
/* step.                                                      */
/* 'errormes' is a string to which the error message is       */
/* copied.                                                    */
/*                                                            */
/* A confidence region (or interval) is a region that contains*/
/* a certain percentage of the total probability distribution.*/
/* You can use constant chi-square boundaries a confidence    */
/* limits. This routine calculates the step in chi-square as  */
/* function of the number of parameters for which you want    */
/* the confidence limits and as function of the probability.  */
/* The probability is expressed in sigma (1 == 68.3%,         */
/* 2 == 95.4% 3 == 99.73% etc.  The steps in chi-square are   */
/* distributed as the chi-square distribution and this        */
/* routine solves for de step in chi-square by finding the    */
/* solution of:                                               */
/*                                                            */
/*           gammaq( nu/2, Dchi2/2 ) = 1 - p                  */ 
/*                                                            */
/* 'nu' is the number of parameters for which a confidence    */
/* limit is wanted. Dchi2 is the step in chi-square and p the */
/* wanted probability.                                        */
/* See also numerical Recipes, page 689ff                     */
/*------------------------------------------------------------*/
{
   float    prob;
   float    chi2;
   
   prob = getgauss( sigma );
   errormes[0] = '\0';   
   chi2 = rtbis( nu/2.0, 1.0-prob, 0.0001, 1000.0, accu, errormes );     
   return( chi2 * 2.0 );
}
#<

#>            ggiverify.c
/* ggiverify.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands

Author: J.P. Terlouw
*/

#define NAME "Question"

#include "stddef.h"
#include "gipsyc.h"
#include "string.h"
#include "userfio.h"
#include "ggi.h"
#include "ggiverify.h"

static ident shell=NULL;
static ident message;
static ident yes_but, no_but;

static ident yes_id, no_id;

static char rkey[KEYLEN];
static int  *flag;

/* -------------------------------------------------------------------------- */
/*                                 keyhandler                                 */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for VFY_YES= and VFY_NO=
 */
static void keyhandler(ident id, char *key, int code, void *arg)
{
   wkeyf("VFY_YES= VFY_NO=");
   if (id==yes_id) {
      wkeyf("%sYES", rkey);
      *flag = 1;
   }
   DescheduleKeyevent(&yes_id);
   DescheduleKeyevent(&no_id);
   GgiDelete(&message);
   GgiDelete(&yes_but);
   GgiDelete(&no_but);
   GgiDelete(&shell);
   shell = NULL;
}

/* ========================================================================== */
/*                                 ggiverify                                  */
/* -------------------------------------------------------------------------- */
/*  ggiverify() pops up a dialog window consisting of the question
 *  specified in the first argument and two buttons labelled "YES" and "NO".
 *  If the YES-button is pressed, the value to which the third argument points
 *  is set to 1 and wkey is called with the keyword specified in the second
 *  argument and the value "YES". Finally the dialog window is removed.
 *  If the NO-button is pressed, the dialog window is removed and no further
 *  action is taken.
 */
void ggiverify(char *question, char *key, int *arg)
{
   ident prevshell;
    
   if (shell) return;              /* only one instance allowed */
   strcpy(rkey,key);
   flag  = arg;
   shell = GgiDialog(NAME);
   prevshell = GgiUseShell(shell);
   message = GgiLabel(question);
   yes_but = GgiSetLabel(GgiButton("VFY_YES=", NULL), "YES", 0);
   no_but  = GgiSetLabel(GgiButton("VFY_NO=",  NULL), " NO ",  0);

   GgiSetPosition(message, 20, NULL, 0, NULL);
   GgiSetPosition(yes_but, 20, NULL, 20, message);
   GgiSetPosition(no_but,  40, yes_but, 20, message);
   (void)GgiUseShell(prevshell);
   yes_id = ScheduleKeyevent(keyhandler, "VFY_YES=", KEYCHANGE, NULL);
   no_id  = ScheduleKeyevent(keyhandler, "VFY_NO=",  KEYCHANGE, NULL);
   GgiShowShell(shell, TRUE);
}
#<

#>            chi2plot.c
/* chi2plot.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "chi2plot"
#define CHI2_NX 325   /* size of chi-sqared plot window */
#define CHI2_NY 325

#include "stddef.h"
#include "stdio.h"
#include "gipsyc.h"
#include "string.h"
#include "userfio.h"
#include "wkey.h"
#include "ggi.h"
#include "gui.h"
#include "chi2plot.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

static bool state=FALSE;                /* up (TRUE) or down (FALSE) */

static bool  initialized=FALSE;         /* initialized flag */
static ident s_chi2plot;                /* chi2plot shell   */
static ident i_box;                     /* inputs box       */
static ident m_x2x, m_x2y, m_mode;
static char  **menulabels;              /* menu labels      */

#define chi2_width 78
#define chi2_height 24
static unsigned char chi2_bits[] = {
  0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x23,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xe3, 0x03, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0x01, 0x30, 0x00, 0x00, 0x06,
  0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x30, 0x00, 0x00, 0x06, 0x00, 0x00,
  0x00, 0x00, 0xe8, 0x00, 0x30, 0xcf, 0xc6, 0xe6, 0xf1, 0x78, 0x36, 0x1e,
  0x70, 0x00, 0xb0, 0xd9, 0x6d, 0x37, 0x9b, 0xcd, 0x6e, 0x33, 0x30, 0x00,
  0x30, 0xd8, 0x6c, 0x76, 0x18, 0xc0, 0x66, 0x33, 0x38, 0x00, 0x30, 0xdf,
  0x6c, 0xc6, 0x19, 0xf8, 0x66, 0x3f, 0x58, 0x00, 0xb0, 0xd9, 0x6c, 0x86,
  0x1b, 0xcc, 0x66, 0x03, 0x4c, 0x00, 0xb0, 0xd9, 0x6c, 0x37, 0x9b, 0xcd,
  0x6e, 0x33, 0x46, 0x02, 0x30, 0xf7, 0xcc, 0xe6, 0xf1, 0xb8, 0x37, 0x1e,
  0xc7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x83, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  };

/* -------------------------------------------------------------------------- */
/*                                 set_chi2_var                               */
/* -------------------------------------------------------------------------- */
static void set_chi2_var(ident id, char *key, int code, void *arg)
{
   ident menu=(ident)arg;
   fint  index=0;
   char  buffer[40];
    
   (void)userfint(&index, 1, 2, key, " ");
   if (index<0) index = 0;
   sprintf(buffer, "%s%s", !strcmp(key,"VAR1=")?"x: ":"y: ",menulabels[index]);
   GgiSetLabel(menu, buffer, 0);
   sprintf(buffer, "VARNAME%s=%s", (menu==m_x2x)?"1":"2", menulabels[index]);
   wkey_c(tofchar(buffer));
}

#if 0
static char var1[KEYLEN+1], var2[KEYLEN+1];      /* chi^2 plot variable names */
static float var1min, var1max, var2min, var2max; /* plot limits */ 
static bool chi2valid=FALSE;                     /* valid plot? */
/* -------------------------------------------------------------------------- */
/*                                 chi2go                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for GO=.
 *  Determines variable names for chi^2 plot and stores the current limits.
 */
static void chi2go(ident id, char *key, int code, void *arg)
{
   fchar  var;
   int    nc;
   char   limkey[KEYLEN+1];
   
   if (UserBool(key)) return; /* only react to button clear by application */
   chi2valid = TRUE; 
   var.l = KEYLEN;
   var.a = var1;
   nc = userftext(var,2,"VARNAME1=", " ");
   var1[nc] = '\0';
   chi2valid = chi2valid && nc;
   var.a = var2;
   nc = userftext(var,2,"VARNAME2=", " ");
   var2[nc] = '\0';
   chi2valid = chi2valid && nc;
   if (chi2valid) {
      sprintf(limkey,"%s_MIN=", var1);
      var1min = UserReal(limkey);
      sprintf(limkey,"%s_MAX=", var1);
      var1max = UserReal(limkey);
      sprintf(limkey,"%s_MIN=", var2);
      var2min = UserReal(limkey);
      sprintf(limkey,"%s_MAX=", var2);
      var2max = UserReal(limkey);
   }
}   
#endif

/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut, b_go;
   ident l_head, l_sizer;
   ident p_chi2;
   ident t_levels, t_samplesx, t_samplesy;
   char  *nullmenu[]={" ", NULL};
    
   s_chi2plot = GgiShell(NAME);
   (void)GgiUseShell(s_chi2plot);
   l_sizer = GgiLabel(" ");
   l_head = GgiLabel("chi2head");
   GgiSetBitmap(l_head, chi2_width, chi2_height, (char*)chi2_bits);
   p_chi2 = GgiPlotField("CHI2", CHI2_NX, CHI2_NY);
   closebut = GgiSetLabel(
                 GgiButton(key, "Close window"),
                 "CLOSE", 0);
                 
   i_box = GgiForm(NAME, 1);
   (void)GgiUseShell(i_box);
   t_levels = GgiSetLabel(GgiTextField("LEVELS=", "Contour levels", 30),
                          "Levels:", 85);
   t_samplesx = GgiSetLabel(GgiTextField("CHI2STEPX=", " ", 5),
                          "Sample size:", 85);
   t_samplesy = GgiSetLabel(GgiTextField("CHI2STEPY=", " ", 5),
                          "x ", 0);
   m_x2x   = GgiMenu("VAR1=", "Variable 1 in landscape",menulabels);
   (void)ScheduleKeyevent(set_chi2_var, "VAR1=", KEYCHANGE, m_x2x);
#if 0
   (void)ScheduleKeyevent(chi2go, "GO=", KEYCHANGE, NULL);
#endif
   m_x2y   = GgiMenu("VAR2=", "Variable 2 in landscape",menulabels);
   (void)ScheduleKeyevent(set_chi2_var, "VAR2=", KEYCHANGE, m_x2y);
   m_mode  = GgiSetLabel(
                GgiMenu("CHI2MODE=", "Select mode for landscape", nullmenu),
                "MODE", 0);
   b_go = GgiButton("GO=", "Start making chi^2 plot");
   GgiSetLabel(b_go, "GO / STOP", 0);
   GgiSetPosition(l_sizer, CHI2_NX-16, NULL, 0, NULL);
   GgiSetPosition(m_x2x,    0, NULL,  0,     NULL);
   GgiSetPosition(m_x2y,    0, m_x2x, 0,     NULL);
   GgiSetPosition(m_mode,  -GgiWidth(m_mode), l_sizer, 0, NULL);
   GgiSetPosition(t_levels, 0, NULL,  0,     m_x2x);
   GgiSetPosition(t_samplesx, 0, NULL,  0,  t_levels);
   GgiSetPosition(t_samplesy, 0, t_samplesx,  0,  t_levels);
   GgiSetPosition(b_go, -GgiWidth(b_go), l_sizer, 0, t_levels);

   (void)GgiUseShell(s_chi2plot);
   GgiSetPosition(l_head, (-CHI2_NX-GgiWidth(l_head))/2, p_chi2, 0, NULL);
   GgiSetPosition(p_chi2, 0, NULL, 35, NULL);
   GgiSetPosition(i_box,    0, NULL, 0, p_chi2);
   GgiSetPosition(closebut, 0, NULL, 0, i_box);
   (void)GgiUseShell(NULL);
   initialized = TRUE;
}

/* -------------------------------------------------------------------------- */
/*                                 chi2plot                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void chi2plot(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_chi2plot, !state);
      state = !state;
      wkey_c(tofchar(key));
   }
}

/* ========================================================================== */
/*                                 SetChi2Labels                              */
/* -------------------------------------------------------------------------- */
extern void SetChi2Labels(void)
{
   GgiMenuLabels(m_x2x, menulabels);
   GgiMenuLabels(m_x2y, menulabels);
}

#if 1
/* ========================================================================== */
/*                                 chi2menu                                   */
/* -------------------------------------------------------------------------- */
/*  Set up a menu with chi2 plot modes.
 */
void chi2menu( char** names )
{
   GgiMenuLabels(m_mode, names);
}
#endif

/* ========================================================================== */
/*                                 Chi2plot                                   */
/* -------------------------------------------------------------------------- */
/*  Chi2plot() creates a pop-up shell for Chi^2-plot display. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up op down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern ident Chi2plot(char *key, char **labels)
{
   menulabels = labels;
   initialize(key);
   ScheduleKeyevent(chi2plot, key, KEYCHANGE, NULL);
   return s_chi2plot;
}
#<

#>            chi2form.c
/* chi2file.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "ROTMAS: save Chi^2 data"

#include "stddef.h"
#include "stdio.h"
#include "gipsyc.h"
#include "string.h"
#include "userfio.h"
#include "wkey.h"
#include "ggi.h"
#include "chi2form.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

static char  popkey[KEYLEN];

static bool  initialized=FALSE;         /* initialized flag */
static ident s_fileform;                /* chi2file keywords shell     */
static ident i_box;
static ident b_over;                    /* file overwrite button */  

static bool expect_save=FALSE;

/* -------------------------------------------------------------------------- */
/*                                 filechanged                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for CHI2FILE=
 */
static void filechanged(ident id, char *key, int code, void *arg)
{
   wkeyf("SAVECHI2=Y");
}
   
/* -------------------------------------------------------------------------- */
/*                                 handle_save                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for SAVECHI2
 */
static void handle_save(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (!tobool(button) && !expect_save) wkeyf("%sY",popkey);
   expect_save = FALSE;
}
      
     
/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut;
   ident out, okbut;

   strcpy(popkey, key);
   s_fileform = GgiDialog(NAME);
   (void)GgiUseShell(s_fileform);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CANCEL", 0);
   b_over = GgiSetLabel(GgiButton("OVERCHI2=", NULL), "OK to overwrite?", 0);
   GgiDeactivate(b_over);
   i_box = GgiForm(NAME, 2);
   (void)GgiUseShell(i_box);
   out = GgiSetLabel(GgiTextField("CHI2FILE=", "Output filename", 20),
                         "Outfile", 0);
   okbut = GgiSetLabel(GgiButton("SAVECHI2=", NULL), "OK", 0);
   GgiSetPosition(out,   0, NULL, 0, NULL);
   GgiSetPosition(okbut, 0, out,  0, NULL);
   (void)GgiUseShell(s_fileform);
   GgiSetPosition(i_box,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, i_box);
   GgiSetPosition(b_over, -GgiWidth(b_over)-2, i_box, 0, i_box);
   (void)GgiUseShell(NULL);
   initialized = TRUE;
}

/* -------------------------------------------------------------------------- */
/*                                 fileform                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void fileform(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_fileform, !state);
      state = !state;
      wkeyf(key);
      if (!state) {
         GgiDeactivate(b_over);
         expect_save = TRUE;
         wkeyf("SAVECHI2= OVERCHI2=");
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 overwrite                                  */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for SAVE_OVER=
 */
static void overwrite(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=FALSE;
    
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      (void)userflog(&state, 1, 2, "SAVECHI2=", " ");
      if (state) {
         (void)TriggerKey("SAVECHI2=");
      } else {
         wkeyf(key);
      }
   }
}

/* ========================================================================== */
/*                                 ask_chi2over                               */
/* -------------------------------------------------------------------------- */
extern void  ask_chi2over(void)
{
   GgiActivate(b_over);
}

/* ========================================================================== */
/*                                 Chi2form                                   */
/* -------------------------------------------------------------------------- */
/*  Chi2form() creates a pop-up shell for saving. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern ident Chi2form(char *key)
{
   initialize(key);
   ScheduleKeyevent(fileform, key, KEYCHANGE, NULL); 
   ScheduleKeyevent(handle_save, "SAVECHI2=", KEYCHANGE, NULL);
   ScheduleKeyevent(overwrite, "OVERCHI2=", KEYCHANGE, NULL);
   ScheduleKeyevent(filechanged, "CHI2FILE=", KEYCHANGE, NULL);
   return s_fileform;
}
#<

#>            colormenus.c
/* colormenus.c
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands

Author: J.P. Terlouw
*/

#define NAME "Colors"

#include "stddef.h"
#include "gipsyc.h"
#include "userfio.h"
#include "ggi.h"
#include "colormenus.h"

static char *colkeys[]={"COLVB=", "COLVD=", "COLVG=", "COLVO=", "COLVOE=",
                        "COLVT=", "COLVU=", NULL};
static char *labels[]={"bulge", "disk", "gas", "observed",
                       "obs. errors", "total", "user"};
static char *colors[]={"",
                       "White",
                       "Red",
                       "Green",
                       "Blue",
                       "Cyan",
                       "Magenta",
                       "Yellow",
                       "Orange",
                       "Greenyellow",
                       "Greencyan",
                       "Bluecyan",
                       "Bluemagenta",
                       "Redmagenta",
                       "Darkgray",
                       "Lightgray",
                       NULL};

/* -------------------------------------------------------------------------- */
/*                                 popshell                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void popshell(ident id, char *key, int code, void *arg)
{  
   static bool state=FALSE;
   bool button=FALSE;
 
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell((ident)arg, !state);
      state = !state;
      wkeyf(key);
   }
}

/* ========================================================================== */
/*                                 ColorMenus                                 */
/* -------------------------------------------------------------------------- */
/*  ColorMenus() creates a pop-up shell with menus for setting the colour
 *  of the graphs. The argument 'key' is the GIPSY keyword (type LOGICAL)
 *  which, when set to "YES", will cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
void ColorMenus(char *key)
{
   static ident s_colormenus;
   ident s_prev, f_box;
   ident l_header;
   ident closebut;
   ident curmenu, prevmenu=NULL;
   char  **curkey;
   char  **curlab=labels;
    
   s_colormenus = GgiShell(NAME);
   s_prev = GgiUseShell(s_colormenus);
   l_header = GgiLabel(" Curve colors");
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   f_box = GgiForm(NAME, 2);
   (void)GgiUseShell(f_box);
   for (curkey=colkeys; *curkey; curkey++) {
      curmenu = GgiSetLabel(
                   GgiAlignLabel(
                      GgiMenu(*curkey, NULL, colors),
                      ggiLeft),
                   *(curlab++), 80);
      GgiSetPosition(curmenu, 0, NULL, 0, prevmenu);
      prevmenu = curmenu;
   }
   (void)GgiUseShell(s_colormenus);
   GgiSetPosition(l_header, 0, NULL, 0, NULL);
   GgiSetPosition(f_box, 0, NULL, 0, l_header);
   GgiSetPosition(closebut, 0, NULL, 0, f_box);
   (void)GgiUseShell(s_prev);
   ScheduleKeyevent(popshell, key, KEYCHANGE, s_colormenus);
}
#<

#>            subsvar.l
%{
/* subsvar.l
                              COPYRIGHT (c) 1998
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands

Variable substitution routine.
Author: J.P. Terlouw
*/

#include "stdio.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

#undef   input                    /* defined internally */
#undef   unput                    /* defined internally */
#undef   output                   /* defined internally */
#define  output(x)                /* no-op */

static void identifier();
static void other();
static char input(void);
static void unput(char);

static char  *bufptr, *varptr, *replptr, *resptr;
static char  ustack[YYLMAX];
static int   stkptr=0;
static int   errorcode=0;

%}
D     [0-9]
E     [DdEe][-+]?{D}+
OP    [\,\*\/+-]

%%
{D}+(\.{D}*)?({E})?     {other(); }
\.{D}+({E})?            {other(); }
[A-Za-z][A-Za-z0-9]*    {identifier(); }
{OP}                    {other(); }
[\(]                    {other(); }
[\)]                    {other(); }
"**"                    {other(); }
[ ]*                    {}
\01                     {BEGIN 0;}
.                       {errorcode++;}
%%


extern int subsvar(char *text, char *var, char *repl, char *result)
{
   errorcode = 0;
   bufptr = text;
   varptr = var;
   replptr= repl;
   resptr = result;
   result[0] = '\0';
   stkptr = 0;
   yylex();
   return errorcode;
}

static char input(void)
{
   static int atend=0;
    
   if (atend) {
      atend = 0;
      return '\0';
   }
   if (stkptr) {
      return ustack[--stkptr];
   }
   if (errorcode || !*(bufptr)) {
      atend++;
      return '\01';
   } 
   return *(bufptr++);
}
 
static void unput(char c)
{
   if (stkptr<YYLMAX) {
      ustack[stkptr++] = c;
   }
}

static void identifier()
{
   if (strcmp((char*)yytext, varptr)) {
      strcat(resptr, (char*)yytext);
   } else {
      strcat(resptr,"(");
      strcat(resptr, replptr);
      strcat(resptr, ")");
   }
}

static void other()
{
   strcat(resptr, (char*)yytext);
}

extern int yywrap()
{
   return 1;
}

#if 0
int main()
{
   char expr[80];
   char var[]="XFG1";
   char sub[]="sin(x)**2";
   char result[160];
   int i;
    
   while (1) {
      for (i=0; i<80; i++) {
         expr[i] = getchar();
         if (expr[i]=='\n') {
            expr[i] = '\0';
            break;
         }
      }
      if (!subsvar(expr, var, sub, result)) printf("%s\n", result);
      else printf("Error!");
   }
}
#endif
#<
