sliceview.src

        Copyright (c) Kapteyn Laboratorium Groningen 2010
        All Rights Reserved.

Name:         sliceview.src
Creator:      vogelaar
Host:         zeearend
Date:         Jun 3, 2010
Contents:     sliceview.make sliceview.dc1 sliceview.h gui.h guipar.h
              utils.h plot.h coledit.h mouse.h ellsam.h
              spline.h splinepop.h common.h helptext.h frames.h
              guilines.h zprof.h guiellipse.h guispline.h guicont.h
              guimark.h sliceview.c gui.c utils.c plot.c
              coledit.c mouse.c ellsam.c spline.c splinepop.c
              frames.c guilines.c zprof.c guiellipse.c guispline.c
              guicont.c guimark.c

#>            sliceview.make
#----------------------------------------------------------------------
# Makefile for SLICEVIEW, Feb 25, 2000
#
#
# Pack sources into sliceview.src with:  > make -f sliceview.make pack
# Clean executable and objects           > make -f sliceview.make clean
# Unpack source files with:              > $gip_exe/xfile sliceview.src
# Install source file with:              > p -reserve sliceview.src
#                                        > p -install sliceview.src
#
# Local compilation for testing:         > p sliceview.make
#
# The CC_OPTS etc. are set by 'compile'
#----------------------------------------------------------------------

SHELL = /bin/sh

OPTS  = $(CC_OPTS)
COMP  = $(CC_COMP)
LIBS  = $(CC_LIBS)

.SUFFIXES: .c .o

DOCUMENTS = sliceview.dc1

INCLUDES  = sliceview.h gui.h guipar.h utils.h plot.h coledit.h mouse.h \
            ellsam.h spline.h splinepop.h common.h \
            helptext.h frames.h guilines.h zprof.h guiellipse.h guispline.h \
            guicont.h guimark.h

SOURCES   = sliceview.c gui.c utils.c plot.c coledit.c mouse.c \
            ellsam.c spline.c splinepop.c frames.c \
            guilines.c zprof.c guiellipse.c guispline.c guicont.c guimark.c

OBJECTS   = sliceview.o gui.o utils.o plot.o coledit.o mouse.o \
            ellsam.o spline.o splinepop.o \
            frames.o guilines.o zprof.o guiellipse.o guispline.o guicont.o guimark.o

default:: sliceview

pack::
	$${gip_sys}/pack.csh sliceview.src sliceview.make \
        $(DOCUMENTS) $(INCLUDES) $(SOURCES)

clean::
	rm -f sliceview $(OBJECTS)


sliceview.o: sliceview.h

gui.o: gui.h guipar.h


.c.o:   
	@echo "$(CC_COMP) -c $(CC_OPTS) $(X11_OPTS) $< ";\
	$(CC_COMP) -c $(CC_OPTS) $(X11_OPTS) $<

sliceview: $(OBJECTS)
	@echo "$(CC_COMP) -o sliceview $(OBJECTS) $(X11_LIBS) $(CC_LIBS) $(XT_LIBS)";\
	$(CC_COMP) -o sliceview $(OBJECTS) $(X11_LIBS) $(CC_LIBS) $(XT_LIBS)

#<

#>            sliceview.dc1
Program:       SLICEVIEW


#begin section overview
                                  OVERVIEW
                                  ========

Movie window
------------

Introduction:
This program is an inspection tool for data cubes. Usually these cubes 
are a set of two dimensional images and the third axis is a spectral type.
It has a movie loop facility for a sequence of subsets with control 
buttons in the main window.
Using the frame slider you can quickly browse through your subsets. A
[COLOR] button pops up a colour editor. This editor allows you to adjust the
colours and to select another colour table. Changing colours is also possible
with the mouse cursor on the image display while pressing the left button.
Colours are divided over a range of pixel values entered in the CLIP 
input field in the main gui. If the value in this field is not fixed by 
the [FIX] button, it will be updated by the program with a default. 

Smooth images:
You can smooth the images by pressing the [INTP] button. This button sets
the image interpolation mode for a selected plot device. All images plotted
after pressing this button will be interpolated.

Hardcopy options:
The images are annotated with axis labels for grids and physical coordinates.
A hardcopy of a selected image (also called frame) is made by selecting the
'save plot' option from the 'FILE' menu. A new window allows you to enter 
a plot device and the name of the PostScript output.
It is also possible to setup an input file for GPLOT. It creates code to 
reproduce a selected image.

Recording of images:
Using the [REC:] button it is possible to record a sequence of frames
in an MPEG movie. See section 'MPEG movie' for details.

Zooming:
In all display modes one can zoom/dezoom an image or move an image (panning)
using keyboard keys. See section about mouse and keyboard.

Windows resize:
The sizes of the windows in your Graphical User Interface cannot be changed
while the program is running. You have to restart the program with keywords
that alter the window sizes. See section 'keywords' to look how these 
keywords are called.



Slice modes
-----------
Images of slices through a data cube are a powerful inspection tool. This
program has three modes each corresponding to a special type of slice.
Standard is the line type. Samples at equidistant intervals are taken along 
a line which has a certain length and an angle with respect to the +Y axis
(i.e. to the north in a spatial system). The subset values along the sample 
are stored and extracting is repeated for the remaining subsets. This set
of data points is displayed as an image with the sample offsets as X axis 
and with the physical coordinates of the 'subset repeat' axis as Y axis 
(usually velocity, hence the name XV image).
A second sample line can be activated. This line has a constant offset in 
angle with respect to the first line. The length and angle of the primary
line can be controlled by mouse or control panel in the slice window.
The slice width can be changed also. This uneven width in grids averages 
a number of profiles in the same direction. Blank image values are not 
taken into account.

Second slice type is an ellipse or ellipse segment. The sample extraction
starts at the endpoint of the major axis and runs counter clockwise in the
direction of the minor axis. 

Third type is a sample extracted along a spline. The spline is created by
entering control points with your mouse. The program creates a smooth curve 
through these points and tries to find sample points between control points
at equal distances. So sample points always coincide with control points.
This is also the mode that you need if you have your own sample positions
and want to create an XV map with these points.

All the slice windows include a line graph. This graph is an intensity plot
of the samples along the slice for the current subset. The X axis is the same 
as the X axis of the XV image.

Markers
-------
With key 'M' you put a marker in both your subset image and the XV map.
The marker in the subset is a symbol of your own choice. The marker in
your XV map is a vertical line in a corresponding colour. Pressing 'M' 
at an already marked position will remove the marker.
Markers are positioned onto a slice line, ellipse or spline curve.

Z-profiles
----------

If we call the subset axes the X and Y direction of the data cube, then 
the third axis is called the Z axis. At each position X,Y you can view
the intensity along Z for each subset in a so called Z profile. You can
move the mouse while pressing the Right mouse button and see how the
Z profiles change with position.

In the spline slice mode it is also possible to mark an area. The spline 
is closed then and the sum of the image values is calculated for each subset.
Then a Z profile is plotted where the Y axis is no longer intensity but 
a sum of enclosed intensities. Each intensity is weighted by the enclosed
pixel area so accurate fluxes can be derived.


External sets
-------------

An 'External set' pop up is activated from the FILE menu or by pressing the 
[EXT.SET] button. First select in which of the three external set frames 
you want to store the image. Then you select a moments
option or enter the name of a set or DSS fits file. The DSS fits file will be 
converted to a GIPSY set. An external set is reprojected (using
GIPSY task REPROJ) with the projection parameters copied from the main 
input set. The contour button in the main window allows you to enter
contour levels and specify whether you want to overlay them on other 
frames or not.
This is an easy way to compare e.g. optical and HI images. 
The 'load special set' pop-up shows for each external or moments set a
clip input field. This clip must be given in units of the external set.
For an empty field, the program tries to calculate a reasonable default and
shows this default in the input field after it displayed the new set.
Note that for frames with different clips and or units, the colour wedge
changes accordingly.

Hardcopies of external sets show also slice samples and markers.
External sets made by the program (sets with moments data, sets from DSS files)
are stored on disk and are NOT removed by the program so that you
can use them outside SLICEVIEW. The names of these sets all start with
prefix "sliceview_", e.g. 'sliceview_dssreproj' or 'sliceview_reproj_0'.

#end section overview



#begin section lines
                            XV MAP FROM A SAMPLE LINE
                            =========================

Along the plotted sample line in the main (or movie) window, samples are 
extracted for each subset. 

These are the line parameters:

parameter               changed by 
---------               ----------
Length                  left mouse or sample length slider.
Angle                   left mouse or angle gauge.
Center                  middle mouse button or position input field.
                        positions in input field can be any valid 
                        GIPSY coordinate.
Width                   Sample width input field
Sample separation       Sample separation input field


A second sample can be viewed also. This sample has a constant offset in 
angle with respect to the first sample line. You can couple the lengths
of the two lines and set a ratio with which the length of the second 
line is calculated from the first.

A line graph shows the intensities along the sample line for the current
subset.

Default, the sample intensity is extracted from the nearest pixel. For
a more realistic intensity you can interpolate intensities using a bilinear
interpolation scheme for the 4 nearest pixels. Use the [DINPT] button
to start bilinear interpolation.

Output of sample positions and corresponding image values is possible.
Select option 'Save sample' in the [FILE] menu of the slice gui.
Note that the slice lines usually have different lengths. This will show
in the Ascii file on disk. Empty values are marked with the a character.

#end section lines



#begin section ellipse
                          XV MAP FROM A SAMPLE ELLIPSE
                          ============================

Along the plotted sample ellipse in the main (or movie) window, samples are 
extracted for each subset. 

These are the ellipse parameters:

parameter               changed by 
---------               ----------
Major axis              Left mouse, Major axis slider or input field.
Minor axis              Left mouse, Minor axis slider or input field.
Center                  Middle mouse button or position input field.
                        Positions in input field can be any valid 
                        GIPSY coordinate.
Angle range             Angle range input field.
sample separation       Sample separation input field.


While changing the length of an ellipse axis with the mouse, the program 
will determine which of the minor and major axis is closest. Only
this axis is changed in length.

You can couple the lengths of major and minor axis and set a ratio 
with which the length of the minor axis is calculated from the length
of the major axis

A line graph shows the intensities along the sample ellipse for the current
subset.

Default, the sample intensity is extracted from the nearest pixel. For
a more realistic intensity you can interpolate intensities using a bilinear
interpolation scheme for the 4 nearest pixels. Use the [DINPT] button
to start bilinear interpolation.

You can give a width in grids. Then each sample intensity on the ellipse
is an average of samples taken along a vector perpendicular to the
tangent.

Pressing 'F' will fill the area inside the ellipse. The sum of all the 
pixels inside is calculated by weighting the intensities by their
area inside the ellipse. This process is repeated for all the subsets
and a plot displays the sum as function of the subset (in grid coordinates).
Besides a scale factor this plot shows the flux as function of subset 
(usually velocity).

Output of sample positions and corresponding image values is possible.
Select option 'Save sample' in the [FILE] menu of the slice gui.

#end section ellipse



#begin section spline
                           XV MAP FROM A SAMPLE SPLINE
                           ===========================

Along the plotted sample spline in the main (or movie) window, samples are
extracted for each subset.

These are the spline parameters:

parameter                      changed by 
---------                      ----------
Sample separation              Sample separation input field. 
New spline control point       Left mouse button.
Insert spline control point    Keyboard 'i' or 'I'.
Delete spline control point    Keyboard 'd' or 'D'.
Close spline curve             Keyboard 'c' or 'C'.
Clear curve                    Clear button

Insertion of a point is done at the current cursor position. Deletion is an
operation done on the nearest spline control point with respect to the 
current cursor position with a maximum distance of 10 grids. The maximum number
of spline control points is 1000.
A spline must be closed before a z-flux-profile can be plotted. 

A line graph shows the intensities along the sample spline for the current
subset. 
Pressing 'F' will fill the area inside a closed spline. The sum of all the 
pixels inside is calculated by weighting the intensities by their
area inside the spline area. This process is repeated for all the subsets
and a plot displays the sum as function of the subset (in grid coordinates).
Besides a scale factor this plot shows the flux as function of subset 
(usually velocity).

Default, the sample intensity is extracted from the nearest pixel. For
a more realistic intensity you can interpolate intensities using a bilinear
interpolation scheme for the 4 nearest pixels. Use the [DINPT] button
to start bilinear interpolation.

You can give a width in grids. Then each sample intensity on the ellipse
is an average of samples taken along a vector perpendicular to the
tangent.

How to enter your sample positions?
With the [FILE] button you can select the option 'Read spline points'.
Enter the name of the Ascii file on disk. Note that the format of this
file is fixed, i.e. each line must contain a valid GIPSY position.

Example contents of a file:
23.4           -12.3                   Grids
* 14 26 9       * -12 3 5.4            Hms, dms in epoch of header
*2000 14 26 9   *2000 -12 3 5.4        Hms, dms in another epoch
G 128.20        G 23.32323             Galactic longitude or latitude in deg.
E 128.20        E 23.32323             Ecliptic longitude or latitude in deg.
S 128.20        S 23.32323             Supergalactic longitude or lat. in deg.

The menu in [FILE] has also an option to write the spline control points.
This is done in a way that the file can be used as input file for control points,
i.e. there is one position (in one of the formats from above) per line.

Appended in comments is the same output but then with the corresponding 
(non interpolated) image value corresponding to the nearest integers of the
given position. 
Also appended in comment lines, the physical values corresponding to the 
grid positions in units of the GDS/FITS header. The format of these positions
is:
 U xxxx.xxx U yyyy.yyy

These position can be used as marker positions for other sets, as long the
sky systems are the same.
One can edit the file to make it suitable as input for
various tasks.

#end section spline


#begin section hardcopy

                                 HARDCOPY
                                 ========

There are two ways to get a hardcopy of what is displayed on screen.
First there is a menu item under FILE called 'Save plot' that sends
the current image to a PostScript file. You can enter a name of this
PostScript file and have to select a plot device.
Another way requires GPLOT. You can store the current colour information 
in the header of the current displayed image. In GPLOT you can use 
command 'getlut header' to read back the colour information before 
you use command 'colplot' to make a hardcopy of this set. Next example is
a set of GPLOT commands to create hardcopies.

device pcpsfile/a.ps
inset dummy_zero_moment 0
box
xsize 140
ysize 140
getlut header
colplot
frame
close

A third option is to save the current plot (only from the subset range, because the 
extra sets are in a way artificial). All relevant GPLOT commands are stored in a 
file on disk. Colour information is stored, contour information is stored and the 
interpolation mode is copied.
Here is an example of a GPLOT input file generated by SLICEVIEW.

! Start GPLOT with COMMAND=input <thisfilename>
device lcpsfile
inset rense VELO 21
xsize 100
ysize 100
box -50 -50 49 49
frame
getlut header
interpol on
colplot
interpol off
levels 0.01:0.1:0.01
color 2
lwidth 2
lstyle 1
contours
close


#end section hardcopy


#begin section mpeg
                                MPEG MOVIES
                                ===========

This option allows you to record a movie in MPEG format.
It requires GIPSY's Python binding to be installed and
the utilities import (from ImageMagick) and ppmtompeg
to be present.

Steps:

1. in the text field next to the [REC:] button specify the name of
   the MPEG file in which the movie should be recorded.
   If omitted, the name 'sliceview.mpg' will be used.

2. position your movie at the frame position where recording should start.

3. press the [REC:] button. This will cause the task MPEG to be started.

4. make sure that no other windows are covering the movie window.

5. start the movie. From now on, every frame in the movie is recorded
   by the task MPEG. During this time SLICEVIEW's GUI is hardly
   responsive to user actions.

6. when the last frame of interest has been recorded, press the [STOP]
   button of the MPEG task. Then the MPEG movie will be constructed from
   the recorded frames and SLICEVIEW will resume normal operation.

After this, a number of files will have been created in your working
directory. Besides the resulting MPEG file there will be a file with a
name like 'frame%%%%.ppm' for each recorded frame. And there will be
a file 'mpeg.par' which is the ppmtompeg parameter file. These files
can be modified and used to regenerate an MPEG movie with different
parameters. Or they can be deleted.

#end section mpeg

#begin section howto
                                 HOWTO'S
                                 =======

How to start?
------------
From the FILE menu, read set/subsets using the file browser. 
Select a slice type from the SLICE menu. Use the mouse to change
the sample curves in the main plot.


What to do if you do not have enough display memory to view all your subsets?
-----------------------------------------------------------------------------
Select less subsets in the 'Input set' window or decrease the size of the 
movie window. If you select the maximum number of available frames, then 
there is no storage anymore to view 'external' images.


How do I make a hardcopy of a framed subset?
--------------------------------------------
Select the 'Save plot' option from the 'File' menu. You will be asked to 
select a device and a PostScript file name. The PS file is always stored
on disk.


How do I make a movie in MPEG format?
-------------------------------------
With the [REC:] button. But please read section 'MPEG movie' first.


Can I use the GPLOT commands 'getlut' and 'storelut'?
----------------------------------------------------
These commands retrieved or stored the colour information of
a displayed image in the header of the set. It connected to GIDS,
so for SLICEVIEW you have to do something else. You can store
colour information in a header with the FILE menu option
'save colors to set'. Then you can retrieve the colour settings
in GPLOT with command 'getlut header'.



How to fix a ratio between minor and major ellipse axes?
--------------------------------------------------------
Enter a number or expression, e.g. cos(rad(40))
and push the 'couple' button. Moving the slider for the major axis
results in a new value for the minor axis according to the new ratio.
The slider for the minor axis is disabled while coupling is on.


How to enter your own sample positions?
---------------------------------------
Sample positions can be read from an Ascii file on disk. The format for
these positions in the file is fixed, i.e. each line must contain a 
valid GIPSY position.
Example contents of a file:
23.4           -12.3                   Grids
* 14 26 9       * -12 3 5.4            Hms, dms in epoch of header
*2000 14 26 9   *2000 -12 3 5.4        Hms, dms in another epoch
G 128.20        G 23.32323             Galactic longitude or latitude in deg.
E 128.20        E 23.32323             Ecliptic longitude or latitude in deg.
S 128.20        S 23.32323             Supergalactic longitude or lat. in deg.


How can I select only the spline control points as sample positions?
--------------------------------------------------------------------
If you want only your spline control points as sample position, then select 
a sample separation greater than the largest distance between two control 
points.


How to get a less 'granulated' view of a XV map?
------------------------------------------------
Select both data interpolation (for non-integer sample positions) and
display interpolation with the [DINTP] and [INTP] buttons. For a movie
you have to reload your data.


How can I improve the resolution of my optical overlay?
-------------------------------------------------------
External sets are reprojected using the projection parameters from
the input set with which you started to display data. If you need 
higher resolution overlay data then you have to regrid your input set 
with GIPSY tasks REPROJ or REGRID to a smaller grid separation.
A faster but less accurate solution could be the use of interpolation 
using the [INTP] button in the main gui. An interpolated version of
your external- or moments set will be displayed. Note that this will
not apply to the plotting of contours.

#end section howto




#begin section keywords
                                KEYWORDS
                                ========

Only a limited number of keywords need to be remembered. Most of these
are related to the sizes of the plot windows. These sizes must be specified
before starting the application.


Keyword        Example       Meaning    
==================================================================
XYWIDTH=       600           Main plot dimensions in screen pixels
XYHEIGHT=      500
XVWIDTH=       400           Slice plot dimensions
XVHEIGHT=      200
XIHEIGHT=      100           Line graph height
ZWIDTH=        500           Z-profile plot dimensions
ZHEIGHT=       200

CLIP=          -0.003 0.012  Divide available colours over this range of
                             pixel values.

If you need to know which keyword is involved while generating an event
(e.g. input of a set or a box or pressing a button), then start this
program on the command line with keyword MONITOR=Y
Your GIPSY log will show the events and the related keywords.

#end section keywords




#begin section limits
                              PROGRAM LIMITS
                              ==============
-The maximum number of input subsets (channel maps) is 4096.
-The maximum length of a file name is 256
-The maximum number of spline control points is 1000.
-The maximum number of subsets to store in a movie is 256.

#end section limits



#begin section mouse
                              MOUSE ACTIONS and KEYBOARD KEYS
                              ===============================

Mouse actions depend on the slice mode. A short description of the mouse
actions is displayed in the status lines of the main window.


ALL modes:
+:                   zoom in at cursor position
-:                   zoom out at cursor position
0:                   reset image to original size
9:                   move image from current mouse position to center of image
arrow keys:          pan image over short distance

Right mouse button:  Open window with Z profile. Drag mouse while pressing this button 
                     to inspect profiles at different positions.
Shift left mouse:    zoom in at cursor position
Ctrl  left mouse:    zoom out at cursor position



DISPLAY mode:
Left mouse button:   Change slope and shift in the colour function with the mouse.
                     In fact this actions changes the setting of the colour editor.
                     


LINE mode:           
Left mouse button:   Drag mouse to change length and angle of closest line
Middle mouse button: Drag mouse to move center of line 
Right mouse button:  Update window with z-profile

M:                   Put a marker on the line.
                     A corresponding marker line appears in the XV image.
                     Unmark a position with the same key at the same position.
E:                   Erase all markers.



ELLIPSE mode:
Left mouse button:   Drag mouse to change length and angle of major axis
Middle mouse button: Drag mouse to move center of ellipse 
Right mouse button:  Update window with z-profile

M:                   Put a marker on the perimeter of the ellipse. 
                     A corresponding marker line appears in the XV image.
                     Unmark a position with the same key at the same position.
E:                   Erase all markers.
Z:                   Fill area enclosed by ellipse and calculate sum in area for each
                     image. Result is an integrated Z-profile.


SPLINE mode:
Left mouse button:   Add a spline control point
Right mouse button:  Update window with z-profile

C:                   Close spline to get a closed area
I:                   Insert a spline control point at mouse cursor position
D:                   Delete nearest spline control point
M:                   Mark/unmark a position on the spline. A corresponding marker line 
                     appears in the XV image.
                     Unmark a position with the same key at the same position
E:                   Erase all markers
S:                   Erase spline and prepare for a new one.
Z:                   Fill area enclosed by spline and calculate sum in area for each
                     image. Result is an integrated Z-profile.
#end section mouse



#begin section defaults
                                DEFAULTS
                                ========
PostScript file name:                    sliceview.ps
File name for sample positions:          sliceview.dat
Set name for output of XV images:        sliceviewxvset
Initial position angle line and ellipse: 45 deg.
Initial sample line width:               1
Angle between sample lines:              90
Ellipse segment:                         0 to 360 deg.
Interpolation on plot device:            NO
Interpolation in XV data:                NO

Clip values:                             From header if available
#end section defaults



#begin section about
Purpose:       SLICEVIEW is an inspection tool for 2d and 3d data sets. It 
               extracts and displays slices under any angle and (for 3-d sets)
               shows z-profiles/flux at any position.

Category:      ANALYSIS, DISPLAY, PLOTTING, PROFILES, ROTATION-CURVES, 
               VELOCITY-FIELDS

File:          sliceview.src

Author:        M.G.R. Vogelaar (GUI: J.P. Terlouw)

Keywords:      See section keywords
               
Version:       1.6

Updates:       Feb 27, 2000: VOG, Document created.
               Sep 07, 2000: VOG. Version 1.2 in system
               Oct 13, 2000: VOG. Version 1.3 in system
               Jan 06, 2001: VOG, Changed spline sampling
               Apr 02, 2002: JPT, Changed movie controls availability.
               Dec 08, 2004: JPT, Implemented MPEG recording.
               Apr 20, 2008: VOG, Added image values to slice linegraph
                                  output to file.
               Apr 12, 2009: VOG, Changed NINT macro to definition that
                                  uses floor() for compatibility with
                                  basic routines dealing with coordinates.

#end section about
#<

#>            sliceview.h
/*
                          COPYRIGHT (c) 2000-2004
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/


#include    "common.h"       /* Useful for all routines */

/* Miscellaneous includes */

#include    "init.h"         /* Declare task running to HERMES and initialize.*/
#include    "finis.h"        /* Informs HERMES that servant quits and cleans up the mess.*/
#include    "anyout.h"       /* General character output routine for GIPSY programs.*/
#include    "error.h"        /* User error handling routine. */
#include    "myname.h"       /* Obtain the name under which a GIPSY task is being run.*/
#include    "nelc.h"         /* Characters in F-string discarding trailing blanks.*/
#include    "minmax1.h"      /* Min, max of an array */
#include    "axunit.h"       /* Returns the units of the physical coordinates of an axis in a set */
#include    "cotrans.h"      /* Transformation from grid coordinates to physical coordinates vv. */
#include    "axtype.h"
#include    "grtoph.h"
#include    "phtogr.h"
#include    "factor.h"
#include    "skyrot.h" 
#include    "getaxname.h"


/* Input of sets */

#include    "gdsinp.h"       /* Input of set, subsets, return # subsets.*/
#include    "gdsout.h"       /* Set for output */
#include    "gdspos.h"       /* Define a position in a subset.*/
#include    "gdsbox.h"       /* Define a box inside/around a subset.*/
#include    "gdsasn.h"       /* Copy input set */
#include    "gdscpa.h"       /* Change properties of an axis in output set */
#include    "gdscss.h"       /* Change size of output before gdsout call */
#include    "gds_exist.h"
#include    "gds_close.h"    /* Close set. */
#include    "gdsc_range.h"   /* Return lower left and upper right corner of a subset.*/
#include    "gdsc_word.h"
#include    "gdsc_ndims.h"   /* Return the dimensionality of a coordinate word.*/
#include    "gdsc_grid.h"    /* Extract grid value.*/
#include    "gdsc_fill.h"    /* return coordinate word filled with a grid */
                             /* value for each axis.*/
#include    "gdsi_read.h"    /* Reads data from (part of) a set.*/
#include    "gdsi_write.h"
#include    "gdsc_name.h"
#include    "gdsd_rchar.h"
#include    "gdsd_rreal.h"
#include    "gdsd_rdble.h"
#include    "gds_delete.h"
#include    "gdst_abslevel.h"/* Disable/enable search at higher levels */

#include    "ggi.h"
#include    "guipar.h"


#define RELEASE        "1.7"      /* Version number. Make copy in dc1 */


/* Common to all the program blocks */

float   fblank;
double  dblank;
fint    setlevel;
char    taskname[20];



typedef struct
/*------------------------------------------------------------*/
/* 'settype'. Define a struct for a set with its properties.  */
/*------------------------------------------------------------*/
{
   char    name[FILENAMELEN+1];  /* A buffer for the set name */
   fchar   Name;                 /* The set name */
   char    handlebuf[FILENAMELEN+1];
   fchar   Sethandle;
   fint    subsets[MAXSUBSETS];  /* Array for the subset coordinate words */
   fint    setdim;
   fint    subdim;
   fint    flo[MAXAXES];         /* Low  edge of frame in grids */
   fint    fhi[MAXAXES];         /* High edge of frame in grids */
   fint    blo[MAXAXES];         /* User low  edge of frame in grids */
   fint    bhi[MAXAXES];         /* User high edge of frame in grids */
   fint    nsubs;                /* Number of subsets entered in 'gdsinp' */
   fint    axnum[MAXAXES];       /* Array of size MAXAXES containing the */
                                 /* axes numbers.  The first elements (upto */
                                 /* the dimension of the subset) contain the */
                                 /* axes numbers of the subset, the other */
                                 /* ones ontain the axes numbers outside the */
                                 /* the subset ordered ccording to the */
                                 /* specification by the user. */
   fint    axcount[MAXAXES];     /* Array of size MAXAXES containing the */
                                 /* number of grids along an axes as */
                                 /* specified by the user. The first elements */
                                 /* (upto the dimension of the subset) */
                                 /* contain the length of the subset axes, */
                                 /* the other ones contain the the number of */
                                 /* grids along an axes outside the subset. */
                                 /* the operation for each subset, Class 2 */
                                 /* is for applications for which the */
                                 /* operation requires an interaction between */
                                 /* the different subsets. */
   double  cdelt[MAXAXES];       /* The grid spacings in header units */
   double  maprotation;          /* Rotation from header for spatial map */
   double  cpos[2];              /* Central position */
   bool    grids;                /* Physical coordinates involved for subsets?*/
   float   clip[2];              /* Clip levels used to display the XV plots */
   float   defclip[2];           /* Default clip levels from header */
   int     exist;                /* Is this set used? */
   char    dataunits[FITSLEN+1];
   int     grid2hmsdms;          /* Cursor grid position is displayed in hms dms */
                                 /* only when possible */
   char     axisname[MAXAXES][FITSLEN+1];  /* Name of outside subset axes */
   int      axisrange[MAXAXES][2];         /* And their ranges */
}
settype;



typedef struct
/*------------------------------------------------------------*/
/* 'xvflag' type.                                             */
/*------------------------------------------------------------*/
{
   int   index;            /* Sample index (= x position in XV diagram */
   int   colour;
   int   linewidth;
   int   markwidth;
   int   linestyle;
   int   symbol;
   float size;   
} XVflag;



typedef struct
/*------------------------------------------------------------*/
/* 'lineslice' type.                                          */
/*------------------------------------------------------------*/
{
   float   *Xpos;
   float   *Ypos;
   float   offmin;
   float   offplus;
   int     ndat;
   float   angle;
   float   xc, yc;
   float   sampledist;     /* Distance in pixels between two samples */
   float   samplelen;      /* Total length in pixels of sample line */
   float   *dummyx;        /* dummy x values for line from sliceimage */
   float   *sliceimage;
   float   slicewidth;     /* Slice line can be sampled in width also */
   float   intsep;         /* Integration separation */
   float   dirvect[2];     /* Direction vector of this slice */
   float   offsetpa;       /* Angle w.r.t. previous sample line */
   fint    PGplotid;       /* Plot destination for XV image */
   ident   GGIplotid;      /* Ggi identifier for this plot */
   fint    PGgraphid;      /* Plot destination for XV image */
   ident   GGIgraphid;     /* Ggi identifier for this plot */   
   float   axratio;        /* Ratio of sample lengths */
   XVflag  *flag;
   int     numflags;   
} lineslice;


typedef struct
/*------------------------------------------------------------*/
/* 'ellipseslice' type.                                       */
/*------------------------------------------------------------*/
{
   float   *Xpos;          /* Positions of samples along the line */
   float   *Ypos;
   float   offmin;         /* XV plot X-axis limits in physical coordinates */
   float   offplus;
   int     ndat;           /* Number of sample points */
   float   angle;          /* Current angle of slice line */
   float   xc, yc;         /* Rotation center of slice line */
   float   sampledist;     /* Distance in pixels between two samples */
   float   slicewidth;     /* Slice ellipse can be sampled in width also */ 
   float   intsep;         /* Integration separation */   
   float   major;          /* Total length in pixels of sample along major axis */
   float   minor;
   float   startpa;        /* Start sample at this angle */
   float   endpa;
   float   *dummyx;        /* dummy x values for line from sliceimage */
   float   *sliceimage;
   fint    PGplotid;       /* Plot destination for XV image */
   ident   GGIplotid;      /* Ggi identifier for this plot */   
   fint    PGgraphid;      /* Plot destination for XV image */
   ident   GGIgraphid;     /* Ggi identifier for this plot */
   float   axratio;        /* Ratio of sample lengths */   
   XVflag  *flag;
   int     numflags;   
} ellipseslice;


typedef struct
/*------------------------------------------------------------*/
/* 'splineslice' type.                                       */
/*------------------------------------------------------------*/
{
   float   Xpos[MAXPAR];
   float   Ypos[MAXPAR];
   int     ndat;
   float   *XposO;
   float   *YposO;
   int     ndatO;   
   float   sampledist;     /* Distance in pixels between two samples */ 
   float   slicewidth;     /* Slice spline can be sampled in width also */ 
   float   intsep;         /* Integration separation */   
   float   *sliceimage;
   float   *dummyx;        /* Dummy x values for line from sliceimage */
   fint    PGplotid;       /* Plot destination for XV image */
   ident   GGIplotid;      /* Ggi identifier for this plot */
   fint    PGgraphid;      /* Plot destination for XV image */
   ident   GGIgraphid;     /* Ggi identifier for this plot */
   XVflag  *flag;
   int     numflags;
   float   lengrids;       /* The length of the spline as estimated in spline.c */
} splineslice;


typedef struct
{
   double   mingrid;
   double   maxgrid;
   double   minph;
   double   maxph;
   char     headerunits[FITSLEN+1];
   char     axisname[FITSLEN+1];
} Yaxis;


typedef struct
{
   fchar   Set;
   char    gdsname[FILENAMELEN+1];
   char    origname[FILENAMELEN+1];
   fint    subset;
   fint    type;
   float   clip[2];
   char    dataunits[FITSLEN+1]; 
   int     exist;
}
externaltype;


typedef struct
{
   settype              inset;            /* Extract XV data from this set */ 
   int                  boxexist;
   ident                mainplotGGIid;
   fint                 PGmainplotid; 
   ident                maincursorid;
   ident                line1cursorid;
   ident                line2cursorid;
   ident                ellipsecursorid;
   ident                splinecursorid;         
   int                  hardcopy;
   fint                 PGhardcopyid;
   fint                 PGinfoid;
   char                 PSname[FILENAMELEN];    /* File name for hard copy */ 
   char                 samplefilename[FILENAMELEN];    /* File name for sample data */    
   char                 gplotfilename[FILENAMELEN];    /* GPLOT commands file*/       
   lineslice            line[2];          /* Two samples along a line */
   ellipseslice         ellipse;          /* Sample along an ellipse */
   splineslice          spline;
   Yaxis                yaxis;
   bool                 panel2;           /* Is panel 2 active ? */
   bool                 linegraph;        /* Plot also an intensity graph ? */
   int                  newframe;         /* Plot a labeled box around linegraph */
   int                  slicemode;        /* One of line, ellipse or spline */
   bool                 interpol;         /* Interpolation on/off */
   float                fluxregrid;       /* Regrid pixels within closed contours to increase accuracy */
   bool                 pginterpol;       /* PGIMAG device interpolation */
   float                extclip[2];       /* Levels to scale external set data */
   int                  imagesloaded;     /* Are subsets already displayed? */
   fchar                Outsetname;       /* Name of set to save xv map */
   char                 outsetbuf[FILENAMELEN];
   externaltype         external[EXTRAFRAMES];  /* External sets like tot. HI */
   int                  currentframe;
   int                  newset;           /* A new set is loaded */
   int                  *updateframe;     /* Reload this frame? */
   int                  skipsliceupdate;  /* If 0, then do not update xv image(s) */
} globaltype;  

#<

#>            gui.h
#if !defined(_gui_h_)
#define _gui_h_

typedef enum {SLICE_LINES, SLICE_ELLIPSE, SLICE_SPLINE} gui_slice_choices;
typedef enum {MENU_MAIN, MENU_LINES, MENU_ELLIPSE, MENU_SPLINE} gui_menucontext;

void gui(void);
void gui_status(char *message, int lineno); /* message in status line */
void gui_error(char *message); 
int gui_xyframes(int requested);            /* allocate movie frames */
void gui_applycol(void);                    /* apply colors from map */
void gui_colormap(int ncolors, float *reds, float *greens, float *blues, 
                               float *bred, float *bgreen, float *bblue);
void gui_datarange(float v1, float v2);     /* set data range for wedge */
void gui_units(char *units);                /* set units for wedge */
void gui_colupd(bool allow);                /* control range, unit updates */
void gui_info(int lineno, char *message);   /* info line in main window */
extern void gui_samlen(float length);       /* set sample length gauge limit */
extern void gui_e_samlen(float length);     /*       ,,       (ellipse)      */
typedef void (*FrameProc)(void);            /* movie frame notification */
void ScheduleFrame(FrameProc proc);
void FrameText(int frame, char* text);      /* annotate extra frame */
void gui_zprof_info(int n, char *text);     /* set z-prof window text line */
void gui_line_status(int n, char *text);    /* annotate line panel */
void gui_ell_status(int n, char *text);     /* annotate ellipse panel */
void gui_spl_status(int n, char *text);     /* annotate spline panel */
int  gui_imgcols(void);                     /* get number of image colors */
#endif
#<

#>            guipar.h
#if !defined(_guipar_h_)
#define _guipar_h_

#define IMAGECOLORS 80  /* number of image colors */

#define XYWIDTH  600    /* main plot dimensions */
#define XYHEIGHT 500

#define XVWIDTH  400    /* slice plot dimensions */
#define XVHEIGHT 200

#define XIHEIGHT 100    /* line graph height */

#define ZWIDTH   500    /* z-profile plot dimensions */
#define ZHEIGHT  200

#define STATUSLINES 3   /* number of status lines in main window */
#define INFOLINES   2   /* number of information lines in main window */

#define EXTRAFRAMES 3   /* number of special frames */

#endif
#<

#>            utils.h
/*
                           COPYRIGHT (c) 1999
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/      

#if !defined(_utils_h_)
#define _utils_h_
bool UserLog( char * );
int emptykey( char  *key );
void hermesstatus( char * );
void error_status( char *, char *, char * );
void clearstatus( void );
void clearfchar( fchar );
float getipval( float, float, fint *, fint *, float ** ); 
float putinrangedeg( float angle );
void stamp( char *mes );
int nearestinarray( float x, float y, float *Xpos, float *Ypos, int ndat, float nearmax ); 
void helpinstatus( int mode );
void deputyerror( fint err, char *mes );
int deputyC( char *taskname, int list );
int luttotable( fchar, fint, fint, float *, float *, float *, fint, fint, fint, float, float, fint );
#endif 
#<

#>            plot.h
/*
                           COPYRIGHT (c) 1999
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/      

#if !defined(_plot_h_)
#define _plot_h_
#define VPXLO   0.15
#define VPYLO   0.2
#define VPXHI   0.9
#define VPYHI   0.95

void setchsize( float ch );
void setchmm( float chmm );
float maxviewport( float charmm );
void setwindow( float, float, float, float );
void setviewport( float, float, float, float );
void setstandardviewport( void );
void setlinestyle( int  style );
void setcolor( int col );
void setwidth( int width );
void setfont( int font ) ;
void plmove( float x, float y );
void pldraw( float x, float y );
void pltext( float x, float y, float angle, float fjust, char *text );
void plsymbol( float x, float y, int symbol,
               float charh, int linewidth, int colour );
void plpoints( float *x, float *y, int ndat, int symbol );
void plarrow( float x1, float y1, float x2, float y2,
              float charh, int linewidth, int colour );
void plrect( float *box, int colour );
void plellipse( float cx, float cy, float maj, float min, float angle, 
                float start, float end );
void setmarker( float x, float y, fint sym );
void setinterpolation( bool interpol );
void selectplot( int id );
void clearpage( void );
fint initplot( char *dev, int  rows, int  cols );
void labelsubset( char *, int col );
#endif 

#<

#>            coledit.h
#if !defined(_coledit_h_)
#define _coledit_h_
void Coledit(char *key, int ci, int nc, int bl);
#endif
#<

#>            mouse.h
/*
                           COPYRIGHT (c) 2000
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/      

#if !defined(_mouse_h_)
#define _mouse_h_
void annotateimage( globaltype  *g, int colour );
int getgridspacings( settype   *set );
int getlinesampledata( globaltype *, int,  char * );
void plotimage( globaltype *g, float *image );
void plotcontour( globaltype *g, float *image );
void displaysliceimage( globaltype *g, int panelnr, float *image );
fint getcword( fchar Setin, fint profaxnum );
void linegraph( globaltype *g );
void subsetarrow( globaltype *g, int panelnr );
int getcurrentframenumber( void ); 
void getsliceim( globaltype *g, int panelnr, int  arrowcol );
void cursor( ident id, GgiPlotInfo info, void *arg );
void xvcursor( ident id, GgiPlotInfo info, void *arg );
void writexv( globaltype *g, int currentxv );
void plotexternalcontour( globaltype *g );
float getimagevalue( globaltype *g, int xi, int yi, int framenr );
void getphysraw( globaltype  *g, float x, float y, int subnr, double *xph, double *yph );
#endif 
#<

#>            ellsam.h
/*
                           COPYRIGHT (c) 2000
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/      

#if !defined(_ellsam_h_)
#define _ellsam_h_
int sampleellipse( double   x0,
                   double   y0,
                   double   maj,
                   double   min,
                   double   arclen,
                   double   angle,
                   double   startpa,
                   double   endpa,
                   float   *xsam,
                   float   *ysam,
                   int      nmax );
#endif 

#<

#>            spline.h
/*
                           COPYRIGHT (c) 2000
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/      

#if !defined(_spline_h_)
#define _spline_h_
void cubicspline( float  *X,
                  float  *Y,
                  int    np,
                  float  sampdist,
                  float  **XO,
                  float  **YO,
                  int    *nout,
                  fint   *blo,
                  fint   *bhi,
                  float  *leningrids );
int splineinsert( float x,
                  float y,
                  splineslice *spline );
int splinedelete( float x,
                  float y,
                  splineslice *spline );
int splinenearestpoint( float x,
                        float y,
                        splineslice *spline ); 
#endif 
#<

#>            splinepop.h
#if !defined(_splinepop_h_)
#define _splinepop_h_
void Splinepop(char*);
#endif

#<

#>            common.h
/*
                           COPYRIGHT (c) 1999
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/



#include    "stdio.h"        /* Defines ANSI C input and output utilities */
#include    "stdlib.h"       /* Defines the ANSI C functions for number */
                             /* conversion, storage allocation, and similar tasks.*/
#include    "string.h"       /* Declares the ANSI C string functions*/
                             /* like:strcpy, strcat etc.*/
#include    "math.h"         /* Declares the mathematical functions and macros.*/
#include    "gipsyc.h"       /* Defines the ANSI-F77 types for Fortran to C intface */
                             /* including def. of char2str,str2char,tofchar,zadd */
                             /* and macros tobool and toflog */
#include    "float.h"        /* Definition of FLT_MAX etc.*/
#include    "ctype.h"        /* Declares ANSI C functions for testing characters */
                             /* like: isalpha, isdigit etc. also tolower, toupper.*/


#include    "userint.h"      /* User input interface routines.*/
#include    "userlog.h"
#include    "userreal.h"
#include    "userdble.h"
#include    "usertext.h"
#include    "userchar.h"
#include    "usercharu.h"
#include    "userfio.h"      /* Easy-C companions of userxxx_c */
#include    "reject.h"       /* Reject user input.*/
#include    "cancel.h"       /* Remove user input from table maintained by HERMES.*/
#include    "keyevents.h"    /* Definitions for event-driven operation */
#include    "events.h"       /* Describes routines for event-driven programs.*/
#include    "eventmonitor.h" 
#include    "wkey.h"
#include    "deputy.h"
#include    "subst.h"
#include    "listctrl.h"
#include    "status.h"
#include    "setdblank.h"
#include    "setfblank.h"


#define MYMAX(a,b)     ( (a) > (b) ? (a) : (b) )
#define MYMIN(a,b)     ( (a) > (b) ? (b) : (a) )
#define BETWEEN(a,b,c) ( (a) < (b) ? (b) : ((a) > (c) ? (c) : (a) ) )

/* Pre April 09 def.: #define NINT(a)        ( (a) < 0 ? (int)((a)-.5) : (int)((a)+.5) )*/
#define NINT(a) ( (int) floor( (double) (a) + 0.5 ) )

#define ABS(a)         ( (a) < 0 ? (-(a)) : (a) )
#define PI             3.141592653589793
#define RAD(a)         ( (a) * 0.017453292519943295769237 )
#define DEG(a)         ( (a) * 57.295779513082320876798155 )
#define FSWAP(a,b) { float temp=(a);(a)=(b);(b)=temp; } /* Swap 2 floats */ 


#define MAXAXES        10         /* Max. axes in a set */
#define MAXSUBSETS     4096       /* Max. allowed subsets */
#define STRLEN         256        /* Max length of strings */
#define FILENAMELEN    256        /* Max length of file names */
#define FITSLEN        20         /* Max length of header items etc.*/
#define NOERRORLOOP    100        /* Special code for gdsinp */
#define NONE           0          /* Default levels in userxxx routines */
#define REQUEST        1
#define HIDDEN         2
#define EXACT          4
#define YES            1          /* C versions of .TRUE. and .FALSE. */
#define NO             0
#define FIRSTLINE      0
#define SECONDLINE     1
#define DEBUG          16

#define EXTRACT        1
#define NOEXTRACT      0


#define MAXPAR         1000       /* Max. number of spline control points */
#define MAXLEVELS      512        /* Max. number of contour levels */
#define MAXPSCOLS      230        /* Maximum number of cols. for PS device */

/* Slice modes */

#define LINE           0
#define ELLIPSE        1
#define SPLINE         2


/* PGPLOT colours */

#define BACKGROUND    0           /* Color definitions for PGPLOT. */
#define FOREGROUND    1           /* Black if background is white. */
#define RED           2
#define GREEN         3
#define BLUE          4
#define CYAN          5
#define MAGENTA       6
#define YELLOW        7
#define ORANGE        8
#define GREENYELLOW   9
#define GREENCYAN    10
#define BLUECYAN     11
#define BLUEMAGENTA  12
#define REDMAGENTA   13
#define DARKGRAY     14
#define LIGHTGRAY    15


#define NORMAL       1                                                          
#define ROMAN        2
#define ITALIC       3
#define SCRIPT       4

#define DOTTED       4
#define DASHED       2
#define FULL         1

#define DOTCIRCLE    9
#define SMALLCIRCLE  4
#define PLUS         2
#define STAR         3    
#define CROSS        5




/* Initialize Fortran compatible string with macro 'fmake' */

#define fmake(fchr,size) { \
                           static char buff[size+1]; \
                           int i; \
                           for (i = 0; i < size; buff[i++] = ' '); \
                           buff[i] = 0; \
                           fchr.a = buff; \
                           fchr.l = size; \
                         }


   

#define H_MOUSE_DISP     "MOU   L: Change colours  R: Profile in z-direction"
#define H_KEY_DISP       "KEY   +,shift mbl/-,ctrl mbl/0: zoom/dezoom/reset  9: pan to cursor  Arrows: pan"
#define H_MOUSE_LINE     "MOU   L: length/angle  M: move centre  R: z-profile"
#define H_KEY_LINE       "KEY   M: mark/unmark   E: erase markers  +/-/0/9/arrows: zoom&pan"
#define H_MOUSE_ELLIPSE  "MOU   L: length/angle  M: move centre  R: z-profile"
#define H_KEY_ELLIPSE    "KEY   M: mark/unmark   E: erase markers   Z: flux profile  +/-/0/9/arrows"
#define H_MOUSE_SPLINE   "MOU   L: add    R: z-prof"
#define H_KEY_SPLINE     "KEY   C: close  I: insert  D: del  M: (un)mark  E: erase markers  S: new spline  Z: flux-prof +/-/0/9/arrows"

#define CHARHEI       3.5
#define REPROJNAME    "sliceview_reproj"
#define DSSNAME       "sliceview_dss"
#define DSSREPROJNAME "sliceview_dssreproj"
#define REPROJ        3
#define DSS           4
#<

#>            helptext.h
#if !defined(_helptext_h)
#define _helptext_h

#define H_CLIP       "Set range of image values in colour bar"
#define H_EXT_CLIP   "Set range of data to display"
#define H_EXT_LOAD   "Start creating/reading external set"
#define H_CONT       "Set level(s) and properties for contour(s)"
#define H_LEVELS     "List of contour levels"
#define H_LEVCOL_T   "List of contour colours"
#define H_LEVCOL_M   "One colour for all contours"
#define H_LEVTHICK_T "List of contour widths"
#define H_LEVTHICK_M "One width for all contours"
#define H_LEVSTYLE_T "List of contour styles"
#define H_LEVSTYLE_M "One style for all contours"
#define H_LEVDRAW    "Draw contours now"
#define H_LEVOVER    "Overlay contours on all frames"
#define H_MARK_SYM   "Symbol of marker on sample"
#define H_MARK_WID   "Line width of (next) marker symbol"
#define H_MARK_SIZ   "Size of symbol (char. size) of marker on sample"
#define H_FIXCLIP    "Fix clip levels for reload or new data"
#define H__EXTSET     "Create moments data or load external set"     
#define H_FLAG       "Set properties of (next) marker"
#define H_FLAG_STY   "Line style in XV plot of (next) flag line"
#define H_FLAG_WID   "Line width in XV plot of (next) flag line"
#define H_FLAG_COL   "Colour of (next) marker and flag"
#define H_POSANG     "Position angle of sample line wrt. +Y axis"
#define H_E_POSANG   "Position angle of sample ellipse wrt. +Y axis"
#define H_E_PARANGE  "Define a segment with 2 angles in deg."
#define H_E_CENTRE   "Central pos. of ellipse, grids or phys. coords."
#define H_E_SAMPLEN1 "Length of major axis in grids"
#define H_E_SAMPLEN2 "Length of minor axis in grids" 
#define H_E_RATIO    "Ratio minor to major if coupled"
#define H_E_SAMP     "Sample separation in grids"
#define H_CENTRE     "Central pos. of line, grids or phys. coords."
#define H_SAMPLEN1   "Length of sample line in grids"
#define H_SWIDTH     "Integrate each sample over this width in grids"
#define H_INTSEP     "Integration separation in grids, default: 1"
#define H_SAMP       "Sample separation in grids"
#define H_OFFSETPA   "Fixed angle in deg. between two samples"
#define H_SAMPLEN2   "Length (grids) of second sample line"
#define H_RATION     "Ratio second to first sample length if coupled "
#define H_S_SAMP     "Sample separation along spline"
#define H__POP_ZPROF "Z-profile and flux"
#define H_STOPSUB    "Stop loading subset images"
#define H_READSUB    "Start loading again"
#endif

#<

#>            frames.h
#if !defined(_frames_h_)
#define _frames_h_
void  Frames(char *key, ident plotter, ident controls);
void MovieFrames(int newframes, int extra);
void SuppressFrame(void);
#endif
#<

#>            guilines.h
#if !defined(_guilines_h_)
#define _guilines_h_
void Guilines(char*);
#endif

#<

#>            zprof.h
#if !defined(_zprof_h_)
#define _zprof_h_
void Zprof(char*);
#endif

#<

#>            guiellipse.h
#if !defined(_guiellipse_h_)
#define _guiellipse_h_
void Guiellipse(char*);
#endif

#<

#>            guispline.h
#if !defined(_guispline_h_)
#define _guispline_h_
void Guispline(char*);
#endif

#<

#>            guicont.h
#if !defined(_guicont_h_)
#define _guicont_h_
void Guicont(char*);
#endif
#<

#>            guimark.h
#if !defined(_guimark_h_)
#define _guimark_h_
void Guimark(char*);
#endif
#<

#>            sliceview.c
/* sliceview.c -XT
                            COPYRIGHT (c) 2000
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.

*/

#include    "sliceview.h"    /* Defines a.o. the global structure to work with */
#include    "cmain.h"        /* Defines the main body of a C program with */
                             /* MAIN_PROGRAM_ENTRY and IDENTIFICATION */
#include    "gui.h"          /* Graphical user interface */
#include    "utils.h"
#include    "mouse.h"
#include    "ellsam.h"
#include    "spline.h"
#include    "pgplot.h"
#include    "pgellipse.h"
#include    "plot.h"
#include    "pgclos.h"
#include    "pgsbci.h"
#include    "dcdpos.h"
#include    "rminmax.h"
#include    "frames.h"

void getxvfromline( globaltype *g, int extract );
void getxvfromellipse( globaltype *g, int extract );
void getxvfromspline( globaltype *g );
void getsamplelen( ident id, char *key, int code, void *arg );
void displayexternalset( int indx, globaltype  *g );
void readsinglesub( int indx, globaltype  *g );
void getbox( ident id, char  *key, int   code, void  *arg );


static void getbool( ident  id,
                     char  *key,
                     int    code,
                     void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for bools.                        */
/*------------------------------------------------------------*/
{
   bool       *userval = (bool  *) arg;
   fint       nitems  = 1;
   fint       dfault  = HIDDEN;


   *userval = toflog( *userval );
   (void) userlog_c( userval,
                     &nitems,
                     &dfault,
                     tofchar(key),
                     tofchar(" ") );
   *userval = tobool( *userval );
}



static void getinterpol( ident  id,
                         char  *key,
                         int    code,
                         void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for PGINTERP=                     */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint       nitems  = 1;
   fint       dfault  = HIDDEN;
   bool       userval;
   int        indx;
   
   userval = toflog( g->pginterpol );
   (void) userlog_c( &userval,
                     &nitems,
                     &dfault,
                     tofchar(key),
                     tofchar(" ") );
   g->pginterpol = tobool( userval );


   SuppressKeyevent( getbox, "BOX=" ); 
   wkeyf( "BOX=%d %d %d %d", g->inset.blo[0], g->inset.blo[1], g->inset.bhi[0], g->inset.bhi[1] );
   getbox( NULL, "BOX=", KEYCHANGE, g ); 


   indx = g->currentframe - g->inset.nsubs;
   if (indx >= 0)
   {
      /* Display again the current external set */
      displayexternalset( indx, g );
   }
   else
   {
      /* Display again the current subset */
      readsinglesub( g->currentframe, g );
   }
   if (g->updateframe != NULL)  /* Prevent this setting if there is not a set yet! */
   {
      int i;
      for (i = 0; i < g->inset.nsubs + 3; i++)
      {
         g->updateframe[i] = 1;
      }                        
      g->updateframe[g->currentframe] = 0;                     /* Need not to be loaded later */
   }
   clearstatus();
}



static void drawconts( ident  id,
                       char  *key,
                       int    code,
                       void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: LEVDRAW= keyword handler.                         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool        draw = UserLog(key);
   int         indx;
   
   if (draw)
   {
      indx = g->currentframe - g->inset.nsubs;
      if (indx >= 0)
      {
         /* Display again the current external set */
         displayexternalset( indx, g );
      }
      else
      {
         /* Display again the current subset */
         readsinglesub( g->currentframe, g );
      }
      if (g->updateframe != NULL)  /* Prevent this setting if there is not a set yet! */
      {
         int i;
         for (i = 0; i < g->inset.nsubs + 3; i++)
         {
            g->updateframe[i] = 1;
         }                        
         g->updateframe[g->currentframe] = 0;                     /* Need not to be loaded later */    
      }
      wkeyf( key );      
   }   
}


#ifdef IFNEEDED
static void getdble( ident id,
                     char  *key,
                     int   code,
                     void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for doubles.                      */
/*------------------------------------------------------------*/
{
    double     *userval = (double *) arg;
    fint       nitems = 1;
    fint       dfault = HIDDEN;

    (void) userdble_c( userval,
                       &nitems,
                       &dfault,
                       tofchar(key),
                       tofchar(" ") );
}



static void getint( ident id,
                    char  *key,
                    int   code,
                    void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for integers.                     */
/*------------------------------------------------------------*/
{
    fint      *userval = (fint *) arg;
    fint       nitems = 1;
    fint       dfault = HIDDEN;

    (void) userint_c( userval,
                      &nitems,
                      &dfault,
                      tofchar(key),
                      tofchar(" ") );
}




static void getfloat( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for floats.                       */
/*------------------------------------------------------------*/
{
    float     *userval = (float *) arg;
    fint       nitems = 1;
    fint       dfault = HIDDEN;

    (void) userreal_c( userval,
                       &nitems,
                       &dfault,
                       tofchar(key),
                       tofchar(" ") );
}
#endif




static void activateslice( globaltype  *g )
/*------------------------------------------------------------*/
/* PURPOSE: Plot new slice and XV map etc.                    */
/*------------------------------------------------------------*/
{
   if (!g->imagesloaded)
      return;

   if (g->skipsliceupdate)
   {
      /* This routine is called after changing a frame      */
      /* with FRAME=                                        */
      /* In the slice panels one can use mouse button 1 to  */
      /* change the displayed subset in the main window.    */
      /* It is not necessary to update the xv slices then   */
      /* because nothing is changed.                        */
      g->skipsliceupdate = 0;                 /*  Reset flag*/
      return;
   }  
   if (g->slicemode == -1 || g->slicemode == 3)
   { 
      helpinstatus( g->slicemode );           /* Help text in status area */   
      return;
   }

   if (g->slicemode == LINE)
   {
      getxvfromline( g, EXTRACT );
   }
   if (g->slicemode == ELLIPSE)
   {
      getxvfromellipse( g, EXTRACT );
   }
   if (g->slicemode == SPLINE)
   {
      getxvfromspline( g );
   }
   gui_error( "" );                        /* Clean error message */
   helpinstatus( g->slicemode );           /* Help text in status area */
}



static void setupcursorinfo( char  *units,
                             int   grid2hmsdms )
/*------------------------------------------------------------*/
/* PURPOSE: Create a title for the cursor info in the main gui*/
/*------------------------------------------------------------*/
{  
   char    mes[128];
   char    units2[FITSLEN+2];
   

   if (grid2hmsdms)
   {
      sprintf( units2, "%s)", units );      
      sprintf( mes, "     GRID      VALUE (%-15.15s  HMS          DMS",
               units2 );
   }
   else
   {
      sprintf( mes, "     GRID      VALUE (%s)", units );
   }
   gui_info( FIRSTLINE, mes );
}



static void storecurrentframenumber(  ident id,
                                      char  *key,
                                      int   code,
                                      void  *arg ) 
/*------------------------------------------------------------*/
/* PURPOSE: FRAME= keyword handler. Get current frame number. */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint        framenr;
   fint        nitems = 1;
   fint        dfault = HIDDEN;
   fint        r;
   static int  oldframenr = -1;
   

   r = userint_c( &framenr,
                  &nitems,
                  &dfault,
                  tofchar("FRAME="),
                  tofchar(" ") );

   if (r == 0)
      framenr = 0;

   if (framenr < 0)
      framenr = 0;

   g->currentframe = (int) framenr;
   /*--------------------------------------------------*/
   /* If a frame is changed after a zoom action then   */
   /* we have to refresh the requested frame first.    */
   /* A refreshed frame however need not to be         */
   /* displayed by the FRAME= keyword handler in the   */
   /* routines in frames.c. A function SuppressFrame() */
   /* suppresses the event for one call.               */
   /*--------------------------------------------------*/
   
   if (g->updateframe[g->currentframe])
   {
      int indx = g->currentframe - g->inset.nsubs;
      if (indx >= 0)
      {
         /* Display again the current external set */
         displayexternalset( indx, g );
      }
      else
      {
        /* Display again the current subset */
        readsinglesub( g->currentframe, g );
      }
      g->updateframe[g->currentframe] = 0;
      SuppressFrame();
   }
   if (g->currentframe != oldframenr)
   {
      if (g->currentframe >= g->inset.nsubs)
      {
         int indx = g->currentframe - g->inset.nsubs;          
         gui_datarange( g->external[indx].clip[0], g->external[indx].clip[1] );
         gui_units( g->external[indx].dataunits );
         setupcursorinfo( g->external[indx].dataunits, g->inset.grid2hmsdms );
      }
      if (g->currentframe < g->inset.nsubs)
      {
         /* This is a movie subset */
         if (oldframenr >= g->inset.nsubs)
         {
            /* Previous was a special set */
            gui_datarange( g->inset.clip[0], g->inset.clip[1] ); 
            gui_units( g->inset.dataunits );
            setupcursorinfo( g->inset.dataunits, g->inset.grid2hmsdms ); 
         }
      }
   }
   oldframenr = g->currentframe;
/*   clearstatus();*/
}



static void setoffsetpa( ident id,
                         char  *key,
                         int   code,
                         void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for OFFSETPA=                     */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float       userval;
   fint        nitems = 1;
   fint        dfault = HIDDEN;

   (void) userreal_c( &userval,
                      &nitems,
                      &dfault,
                      tofchar(key),
                      tofchar(" ") );

    userval = putinrangedeg( userval ); /* Force in range 0..360 degrees */
    g->line[1].offsetpa = userval;      /* Offset applies only to second line */
    g->newframe = YES;                  /* Data changed -> New line plot frame */
    activateslice( g );                 /* Re-plot all */
}



static void setratio( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for RATIO= and E_RATIO=           */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float       userval;
   fint        nitems = 1;
   fint        dfault = HIDDEN;
   bool        coupled = tobool(NO);
   fint        r;


   r = userreal_c( &userval,
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );

   if (r == 0)
      userval = 1.0;
   if (userval < 0.0)
      userval = 0.0;
   if (userval > 1.0)
      userval = 1.0;
      
   if (strcmp(key, "RATIO=") == 0)
   {
      g->line[1].axratio = userval;
      coupled = UserLog("COUPLE=");
      if (coupled)
      {
         g->line[1].samplelen = g->line[0].samplelen * g->line[1].axratio;
         SuppressKeyevent( getsamplelen, "SAMPLEN2=" );
         wkeyf( "SAMPLEN2=%g", g->line[1].samplelen );
      }
   }
   if (strcmp(key, "E_RATIO=") == 0)
   {
      g->ellipse.axratio = userval;
      coupled = UserLog("E_COUPLE=");
   }

   if (coupled)
   {
      g->newframe = YES;                  /* Data changed -> New line plot frame */
      if (g->imagesloaded)
         activateslice( g );              /* Re-plot all */
   }
}




static void setpanel2( ident  id,
                       char  *key,
                       int    code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for PANEL2=                       */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool        userval;
   fint        nitems  = 1;
   fint        dfault  = HIDDEN;


   userval = toflog( NO );
   (void) userlog_c( &userval,
                     &nitems,
                     &dfault,
                     tofchar(key),
                     tofchar(" ") );

   g->panel2 = tobool( userval );
   g->newframe = YES;
   activateslice( g );
}




static void setlinegraph( ident  id,
                          char  *key,
                          int    code,
                          void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: LINEGRAPH= Keyword handler.                       */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool        userval;
   fint        nitems  = 1;
   fint        dfault  = HIDDEN;


   userval = toflog( NO );
   (void) userlog_c( &userval,
                     &nitems,
                     &dfault,
                     tofchar(key),
                     tofchar(" ") );
   g->linegraph = tobool( userval );
   activateslice( g );
}



static void zprofinfo( ident  id,
                     char  *key,
                     int    code,
                     void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: _POP_ZPROF= Keyword handler.                      */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;


   if (!UserLog(key))
   {
      (void)DescheduleKeyevent(&id);
      g->PGinfoid = initplot( "ZPROF", 1, 1 );
   }
   gui_zprof_info( 0, "Press right mouse button on a grid in main window"  );
}




static void popline( ident  id,
                     char  *key,
                     int    code,
                     void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: _POP_LINES= Keyword handler.                      */
/* This is a routine that will be executed only once. After a */
/* call the keyword event is descheduled. It will initialize  */
/* the necessary plot id's which can not be obtained before   */
/* the plot window is opened. So the gui will generate this   */
/* keyword event, the plot window will pop up and the id's    */
/* are initialized.                                           */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;


   if (!UserLog(key))
   {
      (void)DescheduleKeyevent(&id);
      g->line[0].PGplotid = initplot( "LINEPLOT1", 1, 1 );
      g->line[0].GGIplotid = GgiPlotField( "LINEPLOT1", 0, 0 );
                                                                                              
      g->line[1].PGplotid = initplot( "LINEPLOT2", 1, 1 );
      g->line[1].GGIplotid = GgiPlotField( "LINEPLOT2", 0, 0 );
      if (g->line2cursorid) DescheduleGgiPlotCursor( &(g->line2cursorid) );      
      g->line2cursorid = ScheduleGgiPlotCursor( xvcursor, g->line[1].GGIplotid, g );

      g->line[0].PGgraphid = initplot( "LINEGRAPH", 1, 1 );
      g->line[0].GGIgraphid = GgiPlotField( "LINEGRAPH", 0, 0 );

      /* The line graph of the second sample appears in the same plot */
      g->line[1].PGgraphid = g->line[0].PGgraphid;
      g->line[1].GGIgraphid = g->line[0].GGIgraphid;
   }
}



static void popellipse( ident  id,
                        char  *key,
                        int    code,
                        void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: _POP_ELLIPSE= Keyword handler.                    */
/* See 'popline' documentation above.                         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;


   if (!UserLog(key))
   {
      (void)DescheduleKeyevent(&id);
      g->ellipse.PGplotid = initplot( "ELLPLOT", 1, 1 );
      g->ellipse.GGIplotid = GgiPlotField( "ELLPLOT", 0, 0 );
      
      g->ellipse.PGgraphid = initplot( "ELLGRAPH", 1, 1 );
      g->ellipse.GGIgraphid = GgiPlotField( "ELLGRAPH", 0, 0 );
   }
}



static void popspline( ident  id,
                       char  *key,
                       int    code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: _POP_SPLINE= Keyword handler.                     */
/* See 'popline' documentation above.                         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;


   if (!UserLog(key))
   {
      (void)DescheduleKeyevent(&id);
      g->spline.PGplotid = initplot( "SPLPLOT", 1, 1 );
      g->spline.GGIplotid = GgiPlotField( "SPLPLOT", 0, 0 );

      g->spline.PGgraphid = initplot( "SPLGRAPH", 1, 1 );
      g->spline.GGIgraphid = GgiPlotField( "SPLGRAPH", 0, 0 );
   }
   gui_spl_status( 0, "Use left mouse button in movie window to add control points" );
}



static void getregridval( ident id,
                          char  *key,
                          int   code,
                          void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler REGRID=                           */
/*------------------------------------------------------------*/
{
   float     *userval = (float *) arg;
   fint       nitems = 1;
   fint       dfault = HIDDEN;
   fint       r;

   r = userreal_c( userval,
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );
   if (r == 0)
      *userval = 1.0;
   else
   {
      *userval = MYMIN( 1.0, ABS(*userval) );
   }
}




static void ellipserange( ident id,
                          char  *key,
                          int   code,
                          void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler E_PARANGE=.                       */
/* Set the range along the ellipse for wich samples must be   */
/* taken. The range is given with two angles in degrees.      */
/*------------------------------------------------------------*/
{
   globaltype *g = (globaltype*) arg;
   fint       nitems = 2;
   fint       dfault = HIDDEN;
   float      userval[2];
   fint       r;


   r = userreal_c( userval,
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );

   if (r == 0)
   {
      g->ellipse.startpa = 0.0;
      g->ellipse.endpa = 360.0;
   }
   else if (r == 1)
   {
      g->ellipse.startpa = userval[0];
      g->ellipse.endpa = 360.0;
   }
   else
   {
      g->ellipse.startpa = userval[0];
      g->ellipse.endpa =  userval[1];
   }
   activateslice( g );
}




static void setslicemode( ident  id,
                          char  *key,
                          int    code,
                          void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: SLICE= Keyword handler.                           */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint        userval = -1;
   fint        nitems  = 1;
   fint        dfault  = HIDDEN;


   /*--------------------------------------------------*/
   /* If the current plot device is not opened yet,    */
   /* then nothing will be plotted because the routines*/
   /* check if the plot id. is equal to 0. Then only   */
   /* once, the _POP_.... handler is called to initia- */
   /* lize the plot devices. This routine deschedules  */
   /* itself.                                          */
   /*--------------------------------------------------*/
   GgiHandleEvents();   /* Process hanging events first! */
   (void) userint_c( &userval,
                     &nitems,
                     &dfault,
                     tofchar(key),
                     tofchar(" ") );

   g->slicemode = MYMIN( 3, MYMAX(-1, userval) );

   if (g->slicemode == 3)
   {
      g->slicemode = -1;
   }
   if (g->slicemode == -1)
   {
      wkeyf( "FRAME=%d", g->currentframe );
   }
   else
   {
      activateslice( g );
   }
}



static void getcliplevels( settype *set )
/*------------------------------------------------------------*/
/* PURPOSE: define the range of image values that will be     */
/*          assigned the maximum range of available colour-   */
/*          numbers.                                          */
/* The default values are extracted from the set header.      */
/* If the DATMIN, DATMAX items are not available, read the    */
/* data and calculate min, max. (rminmax).                    */
/*------------------------------------------------------------*/
{
   float  minclip = fblank;
   float  maxclip = fblank;
   float  dummymin;
   float  dummymax;   
   int    i;
   bool   abslev = tobool( YES );
   float *image = NULL;


   gdst_abslevel_c( &abslev );
   for (i = 0; i < set->nsubs; i++)
   {
      fint  r1, r2;
      /*--------------------------------------------------*/
      /* Read min, max from header. If items not avail-   */
      /* able, then calculate them and update header.     */
      /* Do not use rminmax for this because this function*/
      /* tries to write in the header which a user does   */
      /* not always want.                                 */
      /*--------------------------------------------------*/

      r1 = 0;
      dummymin = dummymax = fblank;
      gdsd_rreal_c( set->Name, tofchar("DATAMIN"), &(set->subsets[i]),
                    &dummymin, &r1 );
      r2 = 0;
      gdsd_rreal_c( set->Name, tofchar("DATAMAX"), &(set->subsets[i]),
                    &dummymax, &r2 );  
                    
      if (r1 < 0 || r2 < 0)
      {
         /* Calculate from data */
         fint tid  = 0;
         fint cwlo = gdsc_fill_c( set->Name, &(set->subsets[i]), set->blo );
         fint cwhi = gdsc_fill_c( set->Name, &(set->subsets[i]), set->bhi );
         fint pixelsread;
         fint imsize = (set->bhi[0] - set->blo[0] + 1) *
                       (set->bhi[1] - set->blo[1] + 1);         

         if (image == NULL)
         {     

            image = (float *) calloc( (int) imsize, sizeof(float) );
            if (image == NULL)
            {
               char mes[128];
               sprintf( mes, "Cannot allocate %d bytes to calculate clips", imsize*sizeof(float) );
               error_status( mes, "", "" );
               return;
            }         
         }         
         gdsi_read_c( set->Name,
                      &cwlo, &cwhi,
                      image,
                      &imsize,
                      &pixelsread,
                      &tid );
         minmax1_c( image, &imsize, &dummymin, &dummymax );
      }

      /* Found a value ? */
      if (dummymin != fblank)
      {
         if (minclip == fblank)
            minclip = dummymin;
         else
         {
            if (dummymin < minclip)
               minclip = dummymin;      
         }
      }
      if (dummymax != fblank)
      {
         if (maxclip == fblank)
            maxclip = dummymax;
         else
         {
            if (dummymax > maxclip)
               maxclip = dummymax;      
         }
      }
   }
   abslev = tobool( NO );
   gdst_abslevel_c( &abslev );   
   anyoutf( DEBUG, "DEBUG (getclip) minclip, maxclip=%f %f", minclip, maxclip );
   
   /* FLT_MAX itself could cause an Hermes float read error */
   if (minclip == fblank)
      minclip = -sqrt(FLT_MAX);
   if (maxclip == fblank)
      maxclip = sqrt(FLT_MAX);
         
   
   if (minclip == maxclip)
   {
      maxclip += 1.0;
   }

   set->defclip[0] = minclip;
   set->defclip[1] = maxclip;
   
   if (image != NULL)
      free( image );  
}




static void getclip(  ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for CLIP=                         */
/* This range of image values gets the full range of available*/
/* colours.                                                   */
/* The clip is set and the program starts displaying the data.*/
/*------------------------------------------------------------*/
{
   settype *set = (settype*) arg;
   fint         nitems = 2;
   fint         dfault = HIDDEN;
   fint         r;
   float        clip[2];
   static int   first = YES;


   if (!set->exist)
   {
      error_status( "No data available to calculate clip!", 
                       "Enter set first.", "" );
      return;      
   }
   /* Open the color editor as soon as there are set, box and clip levels */
   if (first)
   {
      first = NO;
      wkeyf( "COLOR=Y" );
      GgiHandleEvents();
   }

   r = userreal_c( clip,
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );
      
   if (r == 0)
   {
      if (set->defclip[0] == fblank || set->defclip[1] == fblank)
      {
         error_status( "No data available to calculate clip!", 
                       "Enter set first.", "" );
         return;
      }
      set->clip[0] = set->defclip[0];
      set->clip[1] = set->defclip[1];      
      wkeyf( "CLIP=%.6g %.6g", set->defclip[0], set->defclip[1] );
      SuppressKeyevent( getclip, "CLIP=" );
   }
   if (r > 0)
      set->clip[0] = clip[0];
   if (r > 1)
      set->clip[1] = clip[1];

   gui_datarange( set->clip[0], set->clip[1] );
   wkeyf( "READSUB=Y" );
}




static void extclip(  ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: Keyword handler for EXTCLIP=                      */
/* Clip levels to scale external data so that we do not need  */
/* a second colour editor.                                    */
/*------------------------------------------------------------*/
{
   float *clip = (float *) arg;
   fint         nitems = 2;
   fint         dfault = HIDDEN;
   fint         r;


   clip[0] = clip[1] = fblank;
   r = userreal_c( clip,
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar("") );

   if (clip[0] < clip[1])
      FSWAP( clip[0], clip[1] );
}




void getbox( ident id,
             char  *key,
             int   code,
             void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: BOX= Process user input for a box.                */
/*------------------------------------------------------------*/
{
   fint        boxopt = 0;
   fint        dfault = HIDDEN;
   fint        showdev = DEBUG;
   fint        r;
   char        dummytxt[STRLEN+1];
   fchar       Dummytxt;
   globaltype *g=(globaltype*)arg;
   static      int first = YES;


   if (!g->inset.exist)
   {
      rejectf( "BOX=", "You cannot define a box without a set!" );
      g->boxexist = NO;
      return;                     /* Nothing changed so return old image data */
   }

   /* Check on empty strings */
   Dummytxt.l = STRLEN;
   Dummytxt.a = dummytxt;
   r = usertext_c( Dummytxt, &dfault, tofchar(key), tofchar(" ") );
   if (!r)
   {
      char   mes1[128];
      char   mes2[128];
      int    i;

      /* Prepare the default for 'gdsbox'. With option 16 */
      /* it does not accept an empty string as input.     */

      strcpy( mes1, "BOX=" );
      for (i = 0; i < g->inset.subdim; i++)
      {
         sprintf( mes2, " %d", g->inset.flo[i] );
         strcat( mes1, mes2 );
      }
      for (i = 0; i < g->inset.subdim; i++)
      {
         sprintf( mes2, " %d", g->inset.fhi[i] );
         strcat( mes1, mes2 );
      }
      wkeyf( mes1 );
      return;
   }

   dfault = REQUEST;
   boxopt = 16;
   gdsbox_c( g->inset.blo, g->inset.bhi,
             g->inset.Name, g->inset.subsets,
             &dfault,
             tofchar(key),
             tofchar(" "),
             &showdev,
             &boxopt );

   if (boxopt == -1)
   {
      /* 'gdsbox' detected an error */
      fchar   Errtxt;
      char    errtxt[STRLEN];
      fint    l;
      fint    dfault = -1;

      Errtxt.a = errtxt; Errtxt.l = STRLEN-1; clearfchar(Errtxt);
      cancel( "UCAMESSAGE=" );
      l = usertext_c( Errtxt, &dfault, tofchar("UCAMESSAGE="), tofchar("") );
      Errtxt.a[l] = '\0';

      error_status( Errtxt.a, "Enter another box.", "" );

      g->boxexist = NO;
      return;
   }
   g->boxexist = YES;
   anyoutf( DEBUG, "DEBUG (getbox): BOX=%d %d %d %d", g->inset.blo[0], g->inset.blo[1],
            g->inset.bhi[0], g->inset.bhi[1] );


   /* Calculate min and max values for the slider limits */
   if (first)
   {
      float  x1 = g->inset.blo[0],  x2 = g->inset.bhi[0];
      float  y1 = g->inset.blo[1],  y2 = g->inset.bhi[1];
      float  dx = (x2-x1+1);
      float  dy = (y2-y1+1);
      float  L;

      L = sqrt(dx*dx+dy*dy);

      g->line[0].samplelen = L/2.0;
      g->line[1].samplelen = L/2.0;
      gui_samlen( L );
      gui_e_samlen( 0.5*L );   /* Semi axes */
      g->ellipse.major =  L/4.0;
      g->ellipse.minor =  L/6.0;
      first = NO;
   }
   clearstatus();
}




static void yaxisproperties( globaltype   *g )
/*------------------------------------------------------------*/
/* PURPOSE: Return properties of the profile axis.            */
/*------------------------------------------------------------*/
{
   fint     firstsubset;
   fint     lastsubset;
   fint     axnum, cword;
   fint     r;
   fint     r1, r2;
   fchar    Headerunits;
   double   grid;

   

   axnum = g->inset.axnum[ g->inset.setdim-1 ];
   cword = getcword( g->inset.Name, axnum );
   firstsubset = g->inset.subsets[0];
   lastsubset  = g->inset.subsets[g->inset.nsubs-1];
   r = 0;
   g->yaxis.mingrid = gdsc_grid_c( g->inset.Name, &axnum, &firstsubset, &r );
   if (r < 0)
   {
      error_status( "Cannot find the minimum grid for the Y axis",
                    "Perhaps something is wrong with your set header", "" );
      g->yaxis.mingrid = 0.0;
   }
   r = 0;
   g->yaxis.maxgrid = gdsc_grid_c( g->inset.Name, &axnum, &lastsubset, &r );
   if (r < 0)
   {
      error_status( "Cannot find the maximum grid for the Y axis",
                    "Perhaps something is wrong with your set header", "" );
      g->yaxis.maxgrid = 0.0;
   }
   /* Initialize in case grtoph fails */
   g->yaxis.minph = g->yaxis.mingrid;
   g->yaxis.maxph = g->yaxis.maxgrid;

   /* For the plots we need the physical values at the boundaries */
   /* of a pixel and not at the center. */
   grid = g->yaxis.mingrid - 0.5;
   r1 = grtoph_c( g->inset.Name,
                  &cword,
                  &grid,
                  &(g->yaxis.minph)  );

   grid = g->yaxis.maxgrid + 0.5;
   r2 = grtoph_c( g->inset.Name,
                  &cword,
                  &grid,
                  &(g->yaxis.maxph)  );
   if (r1 || r2)
   {
      g->yaxis.minph = g->yaxis.mingrid;
      g->yaxis.maxph = g->yaxis.maxgrid;
   }
   Headerunits.a = g->yaxis.headerunits;
   Headerunits.l = FITSLEN;
   r = axunit_c( g->inset.Name, &axnum, Headerunits );
   if (r != 0)
   {
      strcpy( g->yaxis.headerunits, "unknown units" );
   }
   else
   {
      g->yaxis.headerunits[nelc_c(Headerunits)] = '\0';
   }
   /* Get the name of the axis */
   {
      fchar    Axname;      
      fint     r = 0;
      
      Axname.a = g->yaxis.axisname;
      Axname.l = FITSLEN;
      clearfchar( Axname );
      gdsc_name_c( Axname, g->inset.Name, &axnum, &r );
      Axname.a[nelc_c(Axname)] = '\0';
   }

   anyoutf( DEBUG, "DEBUG: minph maxph = %f %f (%s)", g->yaxis.minph, g->yaxis.maxph,
            g->yaxis.headerunits );
}



static void getset( ident  id,
                    char  *key,
                    int    code,
                    void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: INSET= keyword handler.                           */
/*------------------------------------------------------------*/
{
   globaltype *g=(globaltype*)arg;
   settype    *set = NULL;
   fint       maxaxes = MAXAXES;       /* Max num. of axes the program can deal with.*/
   fint       maxsubs = MAXSUBSETS;
   fint       class   = 1;             /* Class 1 is for applications which repeat */
   fint       showdev = DEBUG;
   fint       r1, r2;
   fint       dfault = HIDDEN+NOERRORLOOP;  /* Return immediately when error occurs */


   clearstatus();

   if (strcmp(key, "INSET=") == 0)
      set = &(g->inset);

   if (set->exist)
   {
      r1 = 0;
      gds_close_c( set->Name, &r1 );                /* Close the previous set */      
   }

   set->Name.a = set->name;
   set->Name.l = FILENAMELEN;
   set->Sethandle.a = set->handlebuf;
   set->Sethandle.l = FILENAMELEN;
   clearfchar( set->Name );
   set->subdim = 2;                  /* Require 2-dim subsets */
   set->nsubs = gdsinp_c(
                     set->Name,      /* Name of input set. */
                     set->subsets,   /* Array containing subsets coordinate words. */
                     &maxsubs,       /* Maximum number of subsets in 'subin'.*/
                     &dfault,        /* Default code as is USERxxx. */
                     tofchar(key),   /* Keyword prompt. */
                     tofchar(""),    /* Keyword message for the user. */
                     &showdev,       /* Device number (as in ANYOUT). */
                     set->axnum,     /* Array of size 'maxaxes' containing the axes numbers. */
                                     /* The first elements (upto the dimension of the subset) */
                                     /* contain the axes numbers of the subset, */
                                     /* the other ones contain the axes numbers */
                                     /* outside the subset ordered according to the */
                                     /* specification by the user. */
                     set->axcount,   /* Number of grids on axes in 'axnum' */
                     &maxaxes,       /* Max. number of axes. */
                                     /* the operation for each subset. */
                     &class,         /* Class 1 is for applications which repeat */
                     &set->subdim ); /* Dimensionality of the subsets for class 1 */

#if (0)
   {
      fint   r = 0;
      gds_handle_c( set->Sethandle, set->Name, &r );
      set->Sethandle.a[nelc_c(set->Sethandle)] = '\0';
      anyoutf( 1, "TESTING!!! Handle=%s", set->Sethandle.a );
   }
#endif

   if (set->nsubs <= 0)
   {
      fchar   Errtxt;
      char    errtxt[STRLEN];
      fint    dfault = -1;            /* Special default to get UCA message */
      fint    l;

      Errtxt.a = errtxt; Errtxt.l = STRLEN-1; clearfchar(Errtxt);
      l = usertext_c( Errtxt, &dfault, tofchar("UCAMESSAGE="), tofchar("") );
      Errtxt.a[l] = '\0';
      error_status( Errtxt.a,
                   "Check set name and existence on disk", "" );
      set->exist = NO;
      g->boxexist = NO;
      /* De-schedule mouse interaction in this window */
      if (g->maincursorid)
      {
          DescheduleGgiPlotCursor( &(g->maincursorid) );
      }
      return;
   }
   g->inset.Name.a[nelc_c(g->inset.Name)] = '\0';
   set->setdim = gdsc_ndims_c( set->Name, &setlevel );


   /*--------------------------------------------------*/
   /* For dimensions greater than 3, a problem can     */
   /* emerge if the user allows ranges for all the     */
   /* non-subset axes. First we have to check whether  */
   /* the last axis has a range. If not, reject input. */
   /*--------------------------------------------------*/   
   {
      fint    axnum;
      fint    subsetlo = set->subsets[0];
      fint    subsethi = set->subsets[set->nsubs-1];
      fint    r = 0;
      fint    cwlo, cwhi;
      fint    gridlo, gridhi;
      int     i, k;
      int     nonsubsetaxiswithrange = 0;


      for (i = set->subdim, k = 0; i < set->setdim; i++, k++)
      {
         axnum = set->axnum[ i ];
         gdsc_range_c( set->Name, &subsetlo, &cwlo, &cwhi, &r );
         r = 0;
         gridlo = gdsc_grid_c( set->Name, &axnum, &cwlo, &r ); 
         r = 0;
         gdsc_range_c( set->Name, &subsethi, &cwlo, &cwhi, &r );
         r = 0; 
         gridhi = gdsc_grid_c( set->Name, &axnum, &cwhi, &r );
         /*--------------------------------------------------*/
         /* Store the name and range of a non subset axis.   */
         /* Record if it has more than one grid on it.       */
         /*--------------------------------------------------*/         
         {
            fchar    Axname;      
            fint     r = 0;
      
            Axname.a = set->axisname[k];  /* Smallest axnum is 1! */
            Axname.l = FITSLEN;
            clearfchar( Axname );
            gdsc_name_c( Axname, set->Name, &axnum, &r );
            Axname.a[nelc_c(Axname)] = '\0';
            set->axisrange[k][0] = gridlo;
            set->axisrange[k][1] = gridhi;               
         }         
         if (gridlo != gridhi)
         {
            nonsubsetaxiswithrange++;
                        
         }
      }
      if (set->setdim > 3 && nonsubsetaxiswithrange > 1)
      {
         error_status( "Ambiguous input!",
                       "More than one non-subset axis has a grid range > 0",
                       "Specify set with only one axis with a range" );
         set->exist = NO;
         g->boxexist = NO;
         /* De-schedule mouse interaction in this window */
         if (g->maincursorid)
         {
             DescheduleGgiPlotCursor( &(g->maincursorid) );
         }
         return;         
      }
   }
  

   /*-------------------------------*/
   /* Determine edges of this frame */
   /*-------------------------------*/
   {
      fint cwlo, cwhi;                          /* Local coordinate words */
      int  m;
      r1 = 0;
      gdsc_range_c( set->Name, &setlevel, &cwlo, &cwhi, &r1 );
      r1 = r2 = 0;
      for (m = 0; m < set->setdim; m++)
      {
         set->flo[m] = gdsc_grid_c( set->Name, &set->axnum[m], &cwlo, &r1 );
         set->fhi[m] = gdsc_grid_c( set->Name, &set->axnum[m], &cwhi, &r2 );
      }
   }


   if (strcmp(key, "INSET=") == 0)
   {
      char mes[80];
      sprintf( mes, "Set ok. You entered %d subset(s)", set->nsubs );
      clearstatus();
      gui_status( mes, FIRSTLINE );
      sprintf( mes, "The V (i.e. Y) axis in your XV diagram(s) is %d pixels long",
               set->nsubs );
      gui_status( mes, SECONDLINE );
   }
   set->exist = YES;


   /*-------------------------------*/
   /* Get the units of the ampli-   */
   /* tudes for annotations. Put    */
   /* units also in gui after clip  */
   /* input field.                  */
   /*-------------------------------*/
   {
      fint    r = 0;
      fchar   Dataunits;

      Dataunits.a = set->dataunits;
      Dataunits.l = FITSLEN;
      gdsd_rchar_c( set->Name, tofchar("BUNIT"), &setlevel, Dataunits, &r );
      Dataunits.a[nelc_c(Dataunits)]  = '\0';
      if (r < 0)
         strcpy( set->dataunits, "??" );
      gui_units( set->dataunits );
   }

   /* Get the axis type and sky system */
   {
      fint   prosys, skysys, velsys, axtype;
      fchar  Ctype, Cunit, Dunit;
      fint   r;
      char   mes[128];

      fmake( Ctype, 20 ); fmake( Cunit, 20 ); fmake( Dunit, 20 );
      set->grid2hmsdms = NO;

      /* Get properties of first subset axis */
      r = 0;
      (void) sprintf( mes, "CTYPE%d", set->axnum[0] );
      gdsd_rchar_c( set->Name, tofchar(mes), &setlevel, Ctype, &r );
      if (r >= 0)
      {
         axtype = axtype_c( Ctype, Cunit, Dunit, &skysys, &prosys, &velsys );
         if (axtype == 1)   /* spatial axis longitude */
         {
            /* Get properties of second subset axis */
            r = 0;
            (void) sprintf( mes, "CTYPE%d", set->axnum[1] );
            gdsd_rchar_c( set->Name, tofchar(mes), &setlevel, Ctype, &r );
            if (r >= 0)
            {
               axtype = axtype_c( Ctype, Cunit, Dunit, &skysys, &prosys, &velsys );
               if (axtype == 2)   /* spatial axis latitude */
               {
                  if (skysys == 1)
                     set->grid2hmsdms = YES;
               }
            }
         }
      }
   }

   setupcursorinfo( set->dataunits, set->grid2hmsdms );


   /* Get the grid spacings of the subset axes */
   getgridspacings( set );

   if ( ABS(set->cdelt[0]) != ABS(set->cdelt[1]) )
   {
      error_status( "WARNING: Grid spacing x != y", "Angle is not angle in the sky", "" );
      anyoutf( 3, " " );
      anyoutf( 3, "    =============================WARNING==============================" );
      anyoutf( 3, " " );
      anyoutf( 3, "    Warning from task: %s", taskname );
      anyoutf( 3, "    No real angles for Set: [ %s ]", set->Name.a );
      anyoutf( 3, "    Grid spacing |x|=%f |y|=%f are unequal!",
                       ABS(set->cdelt[0]), ABS(set->cdelt[1]) );
      anyoutf( 3, " " );
      anyoutf( 3, "    ==================================================================" );
      anyoutf( 3, " " );
   }

   /* What are the grid and the physical ranges of the last axis */
   yaxisproperties( g );

   g->newset = YES;                           /* Disable external set buttons */
   if (strcmp(key, "INSET=") == 0)
   {
      if (!TriggerKey("BOX="))
      {
       /*  wkeyf( "BOX=%d %d %d %d",
                 set->flo[0], set->flo[1],
                 set->fhi[0], set->fhi[1] );*/
      }
      getbox( NULL, "BOX=", KEYCHANGE, g );
      getcliplevels( set );         /* Calculate default clip only for INSET= */
      /* If user did not fix these levels, empty field and allow defaults */
      if (!UserLog("FIXCLIP="))
      {
         wkeyf( "CLIP=" );
         SuppressKeyevent( getclip, "CLIP=" );
      }      
      getclip( NULL, "CLIP=", KEYCHANGE, set ); /* Set the clip and display data */
   }
}




static void startgui( void )
/*------------------------------------------------------------*/
/* PURPOSE: Get plot window sizes fom user and start gui.    */
/*------------------------------------------------------------*/
{
   fint       xysize[5];
   fint       nitems  = 5;
   fint       dfault  = HIDDEN;
   fint       r;
   int        i;

   xysize[0] = xysize[1] = 500;    /* height x width of main plot */
   xysize[2] = xysize[3] = 200;    /* h x w for line slice image */
   xysize[4] = 150;                /* height for line slice graph */
   r = userint_c( xysize,
                  &nitems,
                  &dfault,
                  tofchar("GUISIZE="),
                  tofchar("Enter window sizes in pixels:   [500 500 200 200 150]") );

   for (i = 0; i < nitems; i++)
   {
      xysize[i] = MYMAX( 1, xysize[i] );
   }
   gui( );
}



static void setmainwindow( globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: Set window and viewport for main plot window.     */
/*------------------------------------------------------------*/
{
   float    xlo, xhi, ylo, yhi;
   float    nx = (float) (g->inset.bhi[0] - g->inset.blo[0] + 1);
   float    ny = (float) (g->inset.bhi[1] - g->inset.blo[1] + 1);
   float    vpxlo, vpxhi, vpylo, vpyhi;
   float    maxvp;
   float    vplenx, vpleny;

   /* We want square pixels */
   if (nx > ny)
   {
      vplenx = 1.0;
      vpleny = ny/nx;
   }
   else
   {
      vplenx = nx/ny;
      vpleny = 1.0;
   }


   {
      float    nx1 = 0.0, nx2 = 1.0, ny1 = 0.0, ny2 = 1.0;
      float    mmxlo, mmxhi, mmylo, mmyhi;
      float    lx, ly;
      fint     mm = 2;

      pgsvp_c( &nx1, &nx2, &ny1, &ny2 );
      /* What is this viewport in mm? */
      pgqvp_c( &mm, &mmxlo, &mmxhi, &mmylo, &mmyhi );
      lx = ny*(mmxhi - mmxlo);
      ly = nx*(mmyhi - mmylo);
      if (lx > ly)
      {
         vplenx = ly/lx;
         vpleny = 1.0;
      }
      else
      {
         vpleny = lx/ly;
         vplenx = 1.0;
      }
   }

   /* Calculate a factor with which you minimize the blank space */
   /* around a plot. */
   maxvp = maxviewport( CHARHEI );

   /* Center the viewport */
   vpxlo = 0.5 * (1.0 - vplenx*maxvp);
   vpxhi = 0.5 * (1.0 + vplenx*maxvp);
   vpylo = 0.5 * (1.0 - vpleny*maxvp);
   vpyhi = 0.5 * (1.0 + vpleny*maxvp);

   pgsvp_c( &vpxlo, &vpxhi, &vpylo, &vpyhi );

   xlo = g->inset.blo[0]-0.5; xhi = g->inset.bhi[0]+0.5;
   ylo = g->inset.blo[1]-0.5; yhi = g->inset.bhi[1]+0.5;
   pgswin_c( &xlo, &xhi, &ylo, &yhi );
}



static void plotflags( XVflag  *flags, 
                       int      numflags,
                       float    sampledist,
                       float    offset,
                       fint     mainplotid,
                       fint     xvplotid,
                       float   *Xpos,
                       float   *Ypos,
                       int      ndat )
/*------------------------------------------------------------*/
/* PURPOSE: Are there any flags to plot in the XV plot?       */
/*------------------------------------------------------------*/
{
   int   i;
   fint  oldplotid;
   fint  oldcol, oldlinewidth, oldlinestyle;
   float oldchsize;   
   float wxlo, wxhi, wylo, wyhi;
   
  
   if (numflags == 0)
      return;

   pgqid_c( &oldplotid );   


   if (mainplotid < 0)
   {
      /* Not ment to write in main plot ? */
      /* Do nothing */
   }
   else
   {
      selectplot( mainplotid );   
      for (i = 0; i < numflags; i++)
      {
         float x, y;
         int   indx;
 
         /* Mark this position in movie window */
  
         indx = flags[i].index;
  
         if (indx < ndat)
         {
            x = Xpos[indx];
            y = Ypos[indx];
            plsymbol( x, y, flags[i].symbol, flags[i].size, 
                     flags[i].markwidth, flags[i].colour );
         }
      }
   }
   
  
   /* Draw a vertical line (flag) in the XV map */  

   if (xvplotid < 0)    /* Nothing to do in XV plot */
      return;

   selectplot( xvplotid );
   pgqwin_c( &wxlo, &wxhi, &wylo, &wyhi );
   pgqci_c( &oldcol );
   pgqlw_c( &oldlinewidth );
   pgqls_c( &oldlinestyle );
   pgqch_c( &oldchsize );
   

   for (i = 0; i < numflags; i++)
   {
      float Xnear;
      int   indx;      
      
      indx = flags[i].index;

      if (indx < ndat)
      {      
         Xnear = ((float) indx ) * sampledist + offset;

         setwidth( flags[i].linewidth );
         setcolor( flags[i].colour );
         setlinestyle( flags[i].linestyle );  
         setchsize( flags[i].size );         
         plmove( Xnear, wylo );
         pldraw( Xnear, wyhi );
      }
   }  
   setcolor( oldcol );
   setwidth( oldlinewidth );
   setlinestyle( oldlinestyle );   
   setchsize( oldchsize );
   selectplot( oldplotid );                 
}



static void plotxvflags( globaltype  *g,
                         int          mode )
/*------------------------------------------------------------*/
/* PURPOSE: Plot only the xv lines in current plot.           */
/*------------------------------------------------------------*/
{
   int xvid;
   
   mode--;
   if (mode == LINE)
   {        
      xvid = g->line[0].PGplotid; 
      if (g->hardcopy)
         xvid = g->PGhardcopyid;
      plotflags( g->line[0].flag, g->line[0].numflags, g->line[0].sampledist,
                 g->line[0].offmin,
                 -1, xvid,
                 g->line[0].Xpos, g->line[0].Ypos,
                 g->line[0].ndat );      
   }
   if (mode == ELLIPSE)
   {  
      xvid = g->ellipse.PGplotid;
      if (g->hardcopy)
         xvid = g->PGhardcopyid;      
      plotflags( g->ellipse.flag, g->ellipse.numflags, g->ellipse.sampledist, 0.0,
                 -1, xvid,
                 g->ellipse.Xpos, g->ellipse.Ypos,
                 g->ellipse.ndat );   
   }
   if (mode == SPLINE)
   {         
      xvid = g->spline.PGplotid;
      if (g->hardcopy)
         xvid = g->PGhardcopyid;      
      plotflags( g->spline.flag, g->spline.numflags, g->spline.sampledist, 0.0,
                 -1, xvid,
                 g->spline.XposO, g->spline.YposO,
                 g->spline.ndatO );   
   }   
}



static void dumpcurrentsubset( globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: Get current subset id. and plot it on a hardcopy  */
/*          device.                                           */
/*------------------------------------------------------------*/
{
   int framenr;
   float *image = NULL;
   fint  imsize;


   framenr = g->currentframe;
   if (framenr >= g->inset.nsubs)
   {
      error_status("Cannot dump this plot", "Plot must be one of the loaded subsets", "" );
      return;
   }
   imsize = (g->inset.bhi[0] - g->inset.blo[0] + 1) *
            (g->inset.bhi[1] - g->inset.blo[1] + 1);
   image = (float *) calloc( (int) imsize, sizeof(float) );
   if (image == NULL)
   {
      char mes[128];
      sprintf( mes, "Cannot allocate %d bytes for plot", imsize*sizeof(float) );

      error_status( mes, "", "" );
      return;
   }
   setmainwindow( g );
   {
      fint tid  = 0;
      fint cwlo = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[framenr]), g->inset.blo );
      fint cwhi = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[framenr]), g->inset.bhi );
      fint pixelsread;
      gdsi_read_c( g->inset.Name,
                   &cwlo, &cwhi,
                   image,
                   &imsize,
                   &pixelsread,
                   &tid );
      plotimage( g, image );
      plotcontour( g, image ); 
      if (g->slicemode == SPLINE)
      {         
         getxvfromspline( g );
      }
      if (g->slicemode == ELLIPSE)
      {         
         getxvfromellipse( g, YES );
      }
      if (g->slicemode == LINE)
      {         
         getxvfromline( g, YES );
      }
   }
   annotateimage( g, FOREGROUND );
   free( image );
}



static void savecolors(  ident  id,
                         char  *key,
                         int    code,
                         void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: SAVECOLORS= keyword handler.                      */
/*          Store color information for current image in the  */
/*          header of the corresponding set/subset. The infor-*/
/*          mation is compatible with the format in the GPLOT */
/*          commands storelut and getlut.                     */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   fint        subsetnr;
   fint        framenr;   
   float       red[MAXPSCOLS+1], green[MAXPSCOLS+1], blue[MAXPSCOLS+1];
   int         result;
   int         startindex;
   float       Ymin, Ymax;
   float       Xmin, Xmax;
   float       bscale, bzero;
   fchar       Setname;



   if (!g->inset.exist)
   {
      error_status( "No set entered yet...", "Specify set input first with 'Input set' in [FILE] menu", "" );
      return;
   }
   framenr = g->currentframe;


   startindex = 16; /* seems save to start with */
   gui_colormap( MAXPSCOLS, &red[1], &green[1], &blue[1], 
                 &red[0], &green[0], &blue[0] );

   Xmin = startindex + 1;                  /* Omit the blank as first element */
   Xmax = startindex + MAXPSCOLS;


   /*----------------------------------------*/
   /* Distinguish (movie) subsets and        */
   /* external (sub)sets.                    */
   /*----------------------------------------*/
   if (framenr >= g->inset.nsubs)             /* Then this is an external set */
   {
      int indx = g->currentframe - g->inset.nsubs;      
      Ymin = g->external[indx].clip[0];
      Ymax = g->external[indx].clip[1];
      Setname.a = g->external[indx].gdsname;
      Setname.l = strlen( g->external[indx].gdsname );
      subsetnr = g->external[indx].subset;
   }
   else
   {
      Setname.a = g->inset.Name.a;
      Setname.l = g->inset.Name.l;
      subsetnr = g->inset.subsets[framenr];
      Ymin = g->inset.clip[0];
      Ymax = g->inset.clip[1];      
   }


   bscale = (Ymax - Ymin) / (Xmax - Xmin);
   bzero  = Ymin - bscale*Xmin;

   result = luttotable( Setname,
                        subsetnr,
                        MAXPSCOLS+1,
                        red, green, blue,
                        startindex,
                        startindex+MAXPSCOLS,
                        MAXPSCOLS,
                        bscale, bzero,
                        startindex );
                        
   error_status( "", "Stored colour information in header of current (sub)set",
                 "" );
}





static void hardcopy( ident id,
                      char  *key,
                      int   code,
                      void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: HCFILENAME= keyword handler.                      */
/*                                                            */
/* Open a hardcopy device (printer or file) and build the     */
/* plot. Close the device afterwards and return to the main   */
/* plot on screen.                                            */
/*------------------------------------------------------------*/
{
   globaltype *g = (globaltype *) arg;
   fchar      Dummytxt;
   char       dummytxt[FILENAMELEN];
   fint       dfault, nitems, r;
   int        len;
   char       devname[FILENAMELEN+64];
   FILE       *fp;
   static int okayed = NO;


   dfault = HIDDEN;
   nitems = 1;
   Dummytxt.l = FILENAMELEN-1;
   Dummytxt.a = dummytxt;
   clearfchar( Dummytxt );
   r = userchar_c( Dummytxt, &nitems, &dfault, tofchar(key), tofchar(" ") );
   len = nelc_c(Dummytxt);
   Dummytxt.a[len] = '\0';


   if (len == 0)
   {
      error_status( "Need a PostScript file name!", "", "" );
      rejectf( key, "Need a PS file name!" );
      okayed = NO;
      return;
   }
   strcpy( g->PSname, dummytxt );

   /* Check existence */
   if (!okayed)
   {
      fp = fopen( g->PSname, "r" );
      if (fp != NULL)
      {
         error_status( "File exists!", "", "" );
         GgiPlotPrompter( "AGAIN", NULL, "Ok to overwrite? Press 'PLOT' for ok." );
         okayed = YES;
         fclose( fp );
         return;
      }
   }
   okayed = NO;

   GgiPlotPrompter( "ACCEPT", NULL, NULL );

   Dummytxt.l = FILENAMELEN-1;
   Dummytxt.a = dummytxt;
   clearfchar( Dummytxt );
   r = userchar_c( Dummytxt, &nitems, &dfault, tofchar("HCDEVICE="), tofchar(" ") );
   len = nelc_c(Dummytxt);
   Dummytxt.a[len] = '\0';
   sprintf( devname, "%s/%s", Dummytxt.a, g->PSname );
   anyoutf( DEBUG, "DEBUG (hardcopy): output: %s", devname );

   /* Start writing to the hard copy device */
   {
      fint       nitems = 1;
      fint       dfault = HIDDEN;
      fint       context;

      (void) userint_c( &context, &nitems, &dfault, tofchar("_MENUCONTEXT="), tofchar(" ") );

      if (context == MENU_MAIN)                                          /* Main window */
      {
         int   framenr = g->currentframe;
         int   indx;
         char  keyw[FITSLEN];

         g->hardcopy = YES;
         g->PGhardcopyid = initplot( devname, 1, 1 );
         if (framenr >= g->inset.nsubs)     /* An external */
         {            
            /* External sets have their own hardcopy handler */
            indx = g->currentframe - g->inset.nsubs;
            sprintf( keyw, "EXTLOAD%d=", indx );
            displayexternalset( indx, g );
         }
         else
            dumpcurrentsubset( g );
      }
      if (context > 0)
      {
         g->hardcopy = YES;
         g->PGhardcopyid = initplot( devname, 1, 1 );
         getsliceim( g, 0, YELLOW );
         plotxvflags( g, context );
      }
      pgclos_c();
      g->hardcopy = NO;
      g->PGhardcopyid = 0;
      selectplot( g->PGmainplotid );                        /* Back to screen */
   }

   /* Give an extra message that the output was written to file */
   {
      char   mes[STRLEN];
      sprintf( mes, "Hardcopy (sub)set written to: %s", g->PSname );
      error_status( "", mes, "" );
   }
}



void aftermovieaction( void )
/*------------------------------------------------------------*/
/* PURPOSE: After stopping a movie or changing a frame, take  */
/* action to redisplay arrow in mainplot.                     */
/*------------------------------------------------------------*/
{
   wkeyf( "ACTIVATE=Y" );
}




void getxcyc( ident  id,
              char  *key,
              int    code,
              void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: CENTRE= and E_CENTRE= keyword handler.            */
/* Get the slice line or ellipse centre.                      */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   double      x0y0[2];
   fint        nitems = 1;
   fint        dfault = HIDDEN;
   fint        r;


   if (!g->inset.exist)
   {
      error_status( "No set entered yet...", "Specify set input first with 'Input set' in [FILE] menu", "" );
      return;
   }
   r = gdspos_c( x0y0,
                 &nitems,
                 &dfault,
                 tofchar( key ),
                 tofchar(""),
                 g->inset.Name,
                 &(g->inset.subsets[0]) );

   if (r == 0)
   {
      wkeyf( "CENTRE=AC" );
      return;
   }

   if (strcmp(key, "CENTRE=") == 0)
   {
      g->line[0].xc =  (float) x0y0[0];
      g->line[0].yc =  (float) x0y0[1];
      getxvfromline( g, YES );
   }
   if (strcmp(key, "E_CENTRE=") == 0)
   {
      g->ellipse.xc =  (float) x0y0[0];
      g->ellipse.yc =  (float) x0y0[1];
      getxvfromellipse( g, EXTRACT );
   }
}




static void getswidth( ident  id,
                       char  *key,
                       int    code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE:(E_/S_)SWIDTH= keyword handler.                    */
/* Get the sample WIDTH in pixels.                            */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float        userval;
   fint         nitems = 1;
   fint         dfault = HIDDEN;
   fint         r;

   userval = 0.0;
   r = userreal_c( &userval,
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );

   if (strcmp(key, "SWIDTH=") == 0)
   {
      g->line[0].slicewidth = g->line[1].slicewidth = userval;
   }
   if (strcmp(key, "E_SWIDTH=") == 0) 
   {
      g->ellipse.slicewidth = userval;
   }
   if (strcmp(key, "S_SWIDTH=") == 0) 
   {
      g->spline.slicewidth = userval;
   }   
   activateslice( g );
}



static void getintsep( ident  id,
                       char  *key,
                       int    code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE:(E_/S_)INTSEP= keyword handler.                    */
/* Get the integration separation in pixels.                  */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float        userval;
   fint         nitems = 1;
   fint         dfault = HIDDEN;

   userval = 1.0;
   (void) userreal_c( &userval,
                      &nitems,
                      &dfault,
                      tofchar(key),
                      tofchar(" ") );

   if (strcmp(key, "INTSEP=") == 0)
   {
      g->line[0].intsep = g->line[1].intsep = userval;
   }
   if (strcmp(key, "E_INTSEP=") == 0) 
   {
      g->ellipse.intsep = userval;
   }
   if (strcmp(key, "S_INTSEP=") == 0) 
   {
      g->spline.intsep = userval;
   }   
   activateslice( g );
}




void getsamplelen( ident  id,
                   char  *key,
                   int    code,
                   void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: (E_)SAMPLEN1/2= keyword handler.                  */
/* Get the sample distance in pixels.                         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool         coupled;
   float        userval;
   fint         nitems = 1;
   fint         dfault = HIDDEN;


   (void) userreal_c( &userval,
                      &nitems,
                      &dfault,
                      tofchar(key),
                      tofchar(" ") );


   /* If the second panel is activated, the lengths of */
   /* the arrows can be coupled. If coupled, the slider */

   if (strcmp(key, "SAMPLEN1=") == 0)
   {
      g->line[0].samplelen = userval;
      coupled = UserLog("COUPLE=");
      if (coupled)
      {
         g->line[1].samplelen = userval * g->line[1].axratio;
         SuppressKeyevent( getsamplelen, "SAMPLEN2=" );
         wkeyf( "SAMPLEN2=%g", g->line[1].samplelen );
      }
      getxvfromline( g, YES );
   }
   if (strcmp(key, "SAMPLEN2=") == 0)
   {
         g->line[1].samplelen = userval;
         getxvfromline( g, EXTRACT );
   }

   if (strcmp(key, "E_SAMPLEN1=") == 0)
   {
      g->ellipse.major = userval;
      coupled = UserLog("E_COUPLE=");
      if (coupled)
      {
         /* Because the axratio is < 1 --> minor < major */
         g->ellipse.minor = userval * g->ellipse.axratio;
      }
      getxvfromellipse( g, EXTRACT );
   }
   if (strcmp(key, "E_SAMPLEN2=") == 0)
   {
      g->ellipse.minor = userval;
      getxvfromellipse( g, EXTRACT );
   }
}



static void getsampledist( ident  id,
                           char  *key,
                           int    code,
                           void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: SAMP= keyword handler.                            */
/* Get the sample distance in pixels.                         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float       userval = 1.0;
   fint        nitems = 1;
   fint        dfault = HIDDEN;

   (void) userreal_c( &userval,
                      &nitems,
                      &dfault,
                      tofchar(key),
                      tofchar(" ") );

   if(g->slicemode == LINE)
   {
      g->line[0].sampledist = userval;
      getxvfromline( g, EXTRACT );
   }
   if (g->slicemode == ELLIPSE)
   {
      g->ellipse.sampledist = userval;
      getxvfromellipse( g, EXTRACT );
   }
   if(g->slicemode == SPLINE)
   {
      g->spline.sampledist = userval;
      getxvfromspline( g );
   }
}



void getsampleangle( ident  id,       /* Function also called externally */
                     char  *key,
                     int    code,
                     void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: POSANG= & E_POSANG keyword handler.               */
/* Get the position angle for the line or ellipse slice.      */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float        userval;
   fint         nitems = 1;
   fint         dfault = HIDDEN;
   fint         r;


   r = userreal_c( &userval,
                   &nitems,
                   &dfault,
                   tofchar(key),
                   tofchar(" ") );

   if (r == 0)
      userval = 0.0;           /* Note this is the mathematical angle */
                                /* Astronomical 0 is mathematical 90 */
   userval += 90.0;

   if (g->slicemode == LINE)
   {
      g->line[0].angle = userval;
      getxvfromline( g, EXTRACT );
   }
   if (g->slicemode == ELLIPSE)
   {
      g->ellipse.angle = userval;
      getxvfromellipse( g, EXTRACT );
   }
}




static void plotarrows( globaltype  *g )
/*------------------------------------------------------------*/
/* PURPOSE: Plot sample arrow(s) in main plot.                */
/*------------------------------------------------------------*/
{
   int          n;
   int          i, imax;
   int          col[2];


   col[0] = YELLOW;
   col[1] = CYAN;

   if (g->panel2)
      imax = 2;
   else
      imax = 1;

   for (i = 0; i < imax; i++)
   {
      n = g->line[i].ndat;

      plarrow(  g->line[i].Xpos[0],
                g->line[i].Ypos[0],
                g->line[i].Xpos[n-1],
                g->line[i].Ypos[n-1],
                1.5, 4, col[i] );

      /* Is a width given? */
      if (g->line[i].slicewidth > 0.0)
      {
         /* Then draw a rectangle showing this width */
         float hw = g->line[i].slicewidth / 2.0;
         int   n = g->line[i].ndat;
         float p = g->line[i].dirvect[0];            /* Direction of slice */
         float q = g->line[i].dirvect[1];
         float xs = g->line[i].Xpos[0];
         float ys = g->line[i].Ypos[0];
         float xe = g->line[i].Xpos[n-1];
         float ye = g->line[i].Ypos[n-1];
         float dx = hw * (-q);
         float dy = hw * p;
         setcolor( RED );
         plmove( xs + dx, ys + dy );
         pldraw( xs - dx, ys - dy );
         pldraw( xe - dx, ye - dy );
         pldraw( xe + dx, ye + dy );
         pldraw( xs + dx, ys + dy );
      }
   }
   plsymbol( g->line[0].xc, g->line[0].yc, SMALLCIRCLE, 1, 2, RED );
}




static void wakeslice( ident  id,
                       char  *key,
                       int    code,
                       void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: ACTIVATE= keyword handler. Must be available      */
/* because a special function 'aftermovieaction' without      */
/* parameters is scheduled for when a movie stops or a frame  */
/* is changed. So a FRAME= change triggers this function.     */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;

   /* Alter number in struct. */ 
   storecurrentframenumber( NULL, "FRAME=", KEYCHANGE, g );
   activateslice( g );
   plotexternalcontour( g );
}



static void clearflags(  ident  id,
                         char  *key,
                         int    code,
                         void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: CLEARFLAGS= keyword handler.                      */
/*          Flags are positions on the sample marked both in  */
/*          the (sub)set plot and in the XVplot.              */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool        wipeflags = UserLog(key);
    

   if (wipeflags)
   {
      if (g->slicemode == LINE)
      {
         g->line[0].numflags = 0;
         free( g->line[0].flag );
         g->line[0].flag = NULL; 
         getxvfromline( g, EXTRACT );
      }
      if (g->slicemode == ELLIPSE)
      {
         g->ellipse.numflags = 0;
         free( g->ellipse.flag );
         g->ellipse.flag = NULL;          
         getxvfromellipse( g, EXTRACT );
      }
      if (g->slicemode == SPLINE)
      {
         g->spline.numflags = 0;
         free( g->spline.flag );
         g->spline.flag = NULL;
         wkeyf("SPLINE=Y");
      }
      wkeyf( key );              /* Reset button */
   } 
}



static void clearspline(  ident  id,
                          char  *key,
                          int    code,
                          void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: SPLINECLEAR= keyword handler.                     */
/* Reset 1) flags and 2) spline data.                         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool         clear = UserLog(key);

   if (clear)
   {
      if (g->spline.numflags > 0)
         g->spline.numflags = 0;

      g->spline.ndat = 0;
      getxvfromspline( g );
      wkeyf( key );
   }
}




static void readspline(  ident  id,
                         char  *key,
                         int    code,
                         void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: SPLINEIN= keyword handler.                        */
/* Read spline data from a file.                              */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   FILE        *fp;
   fchar       Filename;
   char        filename[512];
   fint        dfault = HIDDEN;
   fint        n;

   /* First get the name of the file with positions */
   Filename.a = filename;
   Filename.l = 511;
   n = usertext_c( Filename, &dfault, tofchar(key), tofchar("") );
   if (n == 0)
   {
      error_status( "Empty file name", "", "" );
      rejectf( key, "File name is empty!" );
      return;
   }
   Filename.a[nelc_c(Filename)] = '\0';
   fp = fopen( filename, "r" );
   if (fp == NULL)
   {
       error_status( "Cannot open file:", filename, "" );
       rejectf( key, "Cannot open this file!" );
       return;
   }

   n = 0;
   while (!feof(fp))
   {
      double xy[2];
      fint   maxpos = 1;
      char   posstr[512];
      fint   r;
      char   *cp;

      /* Reset string otherwise it could have contents after fgets */
      posstr[0] = '\0';
      /* 'cp' is a 2nd check whether a valid line is read */
      cp = fgets( posstr, 510, fp );            /* Newline and 0 can be added */
     
      if (cp != NULL)
      {
         /*---------------------------------------------------------*/
         /* Replace the NEWLINE that fgets reads also. The function */
         /* 'dcdpos' is sensitive to newlines and will produce an   */
         /* error condition if a string is followed by blanks and   */
         /* closed by a newline character.                          */
         /*---------------------------------------------------------*/         
         int k;
         for (k = 0; k < strlen(posstr); k++)
         {
            if (posstr[k] == '\n')
               posstr[k] = '\0';
         }
         r = dcdpos_c( g->inset.Name, &(g->inset.subsets[0]),
                       tofchar(posstr), xy, &maxpos );
      }          
      else
      {
         r = 0;
      }

      if (r == 1)
      {
         float x = (float) xy[0];
         float y = (float) xy[1];

         if (g->spline.ndat > 0)
         {
            /* Is this point different from the previous? */
            if (x != g->spline.Xpos[g->spline.ndat-1] || y != g->spline.Ypos[g->spline.ndat-1])
            {
               g->spline.Xpos[g->spline.ndat] = x;
               g->spline.Ypos[g->spline.ndat] = y;
               if (g->spline.ndat < MAXPAR-1)
               {
                  g->spline.ndat++;
                  n++;
               }
            }
         }
         else
         {
            /* First point, copy always */
            g->spline.Xpos[g->spline.ndat] = x;
            g->spline.Ypos[g->spline.ndat] = y;
            if (g->spline.ndat < MAXPAR-1)
            {
               g->spline.ndat++;
               n++;
            }
         }
      }
   }

   /* Notify user that we just read from file */
   {
      char mes[80];

      sprintf( mes, "Read %d positions from file:", n );
      error_status( "", mes, filename );
   }
   getxvfromspline( g );
}



static int sampleerror( int   num,
                        char *mes )
/*------------------------------------------------------------*/
/* PURPOSE: No sample, write error message.                   */
/*------------------------------------------------------------*/
{
   if (num == 0)
   {
      error_status( "NO SAMPLE 1 (number of points is 0)",
                    "Increase sample length or decrease sample separation", "" );
      return( YES );
   }
   if (num == -1)
   {
      error_status( mes,
                   "Select new center",  "" );
      return( YES );
   }
   if (num == -2 || num == -3)
   {
      error_status( mes,
                   "Restart with smaller sample",  "" );
      return( YES );
   }
   if (num < 0)        /* Unknown errors */
   {
      return( YES );
   }

   return( NO );
}






void getxvfromellipse( globaltype *g,
                       int         extract )
/*------------------------------------------------------------*/
/* PURPOSE: sample along ellipse                              */
/*------------------------------------------------------------*/
{
   char         mes[512];
   fint         framenr;

   static int   first = YES;

   static float xc_old, yc_old;
   static float angle_old;
   static float sampledist_old;
   static float major_old, minor_old;
   static float startpa_old, endpa_old;
   static float slicewidth_old;
   static float intsep_old;
   static float numflags_old;


   if (!g->inset.exist)
   {
      error_status( "No set entered yet...", "Specify set input first with 'Input set' in [FILE] menu", "" );
      return;
   }
   if (!g->imagesloaded)
   {
      error_status( "No images available", "", "" );
      return;
   }

   if (g->ellipse.PGplotid == 0)
      return;

   framenr = g->currentframe;

   if (first)
   {
      xc_old      = fblank;
      yc_old      = fblank;
      angle_old   = fblank;
      sampledist_old = fblank;
      minor_old   = fblank;
      major_old   = fblank;
      startpa_old = fblank;
      endpa_old   = fblank;
      slicewidth_old  = fblank;
      intsep_old  = fblank;
      numflags_old = -1;
      first = NO;
   }
   /*--------------------------------------------------*/
   /* Check whether it is really necessary to update   */
   /* the XV map.                                      */
   /*--------------------------------------------------*/
   if (g->ellipse.xc == xc_old &&
       g->ellipse.yc == yc_old &&
       g->ellipse.angle == angle_old &&
       g->ellipse.sampledist == sampledist_old &&
       g->ellipse.startpa == startpa_old &&
       g->ellipse.endpa == endpa_old &&
       g->ellipse.minor == minor_old &&
       g->ellipse.major == major_old &&
       g->ellipse.slicewidth == slicewidth_old &&
       g->ellipse.intsep == intsep_old &&
       g->ellipse.numflags == numflags_old &&
       !g->hardcopy  )
   {
/*      return;*/
   }
   else
   {
      xc_old = g->ellipse.xc;
      yc_old = g->ellipse.yc;
      angle_old = g->ellipse.angle;
      sampledist_old = g->ellipse.sampledist;
      startpa_old = g->ellipse.startpa;
      endpa_old = g->ellipse.endpa;
      minor_old = g->ellipse.minor;
      major_old = g->ellipse.major;
      slicewidth_old = g->ellipse.slicewidth;
      intsep_old = g->ellipse.intsep;
      numflags_old = g->ellipse.numflags;
   }

   if (!g->hardcopy)
   {
      selectplot( g->PGmainplotid );
      GgiPlotShow( g->mainplotGGIid, framenr );
   }

   /* Mark the center */
   plsymbol( g->ellipse.xc, g->ellipse.yc, SMALLCIRCLE, 1, 2, RED );

   setcolor( RED );
   /* Plot major and minor axis */
   {
      float r = g->ellipse.major;
      float a = g->ellipse.angle;
      float xc = g->ellipse.xc;
      float yc = g->ellipse.yc;
      float x, y;
      plmove( xc, yc );
      x = xc + r*cos(RAD(a));
      y = yc + r*sin(RAD(a));
      pldraw( x, y );
      plsymbol( x, y, 9, 1, 1, YELLOW );
      plmove( xc, yc );
      r = g->ellipse.minor;
      x = xc + r*cos(RAD(a+90.0));
      y = yc + r*sin(RAD(a+90.0));
      pldraw( x, y );
      plsymbol( x, y, 9, 1, 1, YELLOW );
   }


   {
      float  xs[MAXPAR], ys[MAXPAR];
      int    i, n ;
      int    nmax = MAXPAR;
      float  start = 0.0;
      float  end = 360.0;


      n = sampleellipse( g->ellipse.xc,
                         g->ellipse.yc,
                         g->ellipse.major,              /* SEMI major & minor */
                         g->ellipse.minor,
                         g->ellipse.sampledist,
                         g->ellipse.angle,
                         g->ellipse.startpa,
                         g->ellipse.endpa,
                         xs, ys,
                         nmax );

      g->ellipse.Xpos = (float *) calloc( n, sizeof(float) );
      g->ellipse.Ypos = (float *) calloc( n, sizeof(float) );
      for (i = 0; i < n; i++)
      {
         g->ellipse.Xpos[i] = xs[i];
         g->ellipse.Ypos[i] = ys[i];
      }
      setcolor( YELLOW );
#if (0)
      /* PGPLOT library function */
      pgellipse_c( &g->ellipse.xc,                            /* Draw Contour */
                   &g->ellipse.yc,
                   &g->ellipse.major,                   /* SEMI major & minor */
                   &g->ellipse.minor,
                   &g->ellipse.angle,
                   &start,
                   &end );
#endif
      plellipse( g->ellipse.xc,                            /* Draw Contour */
                 g->ellipse.yc,
                 g->ellipse.major,                   /* SEMI major & minor */
                 g->ellipse.minor,
                 g->ellipse.angle,
                 start,
                 end );
      plpoints( g->ellipse.Xpos, g->ellipse.Ypos, n, PLUS );       /* Markers */

{
   float hw = g->ellipse.slicewidth;
   plellipse( g->ellipse.xc,                            /* Draw Contour */
                 g->ellipse.yc,
                 g->ellipse.major+hw/2.0,                   /* SEMI major & minor */
                 g->ellipse.minor+hw/2.0,
                 g->ellipse.angle,
                 start,
                 end );
   plellipse( g->ellipse.xc,                            /* Draw Contour */
                 g->ellipse.yc,
                 g->ellipse.major-hw/2.0,                   /* SEMI major & minor */
                 g->ellipse.minor-hw/2.0,
                 g->ellipse.angle,
                 start,
                 end );
                 
}

      g->ellipse.ndat = n;
      plsymbol( g->ellipse.Xpos[0],                  /* Plot start of samples */
                g->ellipse.Ypos[0],
                12, 1, 1, RED );
   }

   if (extract && !g->hardcopy)
   {
      /* Extract data and display */
      selectplot( g->ellipse.PGplotid );
      getsliceim( g, 0, YELLOW );
      GgiPlotRecord( g->ellipse.GGIplotid, 0 );
      subsetarrow( g, 0 );
      /* Annotate the slice panels */
      sprintf( mes, "P.A.: %.1f deg --  Im. size: %d x %d",
               putinrangedeg( g->ellipse.angle - 90.0 ),
               g->ellipse.ndat,
               g->inset.nsubs );
      gui_ell_status( 0, mes );
      /* Plot intensities along sample axis at current frequency */
      /* Always redraw the labeled box */
      g->newframe = YES;
      linegraph( g );
   }
   /* Plot markers and flags */
   { 
      fint  mainid, xvid = -1;
      if (!g->hardcopy)
      {
         mainid = g->PGmainplotid;
         xvid = g->ellipse.PGplotid;
         if (g->ellipsecursorid) DescheduleGgiPlotCursor( &(g->ellipsecursorid) );      
         g->ellipsecursorid = ScheduleGgiPlotCursor( xvcursor, g->ellipse.GGIplotid, g );
      }
      else
      { 
         mainid = g->PGhardcopyid;
         xvid = -1;
      }
      plotflags( g->ellipse.flag, g->ellipse.numflags, g->ellipse.sampledist, 0.0,
                 mainid, xvid, 
                 g->ellipse.Xpos, g->ellipse.Ypos,
                 g->ellipse.ndat );
      plotexternalcontour( g ); 
   }
}



void getxvfromspline( globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: SPLINE= keyword handler.                          */
/*------------------------------------------------------------*/
{
   fint         framenr;

   if (!g->inset.exist)
   {
      error_status( "No set entered yet...", "Specify set input first with 'Input set' in [FILE] menu", "" );
      return;
   }


   if (!g->hardcopy)
   {
      framenr = g->currentframe;
      GgiPlotShow( g->mainplotGGIid, framenr );
      selectplot( g->PGmainplotid );
   }

   setcolor( RED );
   plpoints( g->spline.Xpos, g->spline.Ypos, g->spline.ndat, SMALLCIRCLE );

   if (g->spline.ndat >= 2)
   {
      char  mes[128];
      fint  ndatO;
      cubicspline( g->spline.Xpos, g->spline.Ypos, g->spline.ndat,
                   g->spline.sampledist, &(g->spline.XposO), &(g->spline.YposO),
                   &g->spline.ndatO, g->inset.blo, g->inset.bhi,
                   &(g->spline.lengrids) );

      setcolor( CYAN );
      ndatO = g->spline.ndatO;
      pgline_c( &ndatO, g->spline.XposO, g->spline.YposO );
      setcolor( YELLOW );
      plpoints( g->spline.XposO, g->spline.YposO, g->spline.ndatO, PLUS );
      
      if (!g->hardcopy)
      {
         selectplot( g->spline.PGplotid );
         getsliceim( g, 0, YELLOW );
         GgiPlotRecord( g->spline.GGIplotid, 0 );
         subsetarrow( g, 0 );
         /* Plot intensities along sample axis at current frequency */
         /* Always redraw the labeled box */
         g->newframe = YES;
         linegraph( g );

         /* Annotate the slice panels */
         sprintf( mes, "Im. size: %d x %d",
                  g->spline.ndatO,
                  g->inset.nsubs );
         gui_spl_status( 0, mes );
      }
      {
         fint  mainid, xvid = -1;
         if (!g->hardcopy)
         {
            mainid = g->PGmainplotid;
            xvid = g->spline.PGplotid;
         }
         else
         { 
            mainid = g->PGhardcopyid;
            xvid = -1;
            if (g->splinecursorid) DescheduleGgiPlotCursor( &(g->splinecursorid) );      
            g->splinecursorid = ScheduleGgiPlotCursor( xvcursor, g->spline.GGIplotid, g );
         }      
         plotflags( g->spline.flag, g->spline.numflags, g->spline.sampledist, 0.0,
                    mainid, xvid,
                    g->spline.XposO, g->spline.YposO,
                    g->spline.ndatO );
         plotexternalcontour( g ); 
      }
   }
}




void getxvfromline( globaltype *g,
                    int         extract )
/*------------------------------------------------------------*/
/* PURPOSE: LINE= keyword handler.                            */
/*------------------------------------------------------------*/
{
   char         errmes[128];
   char         mes[512];
   int          num;
   fint         framenr;

   static int   first = YES;

   static float xc_old, yc_old;
   static float angle_old;
   static float sampledist_old;
   static float offsetpa_old;
   static float samplelen_old[2];
   static float slicewidth_old;
   static float intsep_old;   
   static int   numflags_old;

   if (!g->inset.exist)
   {
      error_status( "No set entered yet...", "Specify set input first with 'Input set' in [FILE] menu", "" );
      return;
   }
   if (!g->imagesloaded)
   {
      error_status( "No images available", "", "" );
      return;
   }

   if (g->line[0].PGplotid == 0)
   {
      /*--------------------------------------------------*/
      /* Plot device not yet opened and initialized.      */
      /* Return immediately and process _POP_.... keywords*/
      /* which initializes the necessary plot devices.    */
      /*--------------------------------------------------*/
      return;
   }

   if (first)
   {
      xc_old = fblank; yc_old = fblank;
      angle_old = fblank;
      sampledist_old = fblank;
      offsetpa_old = fblank;
      samplelen_old[0] = fblank;
      samplelen_old[1] = fblank;
      slicewidth_old = fblank;
      intsep_old = fblank;
      numflags_old = -1;
      first = NO;
   }
   /* Copy data to orthogonal slice */
   g->line[1].xc = g->line[0].xc;
   g->line[1].yc = g->line[0].yc;
   g->line[1].angle =  putinrangedeg( g->line[0].angle + g->line[1].offsetpa );
   g->line[1].sampledist = g->line[0].sampledist;


   /*--------------------------------------------------*/
   /* Check whether it is really necessary to update   */
   /* the XV map.                                      */
   /*--------------------------------------------------*/
   if (g->line[0].xc == xc_old &&
       g->line[0].yc == yc_old &&
       g->line[0].angle == angle_old &&
       g->line[0].sampledist == sampledist_old &&
       g->line[1].offsetpa == offsetpa_old &&
       g->line[0].samplelen == samplelen_old[0] &&
       g->line[1].samplelen == samplelen_old[1] &&
       g->line[0].slicewidth == slicewidth_old &&
       g->line[0].intsep == intsep_old &&
       g->line[0].numflags == numflags_old &&
       !g->hardcopy )
   {
 /*     return;*/
   }
   else
   {
      xc_old = g->line[0].xc;
      yc_old = g->line[0].yc;
      angle_old = g->line[0].angle;
      sampledist_old = g->line[0].sampledist;
      offsetpa_old = g->line[1].offsetpa;
      samplelen_old[0] = g->line[0].samplelen;
      samplelen_old[1] = g->line[1].samplelen;
      slicewidth_old = g->line[0].slicewidth;
      intsep_old = g->line[0].intsep;
      numflags_old = g->line[0].numflags;
   }


   num =  getlinesampledata( g, 0, errmes );
   
   if ( sampleerror(num, errmes) )
   {
      g->line[0].ndat = 0;
      return;
   }
   else
      g->line[0].ndat = num;

   if (g->panel2)
   {
      num = getlinesampledata( g, 1, errmes );
      if (  sampleerror(num, errmes) )
      {
         g->line[1].ndat = 0;
         return;
      }
      else
         g->line[1].ndat = num;
   }

#if (0)
{
   int i;
   for (i = 0; i < g->line[0].ndat; i++)
   {
      anyoutf( 1, "%f %f", g->line[0].Xpos[i], g->line[0].Ypos[i] );
   }
}
#endif


   /* Get slice data and display only if wanted */

   if (!g->hardcopy) 
   {
      selectplot( g->PGmainplotid );
      framenr = g->currentframe;
      GgiPlotShow( g->mainplotGGIid, framenr );
   }


   if (!extract)
   {
      /* Plot the arrows only */
      plotarrows( g );
   }
   else
   {
      if (!g->hardcopy)
      {
         plotarrows( g );         
         /* Extract data and display */
         selectplot( g->line[0].PGplotid );
         getsliceim( g, 0, YELLOW );
         GgiPlotRecord( g->line[0].GGIplotid, 0 );
         subsetarrow( g, 0 );
   
         /* Annotate the slice panels */
         sprintf( mes, "P.A.: %.1f deg --  Im. size: %d samples x %d subsets",
                  putinrangedeg( g->line[0].angle - 90.0 ),
                  g->line[0].ndat,
                  g->inset.nsubs );

         gui_line_status( 0, mes );
 
         /* If user wants, it is possible to sample along the orthogonal also */
         if (g->panel2)
         {
            selectplot( g->line[1].PGplotid );
            getsliceim( g, 1,  CYAN );
            GgiPlotRecord( g->line[1].GGIplotid, 0 );
            subsetarrow( g, 1 );
            sprintf( mes, "P.A.: %.1f deg. -- Im. size: %d samples x %d subsets",
                     putinrangedeg( g->line[1].angle - 90.0 ),
                     g->line[1].ndat,
                     g->inset.nsubs );
            gui_line_status( 2, mes );         
         }
         /* Plot intensities along sample axis at current frequency */
         /* Always redraw the labeled box */
         g->newframe = YES;
         linegraph( g );
      }
      else
      {  fint oldplotid;
         pgqid_c( &oldplotid );
         plotarrows( g );
      }

      {
         fint  mainid, xvid = -1;
         if (!g->hardcopy)
         {
            mainid = g->PGmainplotid;
            xvid = g->line[0].PGplotid;
            if (g->line1cursorid) DescheduleGgiPlotCursor( &(g->line1cursorid) );
            g->line1cursorid = ScheduleGgiPlotCursor( xvcursor, g->line[0].GGIplotid, g );
         }
         else
         { 
            mainid = g->PGhardcopyid;
            xvid = -1;
         }            
         plotflags( g->line[0].flag, g->line[0].numflags, g->line[0].sampledist,
                    g->line[0].offmin,
                    mainid, xvid,
                    g->line[0].Xpos, g->line[0].Ypos,
                    g->line[0].ndat );
         plotexternalcontour( g ); 
      }     
   }
}



static void readsub( ident  id,
                     char  *key,
                     int    code,
                     void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: READSUB= keyword handler.                         */
/* Read and display all subsets and store these images as     */
/* bitmaps. The is also a function 'readsinglesub' which      */
/* reads and displays only one subset.                        */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   bool        loadimages = UserLog(key);
   char        mes[512];
   fint        cword, axnum;


   if (loadimages)
   {
      int   i;
      int   nsubs = g->inset.nsubs;
      int   nframes;
      float *image = NULL;
      fint  imsize;
      bool  stopload = NO;

      clearstatus();
      
      /* Is there something to reload? */
      if (!g->inset.exist || !g->boxexist ||  g->inset.nsubs < 0)
      {
         error_status( "Nothing to (re)load!", "Specify set/subsets first", "" );
         wkeyf( key );
         g->imagesloaded = NO;
         return;
      }    
     
    
      /* Ask for frames only if something in the set input has changed */     
      if (g->newset)  
      {
         nframes = gui_xyframes( nsubs );
         anyoutf( DEBUG, "DEBUG (readsub) %s: Requested %d frames. The program reserved %d frames",
                  taskname, nsubs, nframes );
         if (nsubs > nframes)
         {
            char  mes1[80];
            char  mes2[80];
 
            sprintf( mes1, "Could not store all (%d) subsets, not enough display memory!", nsubs );
            sprintf( mes2, "Select at most %d subsets in your 'Input set' window,",
                     nframes );
            error_status( mes1, mes2, "or find a machine with more display memory." );
            wkeyf( key );
            return;
         }
         g->newset = NO;
         if (g->updateframe != NULL)
         {
            free( g->updateframe );
         }
         g->updateframe = (int *) calloc( nsubs+3, sizeof(int) );
         if (g->updateframe == NULL)
         {
             anyoutf( 3, "Cannot allocate memory for frame update array" );
             wkeyf( key ); 
             return;    
         }         
      }
      imsize = (g->inset.bhi[0] - g->inset.blo[0] + 1) *
               (g->inset.bhi[1] - g->inset.blo[1] + 1);
      image = (float *) calloc( (int) imsize, sizeof(float) );
      if (image == NULL)
      {
         anyoutf( 3, "Cannot allocate %d bytes for subset(s)", imsize*sizeof(float) );
         wkeyf( key );
         return;
      }
      selectplot( g->PGmainplotid );
      clearpage();
      /* Set window and viewport and annotate subset image with */
      /* coordinate labels. */
      setmainwindow( g );
      annotateimage( g, FOREGROUND );

      axnum = g->inset.axnum[ g->inset.setdim-1 ];
      cword = getcword( g->inset.Name, axnum );

      sprintf( mes, "Loading %d subsets...", nsubs );
      gui_status( mes, FIRSTLINE );
      for (i = 0; (i < nsubs) && !stopload; i++)
      {
         fint    tid  = 0;
         fint    cwlo = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[i]), g->inset.blo );
         fint    cwhi = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[i]), g->inset.bhi );
         fint    pixelsread;
         fint    grid;
         fint    r;
         char    mes[80];


         r = 0;
         grid = gdsc_grid_c( g->inset.Name,
                             &(g->inset.axnum[g->inset.setdim-1]),
                             &(g->inset.subsets[i]), &r );

         /* Inform the user */
         if (nsubs > 1)
            sprintf( mes, "Loading frame %d from %d subsets", i+1, nsubs );
         else
            sprintf( mes, "Loading frame from set: [ %s ]", g->inset.Name.a );
         hermesstatus( mes );
         gdsi_read_c( g->inset.Name,
                      &cwlo, &cwhi,
                      image,
                      &imsize,
                      &pixelsread,
                      &tid );
         plotimage( g, image );
         /* Display subset grid in physical value in plot in main gui */
         if (g->inset.setdim > 2)
         {
            fint    r;
            double  dgrid = (double) grid;
            double  phys;
            r = grtoph_c( g->inset.Name, &cword, &dgrid, &phys  );
            if (r == 0)
            {
               sprintf( mes, "subset[%d]:  grid %+4d = % 12.5g (%s)",
                        i, grid, phys,
                        g->yaxis.headerunits );
            }
            else
            {
                sprintf( mes, "subset grid: %+4d", grid );
            }
         }
         else
         {
            if (g->inset.setdim == 2)
               sprintf( mes, "Set: [ %s ]", g->inset.Name.a );
         }
         setchmm( CHARHEI-0.4 );
         labelsubset( mes, GREEN );
        
         /* Do we have to plot a contour? */
         plotcontour( g, image );        
        
         /* Record */
         GgiPlotRecord( g->mainplotGGIid, i );
         /* Wipe label */
         labelsubset( mes, BACKGROUND );
         /* Allow user to abort the loading of data */
         GgiHandleEvents();
         stopload = UserLog("STOPSUB=");
         if (stopload)
         {
            g->imagesloaded = NO;
            free( image );
            error_status( "Aborted load process!", "Please reload", "" );
            wkeyf( key );
            wkeyf("STOPSUB=NO");
            return;
         }
      }
      if (nsubs > 1)
      {
         sprintf( mes, "Loaded %d subsets from set [ %s ]", nsubs, g->inset.Name.a );
      }
      else
      {
         if (g->inset.setdim == 2)
            sprintf( mes, "Loaded set [ %s ]", g->inset.Name.a );
         else
            sprintf( mes, "Loaded 1 subset from set [ %s ]", g->inset.Name.a );
      }
      gui_status( mes, FIRSTLINE );
      if ( ABS(g->inset.cdelt[0]) != ABS(g->inset.cdelt[1]) )
      {
         gui_error( "WARNING: Grid spacing in X and Y not equal!" );
      }
      hermesstatus( "" );
      /* Display first recorded image */
      GgiPlotShow( g->mainplotGGIid, 0 );


      /* Set frame and activate a sample */
      wkeyf( "FRAME=0");

      free( image );
      g->newframe = YES;

      /* Schedule mouse interaction in this window */
      if (g->maincursorid)
      {
         DescheduleGgiPlotCursor( &(g->maincursorid) );
      }
      g->maincursorid = ScheduleGgiPlotCursor( cursor,
                                               GgiPlotField("XYPLOT",0,0),
                                               g );
      wkeyf( key );
      g->imagesloaded = YES;
      
   }
}


void readsinglesub( int          subsetindx,
                    globaltype  *g )                    
/*------------------------------------------------------------*/
/* PURPOSE: Read and display one subsets and store this images*/
/* as a bitmap.                                               */
/*------------------------------------------------------------*/
{
   fint        cword, axnum;


   {
      float *image = NULL;
      fint  imsize;
   
      clearstatus();
      
      /* Is there something to reload? */
      if (!g->inset.exist || !g->boxexist ||  g->inset.nsubs < 0)
      {
         error_status( "Nothing to (re)load!", "Specify set/subsets first", "" );
         g->imagesloaded = NO;
         return;
      }    
     
      imsize = (g->inset.bhi[0] - g->inset.blo[0] + 1) *
               (g->inset.bhi[1] - g->inset.blo[1] + 1);
      image = (float *) calloc( (int) imsize, sizeof(float) );
      if (image == NULL)
      {
         anyoutf( 3, "Cannot allocate %d bytes for subset(s)", imsize*sizeof(float) );
         return;
      }
      selectplot( g->PGmainplotid );
      clearpage();
      /* Set window and viewport and annotate subset image with */
      /* coordinate labels. */
      setmainwindow( g );
      annotateimage( g, FOREGROUND );

      axnum = g->inset.axnum[ g->inset.setdim-1 ];
      cword = getcword( g->inset.Name, axnum );      
    
      {
         fint    tid  = 0;
         fint    cwlo = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[subsetindx]), g->inset.blo );
         fint    cwhi = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[subsetindx]), g->inset.bhi );
         fint    pixelsread;
         fint    grid;
         fint    r;
         char    mes[80];


         r = 0;
         grid = gdsc_grid_c( g->inset.Name,
                             &(g->inset.axnum[g->inset.setdim-1]),
                             &(g->inset.subsets[subsetindx]), &r );

         gdsi_read_c( g->inset.Name,
                      &cwlo, &cwhi,
                      image,
                      &imsize,
                      &pixelsread,
                      &tid );
         plotimage( g, image );
         /* Display subset grid in physical value in plot in main gui */
         if (g->inset.setdim > 2)
         {
            fint    r;
            double  dgrid = (double) grid;
            double  phys;
            r = grtoph_c( g->inset.Name, &cword, &dgrid, &phys  );
            if (r == 0)
            {
               sprintf( mes, "subset[%3d]:  grid %+4d = % 12.5g (%s)",
                        subsetindx, grid, phys,
                        g->yaxis.headerunits );
            }
            else
            {
                sprintf( mes, "subset grid: %+4d", grid );
            }
         }
         else
         {
            if (g->inset.setdim == 2)
               sprintf( mes, "Set: [ %s ]", g->inset.Name.a );
         }
         setchmm( CHARHEI-0.4 );
         labelsubset( mes, GREEN );
        
         /* Do we have to plot a contour? */
         plotcontour( g, image );        
        
         /* Record */
         GgiPlotRecord( g->mainplotGGIid, subsetindx );
      }
      
      /* Set frame and activate a sample */
/*      wkeyf( "FRAME=%d", subsetindx );*/ 
           
      g->newframe = YES;
      activateslice( g );      
      free( image );      
   }
}



static void readexternalimage( float  *image,
                               fchar   Set,
                               fint    subset,
                               fint   *blo,
                               fint   *bhi,
                               float  *dmin,
                               float  *dmax )
/*------------------------------------------------------------*/
/* PURPOSE: Read data from this (external, i.e. not movie) set*/
/*          and calculate the minimum and maximum values.     */
/*------------------------------------------------------------*/ 
{
   fint  tid  = 0;
   fint  cwlo = gdsc_fill_c( Set, &subset, blo );
   fint  cwhi = gdsc_fill_c( Set, &subset, bhi );
   fint  pixelsread = 0;
   int   i;
   float datmin, datmax;
   fint  imsize;

   imsize = (bhi[0] - blo[0] + 1) * (bhi[1] - blo[1] + 1); 
   gdsi_read_c( Set,
                &cwlo, &cwhi,
                image,
                &imsize,
                &pixelsread,
                &tid );

   datmin = FLT_MAX; datmax = FLT_MIN;
   for (i = 0; i < pixelsread; i++)
   {
      float v = image[i];
      if (v != fblank)
      {
         if (v > datmax )
            datmax = v;
         if (v < datmin)
            datmin = v;
      }
   }
   *dmin = datmin;
   *dmax = datmax;
}



void displayexternalset( int         indx,
                         globaltype  *g )
/*------------------------------------------------------------*/
/* PURPOSE: Load data from this external set and display.     */
/*------------------------------------------------------------*/
{
   fint  nsubs;
   fchar Extset;
   fint  maxsubs = 1;
   fint  axnum[MAXAXES];
   fint  axcount[MAXAXES];
   fint  maxaxes = MAXAXES;
   fint  subdim = 2;
   fint  class = 1;
   float *image = NULL;
   fint  imsize;
   fint  subset;
   fint  dfault;   
   fint  showdev = DEBUG;
   float datmin, datmax;
   int   i;
   float m, b;                   /* Clip scaling */
   

   g->external[indx].exist = NO;

   Extset.a = g->external[indx].gdsname;
   Extset.l = FILENAMELEN;

   if (g->hardcopy)
   {
      /* Set length to already existing name length */
      subset = g->external[indx].subset;
   }
   else
   {
      char   key[20];
      int    moment = g->external[indx].type;
      fint   r = 0;
      
      strcpy( key, "DUMMYSET=" ); 
      cancel_c( tofchar(key) );     
      if (moment == 0 || moment == 1 || moment == 2)
      {
         if ( !gds_exist_c(Extset, &r) ) 
         {
            error_status( "No set available", "Perhaps MOMENTS failed to create output", "" );
            return;
         }
         /* Add specific subset to name. Remember, the set dim.  */
         /* can be greater than 3 */
         if (g->inset.setdim > 3)
         {
            int   i, k;            
            for (i = g->inset.subdim, k = 0; i < g->inset.setdim; i++, k++)
            {
               /* Not a repeat axis */
               if (g->inset.axisrange[k][0] == g->inset.axisrange[k][1])
               {
                  char  mes[20];
                  sprintf( mes, " %s %d", g->inset.axisname[k], 
                                          g->inset.axisrange[k][0] );
                  strcat( g->external[indx].gdsname, mes );
               }
            }
         }         
         strcat( g->external[indx].gdsname, " param 0" );
      }
      if (g->external[indx].type == REPROJ )
      {
         if ( !gds_exist_c(Extset, &r) ) 
         {
            error_status( "No set available", "Perhaps REPROJ failed to create output", "" );
            return;
         }         
      }
      if (g->external[indx].type == DSS )
      {
         if ( !gds_exist_c(Extset, &r) ) 
         {
             error_status( "No set available", "Perhaps DSS failed to create output", "" );            
             return;             
         }
      }


      dfault = HIDDEN+NOERRORLOOP;  /* Return immediately when error occurs */
      nsubs = gdsinp_c( Extset, &subset, 
                        &maxsubs, 
                        &dfault,
                        tofchar(key),
                        tofchar(""), 
                        &showdev, 
                        axnum, 
                        axcount, &maxaxes, 
                        &class, &subdim );
      if (nsubs <= 0)
      {
         fchar   Errtxt;
         char    errtxt[STRLEN];
         fint    dfault = -1;            /* Special default to get UCA message */
         fint    l;

         Errtxt.a = errtxt; Errtxt.l = STRLEN-1; clearfchar(Errtxt);
         l = usertext_c( Errtxt, &dfault, tofchar("UCAMESSAGE="), tofchar("") );
         Errtxt.a[l] = '\0';
         error_status( Errtxt.a, "Check set input syntax", "" );
         return;
      }                        
      Extset.a[nelc_c(Extset)] = '\0';
      g->external[indx].subset = subset;
      
      /* Get the data units for this data */
      {
         fint    r = 0;
         fchar   Dataunits;

         Dataunits.a = g->external[indx].dataunits;
         Dataunits.l = FITSLEN;
         gdsd_rchar_c( Extset, tofchar("BUNIT"), &subset, Dataunits, &r );
         Dataunits.a[nelc_c(Dataunits)]  = '\0';
         if (r < 0)
            strcpy( g->external[indx].dataunits, "??" );
         gui_units( g->external[indx].dataunits );
         setupcursorinfo( g->external[indx].dataunits,g->inset.grid2hmsdms );
      }     
   }
   imsize = (g->inset.bhi[0] - g->inset.blo[0] + 1) *
            (g->inset.bhi[1] - g->inset.blo[1] + 1);

   image = (float *) calloc( (int) imsize, sizeof(float) );
   if (image == NULL)
   {
      anyoutf( 3, "Cannot allocate %d bytes for subset(s)", imsize*sizeof(float) );
      return;
   }

   if (g->hardcopy)
   {
      selectplot( g->PGhardcopyid );
      setmainwindow( g );
   }
   else
   {
      selectplot( g->PGmainplotid );
      setmainwindow( g );
      /* Window and viewport already set */
      /* It is not possible to load external sets if there is not */
      /* a set in the main/movie window */
   }   
   
   readexternalimage( image, 
                      Extset, subset, 
                      g->inset.blo, 
                      g->inset.bhi, 
                      &datmin, &datmax );

   /* Scale this data using clip levels from user */
   if (!g->hardcopy)
   {
      /* Read the clip keyword */
      fint r, nitems = 2, dfault = HIDDEN;   
      float clip[2];
      char keyw[FITSLEN];

      sprintf( keyw, "EXTCLIP%d=", indx );
      r = userreal_c( clip,
                      &nitems,
                      &dfault,
                      tofchar( keyw ),
                      tofchar("") );
                         
      if (r == 0)
      {
         /* Not set by the user */
         g->external[indx].clip[0] = datmin;
         g->external[indx].clip[1] = datmax;
         /* Update the input field */
         wkeyf( "%s%g %g", keyw, g->external[indx].clip[0], g->external[indx].clip[1] );
      }                         
      if (r == 1)
      {
         /* One value, a real clip with no upper value. */
         /* For the colour range the 'datmax' will be the upper limit. */
         g->external[indx].clip[0] = clip[0]; 
         g->external[indx].clip[1] = datmax;
         wkeyf( "%s%g %g", keyw, g->external[indx].clip[0], g->external[indx].clip[1] );
      }
      if (r == 2)
      {
         /* Two values, update the colour editor with new labels */
         if (clip[0] > clip[1])
            FSWAP( clip[0], clip[1] );                       
         g->external[indx].clip[0] = clip[0];
         g->external[indx].clip[1] = clip[1];
      }
      gui_datarange( g->external[indx].clip[0], g->external[indx].clip[1] );      
   }       
   if (g->external[indx].clip[0]  == g->external[indx].clip[1] &&
       g->external[indx].clip[0] != fblank)
   {
      /* You cannot scale with equal clip levels. Add an amount */
      /* to one of the levels and continue. */
      g->external[indx].clip[1] += 1.0;
   } 
          
   if (g->external[indx].clip[0] != fblank && g->external[indx].clip[1] != fblank )
   {
      m =  (g->inset.clip[1] - g->inset.clip[0]) / (
                  g->external[indx].clip[1] - g->external[indx].clip[0]);
      b = g->inset.clip[0] - m * g->external[indx].clip[0];
   }
   else
   {
      m = 1.0;
      b = 0.0;
   }

   /* Actual rescaling */
   for (i = 0; i < imsize; i++)
   {
      if (image[i] != fblank)
         image[i] = m * image[i] +b;
   }
   g->external[indx].exist = YES;

   /* Plot the image */
   clearpage();
   plotimage( g, image );
   annotateimage( g, FOREGROUND );   /* Plot the same labeled box as in subsets */

   labelsubset( g->external[indx].origname, RED );
   
   if (!g->hardcopy)  /* Record */
   {
      /* At this moment the FRAME= keyword is not yet updated */
      /* by function 'frames.c'. Then we have to calculate    */
      /* the frame number ourselves. The frame keyword will   */
      /* be updated later.                                    */
      /* previous alternative:                                */
      /* r = userfint( (fint *) &(g->currentframe), 1, HIDDEN, "FRAME=", "" );*/

      g->currentframe = g->inset.nsubs + indx;
      GgiPlotRecord( g->mainplotGGIid, g->currentframe );
   }
   plotexternalcontour( g );
   activateslice( g );
   {
      char mes[128];
      sprintf( mes, "%+g to %+g (%s) is data range for [%s]", 
               g->external[indx].clip[0], g->external[indx].clip[1], 
               g->inset.dataunits, g->external[indx].origname );
      error_status( "", mes, 
          "Use numbered buttons to toggle between subsets and external set" );
   }
   free( image );   
}



static int makemomentset( int         indx,
                          globaltype  *g )
/*------------------------------------------------------------*/
/* PURPOSE: Make a moments map using task MOMENTS             */
/*------------------------------------------------------------*/
{
   fint    moment;


   if (g->inset.nsubs < 2 || g->inset.setdim < 3)
   {
      error_status( "Not enough subsets to calculate moments!","", "" );
      return( 0 );
   }
   moment = g->external[indx].type;

   if (moment >= 0 && moment <= 2)
   {
      fint  r;
      char  *outset = g->external[indx].gdsname;
      int   deputyresult = 0;
      int   i, k;
      
      r = 0;
      if (gds_exist_c(  tofchar(outset), &r )) 
      {
         r = 0;
         gds_delete_c( tofchar(outset), &r ); 
      }
      
      /*----------------------------------------*/
      /* Prepare the MOMENTS keywords.          */
      /* The BOX and INSET= keywords for MOMENTS*/
      /* can be copied from the same keywords   */
      /* for the main set. However, it could be */
      /* that they are substituded by a previous*/
      /* call (deputy) to REPROJ. Therefore they*/
      /* need to be 'unsubstituted' first.      */ 
      /*----------------------------------------*/
      for (i = g->inset.subdim, k = 0; i < g->inset.setdim; i++, k++)
      {
         /* Is this the moments 'repeat axis'? */
         if (g->inset.axisrange[k][0] != g->inset.axisrange[k][1])
            break;
      }
      wkeyf( "MOMSET=%s %s %d:%d", 
              g->inset.Name.a,
              strtok(g->inset.axisname[k], " -"),
              g->inset.axisrange[k][0], g->inset.axisrange[k][1] );

      r = 0;
      subst_c( tofchar("INSET=MOMSET="), &r );
      

      /*--------------------------------------------------*/
      /* Create a moments set for the entire area, so use */
      /* the flo/fhi values for the box.                  */
      /* This makes zooming possible.                     */
      /*--------------------------------------------------*/
      {     
         char mes[20];
         char  boxlostr[64];         
         char  boxhistr[64];
         
         strcpy( boxlostr, "" );
         strcpy( boxhistr, "" );         
         for (i = 0; i < g->inset.subdim; i++)
         {
            sprintf( mes, " %d", g->inset.flo[i] );
            strcat( boxlostr, mes );
            sprintf( mes, " %d", g->inset.fhi[i] );
            strcat( boxhistr, mes );            
         } 
         if (g->inset.setdim > 3)
         {
            for (i = g->inset.subdim, k = 0; i < g->inset.setdim; i++, k++)
            {
               /* Not a repeat axis */
               if (g->inset.axisrange[k][0] == g->inset.axisrange[k][1])
               {
                  sprintf( mes, " %d", g->inset.axisrange[k][0] );
                  strcat( boxlostr, mes );
                  strcat( boxhistr, mes );               
               }
            }
         }
         wkeyf( "MOMBOX=%s %s", boxlostr, boxhistr );
         r = 0;
         subst_c( tofchar("BOX=MOMBOX="), &r ); 
      }

      wkeyf( "OPTION=%d", moment );
      wkeyf( "OUTSET=%s", outset );
      wkeyf( "RANGE=" );
      wkeyf( "WINDOW=" );
      wkeyf( "WINMODE=" );
      deputyresult = deputyC( "MOMENTS", 0 );
      if (deputyresult != 1)   /* i.e. not successful */
      {
         char mes[80];
         deputyerror( deputyresult, mes );
         error_status( "Could not deputy task MOMENTS", mes, "" );
         return( 0 );
      }
      if (moment == 0)
      {
         error_status( "", "Sum of profile amplitudes (zeroth moment)", "" );
      }
      else if (moment == 1)
      {
         error_status( "", "Intensity weighted mean of physical coordinates",
                           "along profile (first moment)" );
      }
      else if (moment == 2)
      {
         error_status( "", "Dispersion in intensity weighted physical",
                           "coordinates along profile (second moment)" );
      }
   }
   else
   {
      return( 0 );    /* Not a moment */
   }   
   return( 1 );       /* Success */
}



static int reprojectset( char  *inputset,
                         char  *outputset,
                         fint  *arealo,
                         fint  *areahi )
/*------------------------------------------------------------*/
/* PURPOSE: Reproject an external set using task REPROJ       */
/*------------------------------------------------------------*/
{
   fint    r;
   int     deputyresult = 0;
       
   wkeyf( "REPROJSET=%s", inputset );
   /*----------------------------------------*/
   /* 1) store the name of the external set  */
   /*----------------------------------------*/      
   r = 0; subst_c( tofchar("INSET=REPROJSET="), &r );
      
   /*----------------------------------------*/
   /* 2) Tell REPROJ that it can use the en- */
   /* tire set to reproject but leave origi- */
   /* nal BOX= keyword unaltered.            */
   /*----------------------------------------*/      
   r = 0; subst_c( tofchar("BOX=V_BOX="), &r );
   wkey_c( tofchar("V_BOX=") ); 
      
   /*----------------------------------------*/      
   /* 3) We want the sky- and projection sys-*/
   /* tems from the set displayed in the     */
   /* movie window.                          */
   /*----------------------------------------*/      
   r = 0; subst_c( tofchar("DEFSET=INSET="), &r );

   /*----------------------------------------*/
   /* 4) Give reprojected image a name       */
   /* followed by the frame/index number     */
   /* If the reprojected set exists from a   */
   /* previous run, delete it first.         */
   /*----------------------------------------*/
   {
      wkeyf( "OUTSET=%s", outputset );
      r = 0;
      if (gds_exist_c( tofchar(outputset), &r)) 
      {
         r = 0;
         gds_delete_c( tofchar(outputset), &r ); 
      }
   }
   /*----------------------------------------*/           
   /* 5) We want the same box as the start   */
   /* set in DEFSET=                         */
   /* Use the entire area to make zooming    */
   /* possible.                              */
   /*----------------------------------------*/
   wkeyf( "OUTBOX=%d %d %d %d", arealo[0], arealo[1], areahi[0], areahi[1] );
                                   
   /*----------------------------------------*/
   /* Other REPROJ keywords.                 */
   /*----------------------------------------*/                  
   wkeyf( "DATAMODE=" );                              
   wkeyf( "SPEEDMAT=" );
   deputyresult = deputyC( "REPROJ", 0 );
   
   /*----------------------------------------*/
   /* Things could go wrong if REPROJ was    */
   /* started with a non spatial set. It     */
   /* aborts but the deputy routine then     */
   /* fails to recognize the problem. So we  */
   /* always have to check for the existence */
   /* of a reprojected set.                  */
   /*----------------------------------------*/

   if (deputyresult != 1)   /* i.e. not successful */      
   {
      char mes[80];
      deputyerror( deputyresult, mes );      
      error_status( "Could not deputy task REPROJ", mes, "" );
      return( 0 );
   }
   return( 1 );     /* success */
}




static void drawextcont( ident  id,
                         char  *key,
                         int    code,
                         void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: LEVDRAW0/1/2= keywords handler. Recall current    */
/* image and draw contours over it.                           */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   char        numstr[2];
   int         indx;
   bool        draw = UserLog(key); 
  
   
   if (draw)
   {
      numstr[0] = key[strlen("LEVDRAW")];
      numstr[1] = '\0';
      indx = atoi( numstr );      
      if (g->external[indx].exist)
      {
         /*--------------------------------------------------*/
         /* Refresh frame by emulating a push on one of the  */
         /* extra frame buttons. Note that when this button  */
         /* is already in, then you cannot activate it again */
         /* without confusing this radio button group. Then  */
         /* a trigger of the FRAME is sufficient.            */
         /*--------------------------------------------------*/ 
         char   butkey[KEYLEN];
         sprintf( butkey, "EFRAME%d=", indx );
         if ( !UserLog(butkey) )
         {
            wkeyf( "%sYES", butkey );            
         }
         else
         {
            TriggerKey( "FRAME=" );
         }
      }
      wkeyf( key );    /* Re-enter to reset button */
   }
}



static int dssloadset( char   *inputfits,
                       char   *outputset )
/*------------------------------------------------------------*/
/* PURPOSE: Convert a DSS fits file to a GDS set.             */
/*------------------------------------------------------------*/
{
   int    deputyresult = 0;
       
   wkeyf( "FILENAME=%s", inputfits );
   wkeyf( "OUTSET=%s", outputset );
   deputyresult = deputyC( "DSSLOAD", 0 );

   if (deputyresult != 1)   /* i.e. not successful */
   {
      char mes[80];
      deputyerror( deputyresult, mes );
      error_status( "Could not deputy task DSSLOAD", mes, "" );
      return( 0 );
   }   
   return( 1 );
}




static void externalframes( ident  id,
                            char  *key,
                            int    code,
                            void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: EXTLOAD0/1/2= keywords handler. Detect frame nr   */
/* first and find the origin of the wanted image.             */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   char        numstr[2];
   int         extframenr;
   bool        loadanexternal = UserLog(key);
   char        dumkey[FITSLEN];
   
  
   if (loadanexternal)
   {
      fint  type;
      fint  dfault = HIDDEN;
      fint  nitems = 1;
      int   indx;
      char  mes[FILENAMELEN];
      fchar Extset;
            
      
      numstr[0] = key[strlen("EXTLOAD")];
      numstr[1] = '\0';
      extframenr = atoi( numstr );
      sprintf( dumkey, "EXTTYPE%d=", extframenr );
      indx = extframenr;
      /* Now get the type of this external input */      
      (void) userint_c( &type, &nitems, &dfault, tofchar(dumkey), tofchar("") );
      g->external[indx].type = type;
      if (type == 0)
      {
         strcpy( g->external[indx].origname, "dummy_zero_moment" );
         sprintf( mes, "M0 in: [%s]", g->external[indx].origname );
         strcpy( g->external[indx].gdsname, g->external[indx].origname );
         if (makemomentset( indx, g ) )
            displayexternalset( indx, g ); 
      }
      else if (type == 1)
      {
         strcpy( g->external[indx].origname, "dummy_first_moment" );
         sprintf( mes, "M1 in: [%s]", g->external[indx].origname );
         strcpy( g->external[indx].gdsname, g->external[indx].origname );
         if (makemomentset( indx, g ) )
            displayexternalset( indx, g );
      }
      else if (type == 2)
      {
         strcpy( g->external[indx].origname, "dummy_second_moment" );
         sprintf( mes, "M2 in: [%s]", g->external[indx].origname );
         strcpy( g->external[indx].gdsname, g->external[indx].origname );
         if (makemomentset( indx, g ) )
            displayexternalset( indx, g );          
      }         
      else if (type == REPROJ)
      {
         char keyw[FITSLEN];
         fint r;
       
         Extset.a = g->external[indx].origname;
         Extset.l = FILENAMELEN;         
         sprintf( keyw, "EXTSET%d=", indx );
         dfault = HIDDEN;
         clearfchar( Extset );
         r = usertext_c( Extset, &dfault, tofchar( keyw ), tofchar("") );
         Extset.a[r] = '\0';
         if (r == 0)
         {
            /* User wants an external set but no name was entered */
            error_status( "No set name entered!", "Select type and enter set", "" );
            wkeyf( key ); 
            return;
         }
         strcpy( mes, g->external[indx].origname );
         sprintf( g->external[indx].gdsname, "%s_%d", REPROJNAME, indx );

         /*--------------------------------------------------*/
         /* Reproject the entire area not just the current   */
         /* box otherwise you cannot zoom.                   */
         /*--------------------------------------------------*/
         if ( reprojectset( g->external[indx].origname,
                            g->external[indx].gdsname,
                            g->inset.flo, g->inset.fhi ) )
            displayexternalset( indx, g );
      }
      else if (type == DSS)
      {
         char keyw[FITSLEN];
         fint r;
       
         Extset.a = g->external[indx].origname;
         Extset.l = FILENAMELEN;         
         sprintf( keyw, "EXTDSS%d=", indx );
         dfault = HIDDEN;
         r = usertext_c( Extset, &dfault, tofchar( keyw ), tofchar("") );
         Extset.a[nelc_c(Extset)] = '\0';
         if (r == 0)
         {
            /* User wants to read a DSS set but no name was entered */
            error_status( "No DSS file name entered!", 
                          "Select type and enter set", "" );
            wkeyf( key ); 
            return;
         }         
         sprintf( mes, "DSS: [%s]", g->external[indx].origname );
         strcpy( g->external[indx].gdsname, DSSNAME );
         if ( dssloadset( g->external[indx].origname, 
                          g->external[indx].gdsname ) )
         {
            /* If the DSS fits file could be read, reproject the entire area */
            if ( reprojectset( g->external[indx].gdsname, 
                               DSSREPROJNAME, 
                               g->inset.flo, g->inset.fhi ) )
            {
               fint   r = 0;
               /* Delete the unreprojected gds set */
               gds_delete_c( tofchar(g->external[indx].gdsname), &r );
               strcpy( g->external[indx].gdsname, DSSREPROJNAME );
               displayexternalset( indx, g );
            }
         }
      }
      /* Store the name as entered by the user */
      FrameText( g->inset.nsubs+indx, mes ); 
      wkeyf( key );                                      /* Reset LOAD button */
   }
}



static void xvmaptoset( ident id,
                        char  *key,
                        int   code,
                        void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: XVOUT= keyword handler.                           */
/* Get a set (name) to and save XV map as subset.             */
/*------------------------------------------------------------*/
{
   globaltype    *g = (globaltype *) arg;
   fint          dfault, nitems, r;
   fint          context;
   static int    okayed = NO;



   clearstatus();

   dfault = HIDDEN;
   nitems = 1;
   (void) userint_c( &context, &nitems, &dfault,
                     tofchar("_MENUCONTEXT="), tofchar(" ") );


   if (context == 0)
   {
      error_status( "No slices to save!", "", "" );
      rejectf( key, "No slices to save!" );
      okayed = NO;
      return;
   }

   dfault = HIDDEN;
   nitems = 1;
   r = userchar_c( g->Outsetname, &nitems, &dfault, tofchar(key), tofchar(" ") );
   g->Outsetname.a[nelc_c(g->Outsetname)] = '\0';
   if (r == 0)
   {
      okayed = NO;
      return;
   }
   /* Check existence */
   if (!okayed)
   {
      r = 0;
      if (gds_exist_c(g->Outsetname, &r))
      {
         error_status( "Output set already exists!", "", "" );
         GgiPrompter( "AGAIN", "Ok to overwrite?" );
         okayed = YES;
         return;
      }
   }
   okayed = NO;
   GgiPrompter( "ACCEPT", "" );
   r = 0;
   if (gds_exist_c(g->Outsetname, &r))
   {
      r = 0;
      gds_delete_c( g->Outsetname, &r );
   }

   /* Now we can start creating a new set for output of slices */
   writexv( g, context );
}




static void sampletofile( ident  id,
                          char  *key,
                          int    code,
                          void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: SAMPOUT= keyword handler.                         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   FILE       *fp;
   fchar      Dummytxt;
   fint       dfault, nitems, r;
   static int okayed = NO;
   fint       context;
   char       stampstr[80];


   clearstatus();

   dfault = HIDDEN;
   nitems = 1;
   (void) userint_c( &context, &nitems, &dfault,
                     tofchar("_MENUCONTEXT="), tofchar(" ") );



   Dummytxt.l = FILENAMELEN-1;
   Dummytxt.a = g->samplefilename;
   r = userchar_c( Dummytxt, &nitems, &dfault, tofchar(key), tofchar(" ") );
   Dummytxt.a[nelc_c(Dummytxt)] = '\0';
   if (r == 0)
   {
      okayed = NO;
      return;
   }
   /* Check existence */
   if (!okayed)
   {
      fp = fopen( g->samplefilename, "r" );
      if (fp != NULL)
      {
         error_status( "File exists!", "", "" );
         GgiPrompter( "AGAIN", "Ok to overwrite?" );
         okayed = YES;
         fclose( fp );
         return;
      }
   }
   okayed = NO;
   fp = fopen( g->samplefilename, "w" );
   if (fp == NULL)
   {
      error_status( "Cannot open file on disk", "Check permissions", "" );
      rejectf( key, "Cannot open file on disk!" );
      return;
   }
   GgiPrompter( "ACCEPT", "" );


   stamp( stampstr );
   /* Write to file */
   if (context == MENU_LINES)
   {
      int    i;
      int    ndat;
      float *Y1 = NULL;
      float  D1 = 0.0;
      float *Y2 = NULL;
      float  D2 = 0.0;


      D1 = g->line[0].offmin;
      D2 = g->line[1].offmin;

      fprintf( fp, "!  %s: line sample positions in grids\n", taskname );
      fprintf( fp, "!  The distance in grids from the starting point and the corresponding image value\n" );
      fprintf( fp, "!  Date: %s\n", stampstr );
      if (g->panel2)
      {
         ndat = MYMAX( g->line[0].ndat, g->line[1].ndat );
         fprintf( fp, "!%14s  %15s %15s %15s   %15s  %15s %15s %15s \n", "X1", "Y1", "D1", "I1", "X2", "Y2", "D2", "I2");
      }
      else
      {
         ndat = g->line[0].ndat;
         fprintf( fp, "!%13s  %15s  %15s %15s\n", "X", "Y", "D", "I" );
      }
      Y1 = &(g->line[0].sliceimage[g->currentframe*g->line[0].ndat]);
      Y2 = &(g->line[1].sliceimage[g->currentframe*g->line[1].ndat]);
      for (i = 0; i < ndat; i++)
      {
         float x, y, d;
         float xp, yp;
         int   nmax1, nmax2;

         nmax1 = g->line[0].ndat; nmax2 = g->line[1].ndat;
         if (i <  g->line[0].ndat-1)
         {
            x = g->line[0].Xpos[i]; y = g->line[0].Ypos[i];
            if (i > 0)
            {
               xp = g->line[0].Xpos[i-1]; yp = g->line[0].Ypos[i-1];
               d = sqrt((x-xp)*(x-xp)+(y-yp)*(y-yp));
            }
            else
               d = 0.0;
            D1 += d;
         }
         if (i < g->line[1].ndat-1)
         {
            x = g->line[1].Xpos[i]; y = g->line[1].Ypos[i];
            if (i > 0)
            {
               xp = g->line[1].Xpos[i-1]; yp = g->line[1].Ypos[i-1];
               d = sqrt((x-xp)*(x-xp)+(y-yp)*(y-yp));
            }
            else
               d = 0.0;
            D2 += d;
         }

         /* There are a number of possibilities here */
         /* 1) Just one panel */
         if (!g->panel2)
         {
            fprintf( fp, "%15f  %15f %15f  %15f\n", g->line[0].Xpos[i], g->line[0].Ypos[i], D1, Y1[i] );
         }
         else
         {
            /* 2) Both panels are on and both numbers are available */
            if (i < g->line[0].ndat && i < g->line[1].ndat)
            {
               fprintf( fp, "%15f  %15f  %15f  %15f  %15f  %15f  %15f  %15f\n",
                        g->line[0].Xpos[i], g->line[0].Ypos[i], D1, Y1[i],
                        g->line[1].Xpos[i], g->line[1].Ypos[i], D2, Y2[i] );
            }
            else if (i < g->line[0].ndat)
            {
               /* 3) Both panels but only data from the first */
               fprintf( fp, "%15f  %15f  %15f  %15f\n", g->line[0].Xpos[i], g->line[0].Ypos[i], D1, Y1[i] );
            }
            else
            {
               /* 4) Both panels but only data from the second */
               fprintf( fp, "%15s  %15s  %15s  %15s  %15f  %15f  %15f  %15f\n",
                        "-", "-", "-", "-", g->line[1].Xpos[i], g->line[1].Ypos[i], D2, Y2[i] );
            }
         }
      }
   }
   else if (context == MENU_ELLIPSE)
   {
      int    i;
      int    ndat;
      float *Y = NULL;
      float  D = 0.0;
      float  maj, min, peri, h;

      maj=  g->ellipse.major;              /* SEMI major & minor */
      min = g->ellipse.minor;
      h = (maj-min)/(maj+min);
      h *= h;
      peri = PI * (maj+min) * (1.0 + (3.0*h/(10.0+sqrt(4.0-3.0*h)) )); /* Wolfram ellipse eq 73 */
      fprintf( fp, "!  %s: ellipse sample positions in grids\n", taskname );
      fprintf( fp, "!  The distance in grids from the starting point and the corresponding image value\n" );
      fprintf( fp, "!  Estimated perimeter (in grids) of the ellipse = %f\n", peri );
      fprintf( fp, "!  Date: %s\n", stampstr );
      fprintf( fp, "!%13s  %15s  %15s %15s\n", "X", "Y", "D", "I" );

      ndat = g->ellipse.ndat;
      Y = &(g->ellipse.sliceimage[g->currentframe*ndat]);

      for (i = 0; i < ndat; i++)
      {
         float x, y, d;
         float xp, yp;
         x = g->ellipse.Xpos[i]; y = g->ellipse.Ypos[i];
         if (i > 0)
         {
            xp = g->ellipse.Xpos[i-1]; yp = g->ellipse.Ypos[i-1];
            d = sqrt((x-xp)*(x-xp)+(y-yp)*(y-yp));
         }
         else
            d = 0.0;
         D += d;
         fprintf( fp, "%15f  %15f  %15f  %15f\n", g->ellipse.Xpos[i], g->ellipse.Ypos[i], D, Y[i] );
      }
   }
   else if (context == MENU_SPLINE)
   {
      int    i;
      int    ndat;

      if (strcmp(key, "SPLINEOUT=") == 0)
      {
         /* Save spline control points */
         fprintf( fp, "!  %s: spline control positions in grids and corresponding image values (not interpolated)\n", taskname );
         fprintf( fp, "!  Date: %s\n", stampstr );
         fprintf( fp, "!%13s  %15s\n", "X", "Y");
         ndat = g->spline.ndat;
         for (i = 0; i < ndat; i++)
         {
            fprintf( fp, "%15f  %15f\n", g->spline.Xpos[i], g->spline.Ypos[i] );
         }
         fprintf( fp, "\n!--------------------------------------------------------------\n" );
         fprintf( fp, "!  Same positions in grids but with image values\n" );
         fprintf( fp, "!  These are in comment lines to preserve file as valid input for spline\n" );
         fprintf( fp, "!  control points in %s\n", taskname );
         fprintf( fp, "!%13s  %15s  %15s\n", "X", "Y", "I" );
         for (i = 0; i < ndat; i++)
         {
            float imval;
            float x, y;

            x = g->spline.Xpos[i];
            y = g->spline.Ypos[i];
            imval  = getimagevalue( g, NINT(x), NINT(y), g->currentframe );
            fprintf( fp, "! %15f  %15f  %15f\n", x, y, imval );
         }
         fprintf( fp, "\n!--------------------------------------------------------------\n" );
         fprintf( fp, "!  Same positions in physical coordinates\n" );
         fprintf( fp, "!  These are in comment lines to preserve file as valid input for spline\n" );
         fprintf( fp, "!  control points in %s\n", taskname );
         fprintf( fp, "!%13s  %15s\n", "X", "Y");
         for (i = 0; i < ndat; i++)
         {
            float x, y;
            double xph, yph;
            
            x = g->spline.Xpos[i];
            y = g->spline.Ypos[i];
            getphysraw( g, x, y, g->currentframe, &xph, &yph );
            fprintf( fp, "! U %15f   U %15f\n", xph, yph );
         }
      }
      else
      {
         float *Y = NULL;
         float  D = 0.0;
         fprintf( fp, "!  %s: Interpolated spline sample positions in grids\n", taskname );
         fprintf( fp, "!  The distance in grids from the starting point and the corresponding image value\n" );         
         fprintf( fp, "!  Date: %s\n", stampstr );
         fprintf( fp, "!%13s  %15s  %15s %15s\n", "X", "Y", "D", "I" );
         ndat = g->spline.ndatO;
         Y = &(g->spline.sliceimage[g->currentframe*ndat]);
         for (i = 0; i < ndat; i++)
         {
            float x, y, d;
            float xp, yp;

            x = g->spline.XposO[i]; y = g->spline.YposO[i];
            if (i > 0)
            {
               xp = g->spline.XposO[i-1]; yp = g->spline.YposO[i-1];
               d = sqrt((x-xp)*(x-xp)+(y-yp)*(y-yp));
            }
            else
               d = 0.0;

            D += d;
            fprintf( fp, "%15f  %15f  %15f  %15f\n", g->spline.XposO[i], g->spline.YposO[i], D, Y[i] );
         }
      }
   }
   else
   {
      fclose( fp );
      return;
   }

   fclose( fp );
   {
      char  mes[512];
      sprintf( mes, "Sample data saved to disk in: %s", g->samplefilename );
      error_status( "", mes, "" );
   }
}




static void toGPLOTfile( ident  id,
                         char  *key,
                         int    code,
                         void  *arg )
/*------------------------------------------------------------*/
/* PURPOSE: GPLOTFILE= keyword handler.                       */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   FILE        *fp;
   fchar       Dummytxt;
   fint        dfault, nitems, r;
   static int  okayed = NO;
   fint        context;
   char        stampstr[80];
   char        setspecification[FILENAMELEN+1];
   int         i, k;
   fint        subsetlo = g->inset.subsets[g->currentframe];   
   char        levstring[256];
   int         levspec;         /* Unequal to zero if we have contour levels */



   context = g->slicemode;
   
   dfault = HIDDEN;
   nitems = 1;
   Dummytxt.l = FILENAMELEN-1;   
   Dummytxt.a = g->gplotfilename;
   r = userchar_c( Dummytxt, &nitems, &dfault, tofchar(key), tofchar(" ") );
   Dummytxt.a[nelc_c(Dummytxt)] = '\0';
   if (r == 0)
   {
      okayed = NO;
      return;
   }
   /* Check existence */
   if (!okayed)
   {
      fp = fopen( g->gplotfilename, "r" );
      if (fp != NULL)
      {
         error_status( "File exists!", "", "" );
         GgiPrompter( "AGAIN", "Ok to overwrite?" );
         okayed = YES;
         fclose( fp );
         return;
      }
   }
   okayed = NO;
   fp = fopen( g->gplotfilename, "w" );
   if (fp == NULL)
   {
      error_status( "Cannot open file on disk", "Check permissions", "" );
      rejectf( key, "Cannot open file on disk!" );
      return;
   }
   GgiPrompter( "ACCEPT", "" );

   /* Start writing to file */
   stamp( stampstr );

   strcpy( setspecification, g->inset.name );

   for (i = g->inset.subdim, k = 0; i < g->inset.setdim; i++, k++)
   {
      fint   grid, cwlo, cwhi, r, axnum;
      char   mbuf[512];
      axnum = g->inset.axnum[ i ];

      r = 0;      
      gdsc_range_c( g->inset.Name, &subsetlo, &cwlo, &cwhi, &r );
      r = 0;
      grid = gdsc_grid_c( g->inset.Name, &axnum, &cwlo, &r ); 
      sprintf( mbuf, " %s %d", g->inset.axisname[k], grid );
      strcat( setspecification, mbuf );
   }         


   nitems = 1;
   Dummytxt.l = 256-1;
   Dummytxt.a = levstring;
   r = userchar_c( Dummytxt, &nitems, &dfault, tofchar("LEVELS="), tofchar(" ") );
   levspec = (r == 1);
   Dummytxt.a[nelc_c(Dummytxt)] = '\0';


   /* Current settings of image colours */
   savecolors( NULL, "SAVECOLORS=", KEYCHANGE, g );
   fprintf( fp, "! Start GPLOT with COMMAND=input <thisfilename>\n" );
   fprintf( fp, "device lcpsfile\n" );
   fprintf( fp, "inset %s\n", setspecification );
   fprintf( fp, "xsize 100\n" );
   fprintf( fp, "ysize 100\n" );   
   fprintf( fp, "box %d %d %d %d\n", g->inset.blo[0], g->inset.blo[1], g->inset.bhi[0], g->inset.bhi[1] );
   fprintf( fp, "frame\n" );
   fprintf( fp, "getlut header\n" );
   if (g->pginterpol)
      fprintf( fp, "interpol on\n" );
   fprintf( fp, "colplot\n" );
   if (g->pginterpol)
      fprintf( fp, "interpol off\n" );   
   if (levspec)
   {
      fprintf( fp, "levels %s\n", levstring );
      r = userchar_c( Dummytxt, &nitems, &dfault, tofchar("LEVCOL="), tofchar(" ") );
      Dummytxt.a[nelc_c(Dummytxt)] = '\0';      
      if (r == 1)
         fprintf( fp, "color %s\n", levstring );
      r = userchar_c( Dummytxt, &nitems, &dfault, tofchar("LEVTHICK="), tofchar(" ") );
      Dummytxt.a[nelc_c(Dummytxt)] = '\0';      
      if (r == 1)
         fprintf( fp, "lwidth %s\n", levstring );         
      r = userchar_c( Dummytxt, &nitems, &dfault, tofchar("LEVSTYLE="), tofchar(" ") );
      Dummytxt.a[nelc_c(Dummytxt)] = '\0';      
      if (r == 1)
         fprintf( fp, "lstyle %s\n", levstring );         
      fprintf( fp, "contours\n" );      
   }
   fprintf( fp, "close\n" );

#if 0
   if (context == LINE)
   {
      int    i;
      int    ndat;

      fprintf( fp, "!  %s: GPLOT input file, line sample mode\n", taskname );
      fprintf( fp, "!  Date: %s\n", stampstr );
      fprintf( fp, "!  More to come soon!\n" );
   }
   else if (context == ELLIPSE)
   {
      int    i;
      int    ndat;

      fprintf( fp, "!  %s: GPLOT input file, ellipse sample mode\n", taskname );
      fprintf( fp, "!  Date: %s\n", stampstr );
      fprintf( fp, "!  More to come soon!\n" );      
      ndat = g->ellipse.ndat;
   }
   else if (context == SPLINE)
   {
      int    i;
      int    ndat;

      if (strcmp(key, "SPLINEOUT=") == 0)
      {
         /* spline control points mode */
         fprintf( fp, "!  %s: spline control positions mode\n", taskname );
         fprintf( fp, "!  Date: %s\n", stampstr );
      }
      else
      {
         fprintf( fp, "!  %s: Interpolated spline sample positions mode\n", taskname );
         fprintf( fp, "!  Date: %s\n", stampstr );
      }
      fprintf( fp, "!  More to come soon!\n" );
   }
   else
   {
      fprintf( fp, "!  %s: GPLOT input file, no sample mode\n", taskname ); 
      fprintf( fp, "!  Date: %s\n", stampstr );
      fprintf( fp, "!  More to come soon!\n" );      
      fclose( fp );
      return;
   }
#endif

   fclose( fp );
   {
      char  mes[512];
      sprintf( mes, "GPLOT input file template saved to disk in: %s", g->gplotfilename );
      clearstatus();      
      gui_status( mes, FIRSTLINE );
   }
}




static void initializestruct( globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: Initialize values for current status.             */
/*------------------------------------------------------------*/
{
   int    i;

   g->boxexist = NO;
   g->inset.exist = NO;
   g->hardcopy = NO;
   sprintf( g->PSname, "%s.ps", taskname );
   sprintf( g->samplefilename, "%s.dat", taskname );
   sprintf( g->gplotfilename, "%s.gplot", taskname );
   
   /* The output set is not initialized  with 'getset'! */

   g->PGmainplotid = 0;
   g->PGhardcopyid = 0;
   g->PGinfoid     = 0;
   g->fluxregrid   = 0.1;
   g->imagesloaded = NO;
   g->inset.cpos[0] = g->inset.cpos[1] = 0.0;
   g->inset.defclip[0] = g->inset.defclip[1] = fblank;
   g->inset.grid2hmsdms = NO;
   g->Outsetname.a = g->outsetbuf;
   g->Outsetname.l = sprintf( g->Outsetname.a, "xvset" );
   g->newset = YES;

   for (i = 0; i < 2; i++)
   {
      g->line[i].xc    = 0.0;
      g->line[i].yc    = 0.0;
      g->line[i].angle = 45.0;
      g->line[i].Xpos  = NULL;
      g->line[i].Ypos  = NULL;
      g->line[i].ndat  = 0;
      g->line[i].sampledist = 1.0;
      g->line[i].samplelen = 10000;
      g->line[i].sliceimage = NULL;
      g->line[i].dummyx = NULL;
      g->line[i].slicewidth = 0.0;
      g->line[i].intsep = 1.0;
      g->line[i].dirvect[0] = g->line[i].dirvect[1] = 0.0;
      g->line[i].axratio = 1.0;
      g->line[i].PGplotid = 0;
      g->line[i].PGgraphid = 0;
      g->line[i].flag = NULL;
      g->line[i].numflags = 0;
   }
   g->line[0].offsetpa = 0.0;
   g->line[1].offsetpa = 90.0;
   g->ellipse.xc    = 0.0;
   g->ellipse.yc    = 0.0;
   g->ellipse.angle = 45.0;
   g->ellipse.Xpos  = NULL;
   g->ellipse.Ypos  = NULL;
   g->ellipse.ndat  = 0;
   g->ellipse.sampledist = 1.0;
   g->ellipse.slicewidth = 0.0;
   g->ellipse.intsep = 1.0;   
   g->ellipse.major = 10.0;
   g->ellipse.minor = 5.0;
   g->ellipse.sliceimage = NULL;
   g->ellipse.dummyx = NULL;
   g->ellipse.axratio = 0.5;
   g->ellipse.startpa = 0.0;
   g->ellipse.endpa = 360.0;
   g->ellipse.PGplotid = 0;
   g->ellipse.PGgraphid = 0;
   g->ellipse.flag = NULL;
   g->ellipse.numflags = 0;

   g->spline.ndat = g->spline.ndatO = 0;
   g->spline.XposO = NULL;
   g->spline.YposO = NULL;
   g->spline.sliceimage = NULL;
   g->spline.dummyx = NULL;
   g->spline.sampledist = 1.0;
   g->spline.slicewidth = 0.0;   
   g->spline.intsep = 1.0;
   g->spline.PGplotid = 0;
   g->spline.PGgraphid = 0;
   g->spline.flag = NULL;
   g->spline.numflags = 0;


   g->newframe = YES;
   g->panel2 = NO;
   g->linegraph = NO;
/*   g->slicemode = LINE;*/
   g->maincursorid = NULL;
   g->line1cursorid = NULL;   
   g->line2cursorid = NULL;
   g->ellipsecursorid = NULL;
   g->splinecursorid = NULL;         
   g->interpol = NO;          /* Real data interpolation in a subset */
   g->pginterpol = 0;         /* Bilinear interpolation in PGIMAG */

   for (i = 0; i < EXTRAFRAMES; i++)
   {
      g->external[i].clip[0] = g->external[i].clip[1] = fblank;
      g->external[i].exist = NO;
   }

   g->slicemode = -1;
   g->updateframe = NULL;   
}




static void quit( ident  id,
                  char  *key,
                  int    code,
                  void  *arg)
/*------------------------------------------------------------*/
/* PURPOSE: QUIT= keyword handler.                            */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;


   /* Release memory */

   free( g->line[0].sliceimage );
   free( g->line[1].sliceimage );
   if (g->updateframe != NULL)
      free( g->updateframe );
   cancel("FRAME=");
   cancel("PANEL2=");
   cancel("SPLINECLEAR=");
   cancel("CLEARFLAGS=");
   cancel( key );                       /* remove QUIT= keyword */
   finis_c();                           /* terminate task */
}




MAIN_PROGRAM_ENTRY
/*-------------------------------------------------------------------------*/
/* The macro MAIN_PROGRAM_ENTRY replaces the C-call main() to start the    */
/* main body of your GIPSY application. Variables defined as 'fchar' start */
/* with a capital.                                                         */
/*-------------------------------------------------------------------------*/
{
   /*----------------------------------------*/
   /* Make this struct static. Then all      */
   /* members are initialized to 0 and the   */
   /* structure variable is not part of the  */
   /* stack.                                 */
   /*----------------------------------------*/
   static globaltype   glob;


   init_c();                                /* Contact Hermes */

   /* Initialize global variables */
   strcpy( taskname, "sliceview" );
   anyoutf( 1, "%s version %s", taskname, RELEASE );
   anyoutf( 1, "-----------------------------------------------------------------" );
   anyoutf( 1, "This is SLICEVIEW version 1.7 (June 03, 2010)" );
   anyoutf( 1, "   Release notes:" );
   anyoutf( 1, " " );
   anyoutf( 1, " - Interaction from XV plots. Display of subsets is faster" );
   anyoutf( 1, " - A number of minor bugs removed" );
   anyoutf( 1, "-----------------------------------------------------------------" );   
   setfblank_c( &fblank );
   setdblank_c( &dblank );
   setlevel = 0;

   initializestruct( &glob );               /* Set default properties */
   wkeyf( "HCFILENAME=%s", glob.PSname );   /* Set default PS file name */
   wkeyf( "SAMPOUT=%s", glob.samplefilename );
   wkeyf( "GPLOTFILE=%s", glob.gplotfilename );   
   wkeyf( "XVOUT=%s", glob.Outsetname.a );

   startgui();

   /* Initialize the plot in the main (== movie) window */
   glob.PGmainplotid = initplot( "XYPLOT", 1, 1 );
   glob.mainplotGGIid = GgiPlotField( "XYPLOT", 0, 0 );


   /* Start scheduling the functions */

   (void) ScheduleKeyevent( quit,        "QUIT=",        KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getset,      "INSET=",       KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getbox,      "BOX=",         KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getclip,     "CLIP=",        KEYCHANGE, &(glob.inset) );
   (void) ScheduleKeyevent( hardcopy,    "HCFILENAME=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( readsub,     "READSUB=",     KEYCHANGE, &glob );
   (void) ScheduleKeyevent( drawconts,   "LEVDRAW=",     KEYCHANGE, &glob );   
/*   (void) ScheduleKeyevent( getxvfromline, "LINE=",      KEYCHANGE, &glob );*/
/*   (void) ScheduleKeyevent( getxvfromellipse, "ELLIPSE=",KEYCHANGE, &glob );*/
/*   (void) ScheduleKeyevent( getxvfromspline, "SPLINE=",  KEYCHANGE, &glob );*/
   (void) ScheduleKeyevent( getsampleangle,  "POSANG=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getsampleangle,"E_POSANG=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getxcyc,       "CENTRE=",    KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getxcyc,       "E_CENTRE=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getsampledist, "SAMP=",      KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getsampledist, "E_SAMP=",    KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getsampledist, "S_SAMP=",    KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getsamplelen,  "SAMPLEN1=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getsamplelen,  "SAMPLEN2=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getsamplelen,  "E_SAMPLEN1=",KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getsamplelen,  "E_SAMPLEN2=",KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getswidth,     "SWIDTH=",    KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getswidth,     "E_SWIDTH=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getswidth,     "S_SWIDTH=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getintsep,     "INTSEP=",    KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getintsep,     "E_INTSEP=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getintsep,     "S_INTSEP=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( storecurrentframenumber, "FRAME=", KEYCHANGE, &glob );
   
   (void) ScheduleKeyevent( setpanel2,     "PANEL2=",    KEYCHANGE, &glob );
   (void) ScheduleKeyevent( setlinegraph,  "LINEGRAPH=", KEYCHANGE, &glob );
   (void) ScheduleKeyevent( setslicemode,  "SLICE=",     KEYCHANGE, &glob );

   (void) ScheduleKeyevent( zprofinfo,     "_POP_ZPROF=",   KEYCHANGE, &glob );
   (void) ScheduleKeyevent( popline,       "_POP_LINES=",   KEYCHANGE, &glob );
   (void) ScheduleKeyevent( popellipse,    "_POP_ELLIPSE=", KEYCHANGE, &glob );
   (void) ScheduleKeyevent( popspline,     "_POP_SPLINE=",  KEYCHANGE, &glob );

   (void) ScheduleKeyevent( getbool,       "INTERPOL=",  KEYCHANGE, &(glob.interpol) );
   (void) ScheduleKeyevent( wakeslice,     "ACTIVATE=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( clearspline,   "SPLINECLEAR=", KEYCHANGE, &glob );
   (void) ScheduleKeyevent( readspline,    "SPLINEIN=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( getregridval,  "REGRID=",    KEYCHANGE, &(glob.fluxregrid) );
   (void) ScheduleKeyevent( getinterpol,   "PGINTERP=",  KEYCHANGE, &(glob) );
/*   (void) ScheduleKeyevent( loadexternal,  "EXTSET=",    KEYCHANGE, &glob );*/
   (void) ScheduleKeyevent( extclip,       "EXTCLIP=",   KEYCHANGE, &(glob.extclip) );
   (void) ScheduleKeyevent( setoffsetpa,   "OFFSETPA=",  KEYCHANGE, &glob );
   (void) ScheduleKeyevent( setratio,      "RATIO=",     KEYCHANGE, &glob );
   (void) ScheduleKeyevent( setratio,      "E_RATIO=",   KEYCHANGE, &glob );

   (void) ScheduleKeyevent( sampletofile,  "SAMPOUT=",   KEYCHANGE, &glob );
   (void) ScheduleKeyevent( sampletofile,  "SPLINEOUT=", KEYCHANGE, &glob );
   (void) ScheduleKeyevent( toGPLOTfile,   "GPLOTFILE=", KEYCHANGE, &glob );
   (void) ScheduleKeyevent( xvmaptoset,    "XVOUT=",     KEYCHANGE, &glob );
   (void) ScheduleKeyevent( ellipserange,  "E_PARANGE=", KEYCHANGE, &glob );

   (void) ScheduleKeyevent( clearflags,    "CLEARFLAGS=", KEYCHANGE, &glob );
   (void) ScheduleKeyevent( savecolors,    "SAVECOLORS=", KEYCHANGE, &glob );   
   
   /* Schedule a function for the extra frames */
   {
      int i;
      for (i = 0; i < EXTRAFRAMES; i++)
      {
         char   keyw[30];
         sprintf( keyw, "EXTLOAD%d=", i ); 
         (void) ScheduleKeyevent( externalframes, keyw, KEYCHANGE, &glob );
         sprintf( keyw, "LEVOVER%d=", i );
         if ( !TriggerKey(keyw) )
         {
            wkeyf( "%sYES", keyw );
         }
         sprintf( keyw, "LEVDRAW%d=", i );
         (void) ScheduleKeyevent( drawextcont, keyw, KEYCHANGE, &glob );
      }
   }
 

   ScheduleFrame( aftermovieaction );

   TriggerKey("PGINTERP=");
   TriggerKey("INTERPOL=");
   TriggerKey("MONITOR=");
   TriggerKey("INSET=");
   if (!TriggerKey("OFFSETPA="))     wkeyf( "OFFSETPA=90" );
   if (!TriggerKey("RATIO="))        wkeyf( "RATIO=1.0" );
   if (!TriggerKey("E_RATIO="))      wkeyf( "E_RATIO=0.5" );
   if (!TriggerKey("E_PARANGE="))    wkeyf( "E_PARANGE=0 360" );
   if (!TriggerKey("LINEGRAPH="))    wkeyf( "LINEGRAPH=N");
   if (!TriggerKey("CENTRE="))       wkeyf( "CENTRE=PC" );
   if (!TriggerKey("E_CENTRE="))     wkeyf( "E_CENTRE=PC" );
   if (!TriggerKey("SWIDTH="))       wkeyf( "SWIDTH=0.0" );
   if (!TriggerKey("E_SWIDTH="))     wkeyf( "E_SWIDTH=0.0" );
   if (!TriggerKey("S_SWIDTH="))     wkeyf( "S_SWIDTH=0.0" );      
   if (!TriggerKey("INTSEP="))       wkeyf( "INTSEP=1.0" );
   if (!TriggerKey("E_INTSEP="))     wkeyf( "E_INTSEP=1.0" );
   if (!TriggerKey("S_INTSEP="))     wkeyf( "S_INTSEP=1.0" );      
   if (!TriggerKey("S_SAMP="))       wkeyf( "S_SAMP=1.0" );



#ifdef TRYIT
   if (!TriggerKey("E_SAMPLEN1="))   wkeyf( "E_SAMPLEN1=10000" );
   if (!TriggerKey("E_SAMPLEN2="))   wkeyf( "E_SAMPLEN2=10000" );
   if (!TriggerKey("SAMPLEN1="))     wkeyf( "SAMPLEN1=10000" );
   if (!TriggerKey("SAMPLEN2="))     wkeyf( "SAMPLEN2=10000" );
   if (!TriggerKey("PANEL2="))       wkeyf( "PANEL2=NO" );
   if (!TriggerKey("POSANG="))       wkeyf( "POSANG=%f", glob.line[0].angle );
   if (!TriggerKey("SAMP="))         wkeyf( "SAMP=%f", glob.line[0].sampledist );
#endif

   eventmonitor("MONITOR=", TRUE);

   MainLoop();

   return( EXIT_SUCCESS );
}
#<

#>            gui.c
/* gui.c -XT
                              COPYRIGHT (c) 2000
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands

Author: J.P. Terlouw
*/

#include "stdio.h"
#include "stddef.h"
#include "gipsyc.h"
#include "userfio.h"
#include "ggi.h"
#include "pgplot.h"
#include "coledit.h"
#include "frames.h"
#include "guilines.h"
#include "guiellipse.h"
#include "guispline.h"
#include "guicont.h"
#include "guimark.h"
#include "zprof.h"
#include "guipar.h"
#include "helptext.h"
#include "gui.h"

static  char *filelabels[]={"Input set",
                            "Special input set",
                            "Save plot",
                            "Save to GPLOT",
                            "Save colors to set",
                            "_LINE",
                            "Exit",
                            NULL};

typedef enum               {FILE_INPUT,
                            FILE_SPECIAL,
                            FILE_PLOT,
                            FILE_GPLOT,
                            FILE_COLORS,
                            FILE_LINE,
                            FILE_EXIT} filechoices;

static  char *slicelabels[]={"Lines", "Ellipse", "Spline", "No Slices", "_LINE", NULL};


static char *helplabels[]={"Overview",
                           "XV map from a line",
                           "XV map from a ellipse",
                           "XV map from a spline",
                           "Keywords",
                           "Mouse & keyboard",
                           "Hardcopy",
                           "MPEG movie",
                           "Howto", 
                           "Limits",
                           "Defaults",
                           "About",
                           "_LINE",
                           "User Interface", 
                            NULL};

static char *helpdocs[]=   { "sliceview.dc1#overview",
                             "sliceview.dc1#lines",
                             "sliceview.dc1#ellipse",
                             "sliceview.dc1#spline",
                             "sliceview.dc1#keywords",
                             "sliceview.dc1#mouse",
                             "sliceview.dc1#hardcopy",
                             "sliceview.dc1#mpeg",
                             "sliceview.dc1#howto",
                             "sliceview.dc1#limits",
                             "sliceview.dc1#defaults", 
                             "sliceview.dc1#about",                             
                              NULL, 
                             "ggi.doc"};

static ident xyplot, composer;
static ident l_status[STATUSLINES], l_info[INFOLINES], l_error;

/* -------------------------------------------------------------------------- */
/*                                 statusbox                                  */
/* -------------------------------------------------------------------------- */
/*  statusbox() creates form containing error and status lines
 */
static ident statusbox(int width)
{
   int   i;
   ident logo, curform, prvform, topref=NULL;
   
   curform = GgiForm("status", 1);
   prvform = GgiUseShell(curform);
   l_error  = GgiSetLabel(GgiLabel("error"), " ", 0);
   GgiSetPosition(l_error, 0, NULL,  0, topref);
   topref = l_error;
   for (i=0; i<STATUSLINES; i++) {
      l_status[i] = GgiSetLabel(GgiLabel("status"), " ", 0);
      GgiSetPosition(l_status[i], 0, NULL,  -1, topref);
      topref = l_status[i];
   }
   logo = GgiLogo(NULL, 0, 0);
   GgiSetPosition(logo, width-GgiWidth(logo)-6, NULL, 0, NULL);
   (void)GgiUseShell(prvform);
   return curform;
}


/* -------------------------------------------------------------------------- */
/*                                 infobox                                    */
/* -------------------------------------------------------------------------- */
static ident infobox(int width)
{
   int   i;
   ident curform, prvform, topref=NULL;
   
   curform = GgiForm("info", 1);
   prvform = GgiUseShell(curform);
   GgiSetPosition(GgiCanvas(" ", 1, 1), width-1-6, NULL, 0, NULL);
   topref = NULL;
   for (i=0; i<INFOLINES; i++) {
      l_info[i] = GgiSetLabel(GgiLabel("info"), " ", 0);
      GgiSetPosition(l_info[i], 0, NULL,  -1, topref);
      topref = l_info[i];
   }
   (void)GgiUseShell(prvform);
   return curform;
}
   

/* -------------------------------------------------------------------------- */
/*                                 handle_file                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for the file menu.
 */
static void handle_file(ident id, char* key, int code, void *arg)
{
   fint entry=0;

   if (userfint(&entry, 1, 2, key, " ")==1) {
      wkeyf("_MENUCONTEXT=%d", MENU_MAIN);
      switch (entry) {
         case FILE_INPUT: {
            composer = GgiInset(ggiIdent, "SETNAME=");
            if (composer) {
               (void)GgiInset(ggiDelete, composer);
            } else {
               composer = GgiInset(ggiCreate, "SETNAME=", "INSET=", "BOX=",
                                   "Map(s) to be displayed");
               (void)GgiInset(ggiNdims, composer, 2);
            }
            break;
         }
         case FILE_SPECIAL: {
            wkeyf("_EXTSET=YES");
            break;
         }
         case FILE_PLOT: {
            GgiPlotPrompter("HCFILENAME=", "HCDEVICE=",
                            "Main window plot.\nPostScript filename:");
            break;
         }
         case FILE_GPLOT: {
            GgiPrompter("GPLOTFILE=", "GPLOT file to be written:");
            break;
         }
         case FILE_COLORS: {
            wkeyf("SAVECOLORS=YES");
            break;
         }
         case FILE_EXIT: {
            wkeyf("QUIT=YES");
         }
      }
      wkeyf(key);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_slice                               */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for the slice menu.
 */
static void handle_slice(ident id, char* key, int code, void *arg)
{
   fint entry=0;

   if (userfint(&entry, 1, 2, key, " ")==1) {
      switch (entry) {
         case SLICE_LINES: {
            Guilines(NULL);
            break;
         }
         case SLICE_ELLIPSE: {
            Guiellipse(NULL);
            break;
         }
         case SLICE_SPLINE: {
            Guispline(NULL);
            break;
         }
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_ok                                  */
/* -------------------------------------------------------------------------- */
static void handle_ok(ident id, char* key, int code, void *arg)
{
   (void)GgiInset(ggiDelete, composer);
}

/* ========================================================================== */
/*                                 gui                                        */
/* -------------------------------------------------------------------------- */
/*  Interface routine to initialize the graphical user interface.
 */
extern void gui(void)
{
   ident topbar, info, status, filemenu, stopb, relb, fixb, clipinp,
         contb, markb, slicemenu, extb, colorbut, frmbox, zprofbut, intpbut,
         helpmenu;
   
   fint xywidth=XYWIDTH, xyheight=XYHEIGHT;
   
   static char *my_resources[] = {
      "*error.foreground: red",
      "*error.font: *helvetica*bold-r*14*",
      "*infoline.font: *courier*bold-r*12*",
      "*info.font: *courier*bold-r*12*",
      NULL
   };

   (void)userfint(&xywidth,  1, 2, "XYWIDTH=",  " ");
   (void)userfint(&xyheight, 1, 2, "XYHEIGHT=", " ");
   
   GgiAutoLayout(FALSE);
   GgiPostponeRealize(TRUE);
   GgiSetResources(my_resources);

   topbar = GgiForm("top", 1);
   xyplot = GgiPlotField("XYPLOT", xywidth, xyheight);
   (void)GgiPlotColors(NULL, 16+IMAGECOLORS);
   GgiPlotMapColors(xyplot, 0, 16, 16, IMAGECOLORS, -1);
   frmbox  = GgiForm("frames", 1);
   status  = statusbox(xywidth);
   info    = infobox(xywidth);
   
   GgiSetPosition(topbar, 0, NULL,   0, NULL);
   GgiSetPosition(xyplot, 0, NULL,   0, topbar);
   GgiSetPosition(frmbox, 0, NULL,   0, xyplot);
   GgiSetPosition(info,   0, NULL,   0, frmbox);
   GgiSetPosition(status, 0, NULL,   0, info);

   (void)GgiUseShell(topbar);
   filemenu = GgiMenu("FILE=", NULL, filelabels);
   stopb    = GgiSetLabel(GgiButton("STOPSUB=", H_STOPSUB), "STOP", 0);
   relb     = GgiSetLabel(GgiButton("READSUB=", H_READSUB), "RELOAD", 0);
   clipinp  = GgiSetLabel(GgiTextField("CLIP=", H_CLIP, 10), "CLIP", 0);
   fixb     = GgiSetLabel(GgiButton("FIXCLIP=",  H_FIXCLIP), "FIX", 0);
   extb     = GgiSetLabel(GgiButton("_EXTSET=",  H__EXTSET), "EXT. SET", 0);
   contb    = GgiSetLabel(GgiButton("_POP_CONT=",  H_CONT), "CONTOUR", 0);
   markb    = GgiSetLabel(GgiButton("_POP_FLAG=",  H_FLAG), "MARKER", 0);   
   slicemenu= GgiMenu("SLICE=", NULL, slicelabels);
   colorbut = GgiButton("COLOR=", NULL);
   zprofbut = GgiSetLabel(GgiButton("_POP_ZPROF=", H__POP_ZPROF), "ZPROF", 0);
   intpbut  = GgiSetLabel(GgiButton("PGINTERP=",
                             "Interpolate displayed images"), "INTP", 0);
   helpmenu = GgiHelpMenu("_HELP=", "HELP", NULL, helplabels, helpdocs);

   GgiSetPosition(filemenu,  0, NULL,      0, NULL);
   GgiSetPosition(stopb,     0, filemenu,  0, NULL);
   GgiSetPosition(relb,      0, stopb,     0, NULL);
   GgiSetPosition(clipinp,  10, relb,      0, NULL);
   GgiSetPosition(fixb,     -1, clipinp,   0, NULL);
   GgiSetPosition(extb,     10, fixb,      0, NULL);
   GgiSetPosition(slicemenu, 0, extb,      0, NULL);
   GgiSetPosition(zprofbut,  0, slicemenu, 0, NULL);
   GgiSetPosition(helpmenu,  xywidth-GgiWidth(helpmenu)-6, NULL, 0, NULL);

   GgiSetPosition(colorbut,  0, NULL,      0, filemenu);
   GgiSetPosition(contb  ,   0, colorbut,  0, filemenu);
   GgiSetPosition(markb  ,   0, contb,     0, filemenu);
   GgiSetPosition(intpbut,   0, markb,     0, filemenu);



   (void)GgiUseShell(frmbox);
   GgiSetPosition(GgiCanvas(" ", 1, 1), xywidth-1-6, NULL, 0, NULL);


   Coledit("COLOR=", 17, IMAGECOLORS-1, 16);
   Frames("_EXTSET=", xyplot, frmbox);
   Guilines("_POP_LINES=");
   Guiellipse("_POP_ELLIPSE=");
   Guispline("_POP_SPLINE=");
   Guicont("_POP_CONT=");
   Guimark("_POP_FLAG=");
   Zprof("_POP_ZPROF=");
    
   GgiRealize();
   
   (void)ScheduleKeyevent(handle_file,  "FILE=",    KEYCHANGE, NULL);
   (void)ScheduleKeyevent(handle_slice, "SLICE=",   KEYCHANGE, NULL);
   (void)ScheduleKeyevent(handle_ok,    "INSET=",   KEYCHANGE, NULL);
   (void)ScheduleKeyevent(handle_ok,    "BOX=",     KEYCHANGE, NULL);
}

/* ========================================================================== */
/*                                 gui_status                                 */
/* -------------------------------------------------------------------------- */
/*  Interface routine to display a status message.
 */
void gui_status(char *message, int lineno)
{
   GgiSetLabel(l_status[lineno%STATUSLINES], message, 0);
} 

/* ========================================================================== */
/*                                 gui_info                                   */
/* -------------------------------------------------------------------------- */
/*  Interface routine to display an info line.
 */
void gui_info(int lineno, char *message)
{
   GgiSetLabel(l_info[lineno%INFOLINES], message, 0);
} 

/* ========================================================================== */
/*                                 gui_error                                  */
/* -------------------------------------------------------------------------- */
/*  Interface routine to display an error message.
 */
void gui_error(char *message)
{
   char buffer[512];
   
   if (*message) {
      sprintf(buffer,"%s",message);
      GgiSetLabel(l_error, buffer, 0);
   } else {
      GgiSetLabel(l_error, " ", 0);
   }
}

/* ========================================================================== */
/*                                 gui_xyframes                               */
/* -------------------------------------------------------------------------- */
int gui_xyframes(int requested)
{
   int nframes;
   nframes = GgiPlotFrames(xyplot, requested+EXTRAFRAMES);
   MovieFrames(nframes, nframes-requested);
   return nframes;
}


#if defined(TESTBED)  /* ++++++++++++++++++++++++++++++++++++++++++++++++++ */
#include "init.h"
#include "finis.h"
#include "eventmonitor.h"
#include "cmain.h"

static void setmessage(ident id, void *arg)
{
   static int mesno=0;
   char message[80];
   
   sprintf(message,"Status message %d (%o Oct, %X Hex)", mesno, mesno, mesno);
   gui_status(message,mesno);
   gui_info(mesno,message);
   gui_zprof_info(mesno%3, message);
   gui_line_status(mesno%3, message);   
   mesno++;
}

static void seterror(ident id, void *arg)
{
   static int mesno=1;
   char message[80];  

   sprintf(message,"Error message %d (%o Oct, %X Hex)", mesno, mesno, mesno);
   mesno++;
   if (mesno%2) gui_error(message); else gui_error("");
}
 
static void handle_zprof(ident id, char* key, int code, void *arg)
{
   bool button=toflog(FALSE);
    
   (void)userflog(&button, 1, 2, key, " ");
   if (!tobool(button)) {
      (void)DescheduleKeyevent(&id);
      (void)pgopen_c(tofchar("ZPROF"));
      anyoutf(0, "ZPROF plot device opened");
   }
}

static void quit(ident id, char* key, int code, void *arg)
{
   bool button=toflog(FALSE);
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      wkeyf(key);
      finis_c();
   }
}


MAIN_PROGRAM_ENTRY
{
   init_c();
   gui();
   pgopen_c(tofchar("XYPLOT"));
#if 1
   (void)gui_xyframes(15);
   FrameText(16, "This is frame sixteen");
#endif
   (void)ScheduleTimer(setmessage,  3 SECONDS, NULL);
   (void)ScheduleTimer(seterror,    5 SECONDS, NULL);
   eventmonitor("MONITOR=", TRUE);
   (void)ScheduleKeyevent(handle_zprof, "_POP_ZPROF=", KEYCHANGE, NULL);
   (void)ScheduleKeyevent(quit, "QUIT=", KEYCHANGE, NULL);
   MainLoop();
}
#endif

#<

#>            utils.c
/* utils.c
                           COPYRIGHT (c) 1999
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/

#include    "common.h"
#include    "utils.h"
#include    "gui.h"
#include    "time.h"
#include    "matrix.h"
#include    "nelc.h"
#include    "gdsa_delcol.h"
#include    "gdsa_crecol.h"
#include    "gdsa_wcreal.h"
#include    "gdsa_wcint.h"
#include    "gdsa_colinq.h"


extern float fblank;


#define VARRECLEN      132             /* Variable reclen. for table comments */
#define ITEMLEN        8
#define TABNAME        "LUTS"


#define fmake(fchr,size) { \
                           static char buff[size+1]; \
                           int i; \
                           for (i = 0; i < size; buff[i++] = ' '); \
                           buff[i] = 0; \
                           fchr.a = buff; \
                           fchr.l = size; \
                         }
#define fcopy( f, c )                   \
        {int k;for(k=0;c[k]&&k<f.l;f.a[k]=c[k],k++);while(k<f.l)f.a[k++]=' ';}


bool UserLog(char *key)
/*------------------------------------------------------------*/
/* Purpose: Special version of userlog with default.          */
/*------------------------------------------------------------*/
{
   bool result = toflog(FALSE);
   fint fint1 = 1, fint2 = 2;

   (void) userlog_c( &result, &fint1, &fint2, tofchar(key), tofchar(" ") );
   return( tobool(result) );
}   



int emptykey( char  *key )
/*------------------------------------------------------------*/
/* Purpose: Check whether a keyword has contents or not.      */
/*------------------------------------------------------------*/
{
   fchar  Dummytxt;
   char   buf[512+1];
   fint   dfault = 2;    /* hidden */
   fint   r;
   
   
   Dummytxt.a = buf;
   Dummytxt.l = 512;
   r = usertext_c( Dummytxt, &dfault, tofchar(key), tofchar("") );
   return( !r );
}


void hermesstatus( char *txt )
/*------------------------------------------------------------*/
/* PURPOSE: Update status in hermes status                    */                
/*------------------------------------------------------------*/                
{
   status_c( tofchar(txt) );                                                    
}



extern void error_status( char *errstr,
                          char *statstr1,
                          char *statstr2 )
/*------------------------------------------------------------*/
/* PURPOSE: Update status and error messages in gui.          */
/*------------------------------------------------------------*/
{
   gui_error( errstr );
   gui_status( statstr1, 0 );
   gui_status( statstr2, 1 );
}




void clearstatus( void )
/*------------------------------------------------------------*/
/* PURPOSE: Clear status and error messages in gui.           */
/*------------------------------------------------------------*/
{
   gui_error( "" );
   gui_status( H_MOUSE_DISP, 1 );
   gui_status( H_KEY_DISP, 2 );   
   hermesstatus("");
}



void clearfchar( fchar Str )
/*------------------------------------------------------------*/
/* PURPOSE: Set all chars. in a Fortran string to a space.    */
/*------------------------------------------------------------*/
{
   int   i,l;

   l = Str.l;
   for (i = 0; i < l; i++)
      Str.a[i] = ' ';
} 


int quadrant( double angle )
/*---------------------------------------------------------*/
/* Convert an angle to its quadrant.                       */
/*---------------------------------------------------------*/
{
   angle = fmod( angle, 360.0 );
   if (angle < 0.0)
      angle += 360.0;
   if (angle <= 90.0)  return 1;
   if (angle <= 180.0) return 2;
   if (angle <= 270.0) return 3;
   if (angle <= 360.0) return 4;
   return 1;  /* dummy */
}



float putinrangedeg( float angle )
/*------------------------------------------------------------*/
/* PURPOSE: Return angle between 0 and < 360.0                */
/*------------------------------------------------------------*/
{
   while (angle < 0.0)
      angle +=360.0;
   while (angle > 360.0)
      angle -=360.0;
   return( angle );
}



double putinrangerad( double angle )
/*------------------------------------------------------------*/
/* PURPOSE: Return angle between 0 and < 2*PI                 */
/*------------------------------------------------------------*/
{
   double twopi = 2.0*PI;
   while (angle < 0.0)
      angle += twopi;
   while (angle > twopi)
      angle -= twopi;
   return( angle );
}


double sign( double x )
/*------------------------------------------------------------*/
/* PURPOSE: Return -1 if x < 0.0 else return 1                */
/*------------------------------------------------------------*/
{
   if (x < 0.0)
      return( -1.0 );
   return( 1.0 );
}


double arctan( double y, double x )
/*------------------------------------------------------------*/
/* PURPOSE: Return arctangens between 0 and < 360.0           */
/*------------------------------------------------------------*/
{
   double r;
   r = atan2( y, x );
   if (r < 0.0)
      r += 2.0*PI;
   return( r );
}



double atantan( double   beta,
                double   y )
/*------------------------------------------------------------*/
/* PURPOSE: Return:  theta = atan[ tan(beta)/y ]              */
/*                                                            */
/* Input is an angle beta in radians and a value y. The       */
/* function atan2(tan(x)) does not preserve the sign of x.    */
/* Therefore a correction is made for the various intervals.  */
/* atan2( 89,1 )  =  89                                       */
/* atan2( 91,1 )  = -89                                       */
/* atan2( 179,1 ) = -1                                        */
/* atan2( 181,1 ) =  1                                        */
/* atan2( 269,1 ) =  89                                       */
/* atan2( 271,1 ) = -89                                       */
/*------------------------------------------------------------*/
{
   double twopi = 2.0*PI;
   double pidiv2 = PI/2.0;
   double a1 = beta;
   double a2;

   while (a1 < 0.0)
      a1 += twopi;
   while (a1 > twopi)
      a1 -= twopi;
   a2 = atan2( tan(a1), y );
   if (a1 < pidiv2)
      return( a2 );
   if (a1 == pidiv2)
      return( pidiv2 );
   if (a1 < 3.0*pidiv2)
      return( PI + a2 );
   if (a1 == 3.0*pidiv2)
      return( 3.0*pidiv2 );
   return(twopi + a2);
}



void stamp( char *mes )
/*------------------------------------------------------------*/
/* PURPOSE: Put time and user name in string.                 */
/*------------------------------------------------------------*/
{
   struct tm   *ptr;
   time_t      lt;


   lt    = time( NULL );                       /* Get the coded calendar time */
   ptr   = localtime( &lt );
   strftime( mes, 128, "%d-%b-%Y (%H:%M:%S)", ptr );
}



int nearestinarray( float  x,
                    float  y,
                    float *Xpos,
                    float *Ypos,
                    int    ndat,
                    float  nearmax )
/*------------------------------------------------------------------*/
/* PURPOSE: Find nearest point in array with respect to the mouse   */
/*          position x, y. Include all sample points in search.     */
/*          Mouse positions further away than 'nearmax' grids from  */
/*          an array position, are omitted.                         */ 
/*------------------------------------------------------------------*/
{
   float D, Dmin, Dmax = nearmax;
   float blank;
   int   i;
   int   indxmin = -1;
   int   n = ndat;


   setfblank_c( &blank );
   Dmin = blank;

   for (i = 0; i < n; i++)
   {
      float dx = Xpos[i] - x;
      float dy = Ypos[i] - y;
      D = sqrt( dx*dx + dy*dy );
      if (D < Dmax)
      {
         if (Dmin == blank)
         {
            Dmin = D;
            indxmin = i;
         }
         else
         {
            if (D < Dmin)
            {
               Dmin = D;
               indxmin = i;
            }
         }
      }
   }
   /* The index is either a value between 0..n-1 or -1 if there is not   */
   /* a nearest position (i.e. mouse too far away from all array points. */

   return( indxmin );
}


void helpinstatus( int mode )
/*------------------------------------------------------------*/
/* PURPOSE: Put help lines in status area.                    */
/*------------------------------------------------------------*/
{
   if (mode == LINE)
   {
      gui_status( H_MOUSE_LINE, 1 );
      gui_status( H_KEY_LINE, 2 );
   }
   else if (mode == ELLIPSE)
   {
      gui_status( H_MOUSE_ELLIPSE, 1 );
      gui_status( H_KEY_ELLIPSE, 2 );
   }
   else if (mode == SPLINE)
   {
      gui_status( H_MOUSE_SPLINE, 1 );
      gui_status( H_KEY_SPLINE, 2 );
   }
   else
   {
      clearstatus();
   }
}


void deputyerror( fint err, char *mes )
/*------------------------------------------------------------*/
/* PURPOSE: Return reason why deputy task failed.             */
/*------------------------------------------------------------*/
{
    if (err == -6)
       strcpy( mes, "Task not present" );
    else if (err == -7)  
       strcpy( mes, "Max. number of tasks already active" );
    else if (err == -8)  
       strcpy( mes, "Fatal error" );
    else if (err == -9)  
       strcpy( mes, "User abort" );
    else if (err == -10)  
       strcpy( mes, "Crash" );
    else if (err == -11)  
       strcpy( mes, "Aborted due to no-default user input request" );    
}


int deputyC( char *taskname, int list )
/*------------------------------------------------------------*/
/* PURPOSE: C version of deputy  with list control.           */
/*------------------------------------------------------------*/
{
   fint  hermesold;
   fint  hermesnew = (fint) list;
   fint  r = 0;
   
   hermesold = listctrl_c( &hermesnew );      
   deputy_c( tofchar( taskname ) , &r ) ;
   (void) listctrl_c( &hermesold );   /* Reset output mode */
   return( (int) r );
}



static int colexist( fchar Setin,
                     fint  subset,
                     fchar Tname,
                     fchar Cname )
/*------------------------------------------------------------*/
/* PURPOSE: Does a column in this table in this set exists?   */
/*------------------------------------------------------------*/
{
   fint    r1 = 0;
   fint    nrows;
   fchar   Units;
   fchar   Comment;
   fchar   Type;

   fmake( Units,   VARRECLEN );
   fmake( Comment, VARRECLEN );
   fmake( Type,    VARRECLEN );

   gdsa_colinq_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &nrows, &r1 );
   if (r1 < 0)
   {
      anyoutf( 16, "Cannot get info from column [%.*s] in set [%.*s]",
               nelc_c(Cname), Cname.a, nelc_c(Setin), Setin.a );
      return( 0 );
   }
   return( 1 );
}



int luttotable( fchar Setin,
                fint  subset,
                fint  lutlen,
                float *lutr,
                float *lutg,
                float *lutb,
                fint  GIDSmincol,
                fint  GIDSmaxcol,
                fint  GIDSncolors,
                float GIDSbscale,
                float GIDSbzero,
                fint  GIDSblank )
/*------------------------------------------------------------*/
/* PURPOSE: Store in the header of 'Setin' the lut parameters */
/*          in a table.                                       */
/* The lut parameters are three arrays with the RGB values.   */
/* The arrays have length 'lutlen'. Scaling is done with the  */
/* values of 'GIDSmincol/maxcol', and 'GIDSbscale/bzero'.     */
/*------------------------------------------------------------*/
{
   fchar   Cname;
   fchar   Tname;
   fchar   Units;
   fchar   Comment;
   fchar   Type;
   fint    r1;
   fint    one = 1;


   fmake( Tname,   ITEMLEN );
   fmake( Cname,   ITEMLEN );
   fmake( Units,   VARRECLEN );
   fmake( Comment, VARRECLEN );
   fmake( Type,    VARRECLEN );

   fcopy( Tname, TABNAME );
   fcopy( Cname, "LUTR" );
   fcopy( Units, "NONE" );
   if ( colexist( Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Type, "REAL" );
   fcopy( Comment, "Lut array RED" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );

   fcopy( Cname, "LUTG" );
   if ( colexist( Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Comment, "Lut array GREEN" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );

   fcopy( Cname, "LUTB" );
   if ( colexist( Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Comment, "Lut array BLUE" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );

   r1 = 0;
   gdsa_wcreal_c( Setin, &subset, Tname, tofchar("LUTR"), lutr, &one, &lutlen, &r1 );
   r1 = 0;
   gdsa_wcreal_c( Setin, &subset, Tname, tofchar("LUTG"), lutg, &one, &lutlen, &r1 );
   r1 = 0;
   gdsa_wcreal_c( Setin, &subset, Tname, tofchar("LUTB"), lutb, &one, &lutlen, &r1 );

   fcopy( Cname, "LUTLEN" );
   if ( colexist(Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Type, "INT" );
   fcopy( Comment, "Lut array length" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );
   r1 = 0;
   gdsa_wcint_c( Setin, &subset, Tname, Cname, &lutlen, &one, &one, &r1 );

   fcopy( Cname, "MINCOL" );
   if ( colexist( Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Type, "INT" );
   fcopy( Comment, "Minimum colour index" );
   r1 = 0; 
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );
   r1 = 0; 
   gdsa_wcint_c( Setin, &subset, Tname, Cname, &GIDSmincol, &one, &one, &r1 );

   fcopy( Cname, "MAXCOL" );
   if ( colexist( Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Type, "INT" );
   fcopy( Comment, "Maximum colour index" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );
   r1 = 0;
   gdsa_wcint_c( Setin, &subset, Tname, Cname, &GIDSmaxcol, &one, &one, &r1 );

   fcopy( Cname, "NCOLORS" );
   if ( colexist( Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Type, "INT" );
   fcopy( Comment, "Maximum number of colours" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );
   r1 = 0;
   gdsa_wcint_c( Setin, &subset, Tname, Cname, &GIDSncolors, &one, &one, &r1 );

   fcopy( Cname, "BSCALE" );
   if ( colexist( Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Type, "REAL" );
   fcopy( Comment, "Colour scaling (bscale)" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );
   r1 = 0;
   gdsa_wcreal_c( Setin, &subset, Tname, Cname, &GIDSbscale, &one, &one, &r1 );

   fcopy( Cname, "BZERO" );
   if ( colexist( Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Type, "REAL" );
   fcopy( Comment, "Colour offset (bzero)" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );
   r1 = 0;
   gdsa_wcreal_c( Setin, &subset, Tname, Cname, &GIDSbzero, &one, &one, &r1 );

   fcopy( Cname, "BLANKIND" );
   if ( colexist(Setin, subset, Tname, Cname) )
   {
      r1 = 0;
      gdsa_delcol_c( Setin, &subset, Tname, Cname, &r1 );
   }
   fcopy( Type, "INT" );
   fcopy( Comment, "Colour index of a blank" );
   r1 = 0;
   gdsa_crecol_c( Setin, &subset, Tname, Cname, Type, Comment, Units, &r1 );
   r1 = 0;
   gdsa_wcint_c( Setin, &subset, Tname, Cname, &GIDSblank, &one, &one, &r1 );

   return( 1 );
}

#<

#>            plot.c
/* plot.c


                          COPYRIGHT (c) 1996
                    Kapteyn Astronomical Institute
               University of Groningen, The Netherlands
                        All Rights Reserved.

*/

#include    "common.h"
#include    "gui.h"
#include    "pgplot.h"       /* All PGPLOT includes. */
#include    "pgsbci.h"
#include    "plot.h"


extern float    fblank;
extern double   dblank;


void setchsize( float ch )
/*-------------------------------------------------------------*/
/* PURPOSE: Set character height.                              */
/*-------------------------------------------------------------*/
{
   pgsch_c( &ch );
}



float maxviewport( float charmm )
/*-------------------------------------------------------------*/
/* PURPOSE: Get max viewport so that labels are inside device. */
/* Input parameter is the character size in mm.                */
/*-------------------------------------------------------------*/
{
   float    oldvp[4];
   fint     normalized = 0;
   fint     mm = 2;
   float    nxlo, nxhi, nylo, nyhi;
   float    vp1, vp2;
  
 
   /* Store current viewport */
   pgqvp_c( &normalized, &oldvp[0], &oldvp[1], &oldvp[2], &oldvp[3] );   
   
   /* Set the viewport to the entire surface */
   nxlo = 0.0; nylo = 0.0; nxhi = 1.0; nyhi = 1.0;
   pgsvp_c( &nxlo, &nxhi, &nylo, &nyhi );
   
   /* What is this in mm? */
   pgqvp_c( &mm, &nxlo, &nxhi, &nylo, &nyhi );

   /* First in y direction. We need at least 3 extra char heights */
   vp1 = (nyhi - 20.0 - 3.5 * charmm) / nyhi;
   vp2 = (nxhi - 20.0 - 2.5 * charmm) / nxhi;
   if (vp1 < 0.0) vp1 = 0.5;
   if (vp2 < 0.0) vp2 = 0.5;   
   
   /* Reset old viewport */
   pgsvp_c( &oldvp[0], &oldvp[1], &oldvp[2], &oldvp[3] );    
   return( MYMIN(vp1, vp2) );
}




void setchmm( float chmm )
/*-------------------------------------------------------------*/
/* PURPOSE: Set character height number so that the height     */
/*          corresponds to 'chmm' millimeter.                  */
/*-------------------------------------------------------------*/
{
   fint     mm = 2;
   float    xch, ych;
   
   setchsize( 1.0 );
   pgqcs_c( &mm, &xch, &ych );
   setchsize( chmm / ych );
}




void setwindow( float xlo,
                float ylo,
                float xhi, 
                float yhi )
/*-------------------------------------------------------------*/
/* PURPOSE: Set window                                         */
/*-------------------------------------------------------------*/
{
   pgswin_c( &xlo, &xhi, &ylo, &yhi );
}



void setviewport( float xlo,
                  float ylo,
                  float xhi, 
                  float yhi )
/*-------------------------------------------------------------*/
/* PURPOSE: Set viewport.                                      */
/*-------------------------------------------------------------*/
{
   pgsvp_c( &xlo, &xhi, &ylo, &yhi );
}



void setstandardviewport( void )
/*-------------------------------------------------------------*/
/* PURPOSE: Set viewport.                                      */
/*-------------------------------------------------------------*/
{
   setviewport( VPXLO, VPYLO, VPXHI, VPYHI );
}
               


void setlinestyle( int  style )
/*-------------------------------------------------------------*/
/* PURPOSE: Set line style.                                    */
/*-------------------------------------------------------------*/
{
   fint   Style = (fint) style;
   pgsls_c( &Style );
}



void setcolor( int col )
/*-------------------------------------------------------------*/
/* PURPOSE: Set color to 'col'.                                */
/* Alternative pgsci.                                          */
/*-------------------------------------------------------------*/
{
   fint   Col = (fint) col;
   pgsci_c( &Col );
}


void setwidth( int width )
/*-------------------------------------------------------------*/
/* PURPOSE: Set line width to 'width'.                         */
/* Alternative pgslw.                                          */
/*-------------------------------------------------------------*/
{
   fint    Width = (fint) width;
   pgslw_c( &Width );
}


void setfont( int font )
/*-------------------------------------------------------------*/
/* PURPOSE: Set font to 'font'                                 */
/*-------------------------------------------------------------*/
{
   fint    Font = (fint) font;
   pgscf_c( &Font );
}


void plmove( float x, float y )
/*-------------------------------------------------------------*/
/* PURPOSE: Alternative for pgmove.                            */
/*-------------------------------------------------------------*/
{
   pgmove_c( &x, &y );
}


void pldraw( float x, float y )
/*-------------------------------------------------------------*/
/* PURPOSE: Alternative for pgdraw.                            */
/*-------------------------------------------------------------*/
{
   pgdraw_c( &x, &y );
}


void pltext( float   x,
             float   y,
             float   angle,
             float   fjust,
             char   *text )
/*-------------------------------------------------------------*/
/* PURPOSE: Alternative for pgtxt.                             */
/*-------------------------------------------------------------*/
{
   pgptxt_c( &x, &y, &angle, &fjust, tofchar(text) );
}



void plsymbol( float x, float y, int symbol,
               float charh, int linewidth, int colour )
/*-------------------------------------------------------------*/
/* PURPOSE: Alternative for pgpt.                              */
/* Is used 'extern'.                                           */
/*-------------------------------------------------------------*/
{
   fint  num = 1;
   fint  symnr = (fint) symbol;
   fint  col = (fint) colour;
   fint  lw  = (fint) linewidth;
   fint  oldcol, oldlw;
   float oldch;


   pgqch_c( &oldch );
   pgqlw_c( &oldlw );
   pgqci_c( &oldcol );
   setchsize( charh );
   setwidth( lw );
   setcolor( col );   
  
   pgpt_c( &num, &x, &y, &symnr );
   
   setchsize( oldch );
   setwidth( oldlw );   
   setcolor( oldcol );
}



void plpoints( float *x, float *y, int ndat, int symbol )
/*-------------------------------------------------------------*/
/* PURPOSE: Alternative for pgpt.                              */
/*-------------------------------------------------------------*/
{
   fint    num = (fint) ndat;
   fint    symnr = (fint) symbol;

   pgpt_c( &num, x, y, &symnr );
}




void plarrow( float x1, float y1, float x2, float y2, 
              float charh, int linewidth, int colour )
/*-------------------------------------------------------------*/
/* PURPOSE: Alternative for pgarro.                            */
/*-------------------------------------------------------------*/
{
   fint  col = (fint) colour;
   fint  lw  = (fint) linewidth;
   fint  oldcol, oldlw;
   float oldch;


   pgqch_c( &oldch );
   pgqlw_c( &oldlw );
   pgqci_c( &oldcol );
   setchsize( charh );
   setwidth( lw );
   setcolor( col );
   pgarro_c( &x1, &y1, &x2, &y2 );
   setchsize( oldch );
   setwidth( oldlw );   
   setcolor( oldcol );
}



void plrect( float  *box,
             int     colour )
/*-------------------------------------------------------------*/
/* PURPOSE: Alternative for pgrect.                            */
/*-------------------------------------------------------------*/
{
   fint   hollow = 2;

   pgsfs_c( &hollow );
   setcolor( colour );
   pgrect_c( &box[0], &box[2], &box[1], &box[3] );
}




void setmarker( float x, float y, fint sym )
/*-------------------------------------------------------------*/
/* PURPOSE: Set marker op x, y.                                */
/*-------------------------------------------------------------*/
{
   fint one = 1;
   pgpt_c( &one, &x, &y, &sym );
} 



void setinterpolation( bool interpol )
/*-------------------------------------------------------------*/
/* PURPOSE: Set interpolation for PGIMAG.                      */
/*-------------------------------------------------------------*/
{
   fint   ip = 0;
   
   if (interpol)
      ip = 1;
      
   pgsimi_c( &ip );
}



void selectplot( int id )
/*------------------------------------------------------------*/
/* PURPOSE: Select plot                                       */
/*------------------------------------------------------------*/
{
   fint r = id;
   pgslct_c( &r );   
}


void clearpage( void )
/*-------------------------------------------------------------*/
/* PURPOSE: Alternative for pgpage.                            */
/* Is used 'extern'.                                           */
/*-------------------------------------------------------------*/
{
   pgpage_c();
}



void plellipse( float cx,
                float cy,
                float maj,
                float min,
                float angle,
                float start,
                float end )
/*-------------------------------------------------------------*/
/* PURPOSE: Fast ellipse plotter.                              */
/* Draw ellipse from angle 'start' to angle 'end'.             */
/*-------------------------------------------------------------*/
{
#define NUMPOINTS  180
   float   CosP  = (float) cos( RAD(angle) );
   float   SinP  = (float) sin( RAD(angle) );
   float   Dphi;
   float   X[NUMPOINTS+1];
   float   Y[NUMPOINTS+1];
   float   adivb, bdiva;
   float   cosdphi, sindphi;
   int     i;
   fint    numpoints = NUMPOINTS;
   
  
   /*--------------------------------------------------*/
   /* Generate 'numpoints' unique points on the        */
   /* ellipse. Note that first and last points are     */
   /* coincident.                                      */
   /*--------------------------------------------------*/
   Dphi = 2.0*PI/(double) NUMPOINTS;
   X[0] = maj;
   Y[0] = 0.0;
   
   adivb = maj / min;
   bdiva = min / maj; 
   sindphi = (float) sin( Dphi );   
   cosdphi = (float) cos( Dphi );
   for (i = 1; i < NUMPOINTS; i++)
   {
      X[i] = X[i-1] * cosdphi - adivb * Y[i-1] * sindphi;
      Y[i] = bdiva * X[i-1] * sindphi + Y[i-1] * cosdphi;
   }
   for (i = 0; i < NUMPOINTS; i++)
   {
      float x = X[i];
      float y = Y[i];
      X[i] = x * CosP - y * SinP  + cx;
      Y[i] = x * SinP + y * CosP  + cy;      
   }
   pgline_c( &numpoints, X, Y );
}



fint initplot( char *dev, 
               int  rows, 
               int  cols )
/*------------------------------------------------------------*/ 
/* PURPOSE: Initialize PGPLOT                                 */
/* We have more plot windows to process. Therefore pgbeg is   */
/* replaced by pgopen.                                        */
/* r = pgbeg_c( &unit, tofchar( dev ),&nxysub[0],&nxysub[1] );*/
/* In this stage a plot window is already opened by gui.c     */               
/*------------------------------------------------------------*/
{                                                                       
   fint      r;
   fint      ny = (fint) rows;
   fint      nx = (fint) cols;
   bool      paging;
   fint      font = ROMAN;      /* Single stroke */
                                                                        
   r = pgopen_c( tofchar(dev) );                                        
   if (r <= 0)  
      return( -1 );
   pgsubp_c( &nx, &ny );
   paging = toflog( NO );
   pgask_c( &paging );
   pgscf_c( &font ); 
   return( r );
}                                                                



void labelsubset( char  *mes, 
                  int   col )
/*------------------------------------------------------------*/                
/* PURPOSE: Plot a label somewhere above the plot.            */
/*------------------------------------------------------------*/
{
   float     disp  = 3.0;
   float     coord = 0.0;
   float     fjust = 0.0;
   fint      oldcol;


   fjust = coord;
   pgqci_c( &oldcol );
   setcolor( col );
   pgmtxt_c( tofchar("T"), &disp, &coord, &fjust, tofchar(mes) );
   setcolor( oldcol ); 
}
#<

#>            coledit.c
/* coledit.c
                              COPYRIGHT (c) 1999
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands

Author: J.P. Terlouw
*/

#define NAME "Edit color map"

#include "stddef.h"
#include "stdio.h"
#include "string.h"
#include "gipsyc.h"
#include "userfio.h"
#include "ggi.h"
#include "gui.h"
#include "coledit.h"

static ident editor;
static bool state=FALSE;     /* visibility */
static bool rchng=FALSE;     /* limits changed */
static bool allowupd=TRUE;   /* allow limits update */
static float lower, upper;   /* saved limits */
static char  sunits[10];     /* saved units */
                                                                                                                                                                                                               
/* -------------------------------------------------------------------------- */
/*                                 popshell                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void popshell(ident id, char *key, int code, void *arg)
{  
   bool button=toflog(FALSE);
 
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell((ident)arg, !state);
      if (!TriggerKey("CE_SLOPE1=")) wkeyf("CE_SLOPE1= 1.0");
      if (!TriggerKey("CE_SHIFT1=")) wkeyf("CE_SHIFT1= 0.0");
      state = !state;
      wkeyf(key);
   }
}

/* ========================================================================== */
/*                                  gui_applycol                              */
/* -------------------------------------------------------------------------- */
void gui_applycol(void)
{
   (void)GgiPlotColorEditor(ggiApply, editor);
}

/* ========================================================================== */
/*                                  gui_colormap                              */
/* -------------------------------------------------------------------------- */
void gui_colormap(int ncolors, float *reds, float *greens, float *blues,
                               float *bred, float *bgreen, float *bblue)
{
   (void)GgiPlotColorEditor(ggiGetMap, editor, ncolors, reds, greens, blues,
                                                        bred, bgreen, bblue);
}

/* ========================================================================== */
/*                                  gui_datarange                             */
/* -------------------------------------------------------------------------- */
void gui_datarange(float v1, float v2)
{
   if (allowupd) {
      (void)GgiPlotColorEditor(ggiLimits, editor, v1, v2);
   } else {
      lower = v1;
      upper = v2;
      rchng = TRUE;
   }
}

/* ========================================================================== */
/*                                  gui_units                                 */
/* -------------------------------------------------------------------------- */
void gui_units(char *units)
{
   if (allowupd) {
      (void)GgiPlotColorEditor(ggiUnits, editor, units);
   } else {
      strncpy(sunits, units, 9);
   }
}

/* ========================================================================== */
/*                                  gui_colupd                                */
/* -------------------------------------------------------------------------- */
void gui_colupd(bool allow)
{
   allowupd = allow;
   if (allowupd && rchng) {
      (void)GgiPlotColorEditor(ggiLimits, editor, lower, upper);
      (void)GgiPlotColorEditor(ggiUnits, editor, sunits);
      rchng = FALSE;
   }
}

/* ========================================================================== */
/*                                  Coledit                                    */
/* -------------------------------------------------------------------------- */
/*   Coledit() creates a pop-up shell for editing colour map
 */
void  Coledit(char *key, int ci, int nc, int bl)
{
   static ident s_coledit;
   ident s_prev;
   ident closebut;
    
   s_coledit = GgiShell(NAME);
   s_prev  = GgiUseShell(s_coledit);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   editor = GgiPlotColorEditor(ggiCreate, ci, nc, bl);
   GgiSetPosition(editor,   0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, editor);
   ScheduleKeyevent(popshell, key, KEYCHANGE, s_coledit);
   (void)GgiUseShell(s_prev);
}
#<

#>            mouse.c
/* mouse.c
                           COPYRIGHT (c) 2000
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/


#include    "sliceview.h"
#include    "mouse.h"
#include    "utils.h"
#include    "gui.h"
#include    "plot.h"
#include    "pgsbci.h"
#include    "pgplot.h"
#include    "drawaxis.h"
#include    "interpol.h"
#include    "spline.h"
#include    "gdsd_rint.h"
#include    "gds_extend.h"
#include    "gdsd_wchar.h"
#include    "gdsd_wdble.h"
#include    "gds_create.h" 
#include    "minmax1.h"
#include    "matrix.h"
#include    "hmsdmsC.h"


#define TITLEOFF_X       0.4             /* An offset scaled with char. height */
#define TITLEOFF_Y       1.2 

extern float fblank;


void getsampleangle(   ident id, char *key, int code, void *arg );
void getsamplelen(     ident id, char *key, int code, void *arg );
void getxvfromline(    globaltype *g, int extract );
void getxvfromellipse( globaltype *g, int extract );
void getxvfromspline(  globaltype *g );
void getxcyc(          ident id, char *key, int code, void *arg );
void readsinglesub(      int subsetindx, globaltype *g );
void displayexternalset( int indx, globaltype *g );
void getbox( ident id, char  *key, int   code, void  *arg );


void annotateimage( globaltype  *g,
                    int          colour )
/*------------------------------------------------------------*/
/* PURPOSE: Make a frame with grid and physical coordinate    */
/*          labels for the subset image.                      */
/*------------------------------------------------------------*/
{
   /* Variables to interface with external drawaxis routine */

   double  origmm[2], scale[2];
   fint    r;
   double  gridmargin[2];
   double  box[4];
   bool    setexist = toflog( YES );
   fint    ldev = 1;
   double  ticksize = 2;        /* 2 mm */
   fint    axminors = -1;
   double  *axlogs = NULL;
   fint    axloglen = 0;
   double  cgstep = 1.0;
   fchar   Title_id;
   fchar   Axtitle;
   double  titleXY[8];
   char    *axiscommand[4] = {"BPI10", "LPI10", "RWI10", "TWI10"};
   fint    oldcol;

   /* Other variables */

   fint     norm = 0, mm = 2;
   float    vpxlo, vpxhi, vpylo, vpyhi;
   float    mmxlo, mmxhi, mmylo, mmyhi;
   float    nxlo, nxhi, nylo, nyhi;
   float    wxlo, wxhi, wylo, wyhi;
   float    oldsize;
   int      i;
   float    charmm;
   

   charmm = CHARHEI;
  
   pgqci_c( &oldcol );
   setcolor( colour ); 
  
   /* Save current viewport */
   pgqvp_c( &norm, &vpxlo, &vpxhi, &vpylo, &vpyhi );

   /* What is this viewport in mm? */
   pgqvp_c( &mm, &mmxlo, &mmxhi, &mmylo, &mmyhi );

   /* What is the curent window */
   pgqwin_c( &wxlo, &wxhi, &wylo, &wyhi );

   box[0] = (double) wxlo;
   box[1] = (double) wylo;
   box[2] = (double) wxhi;
   box[3] = (double) wyhi;

   /* Then we can calculate origin and scale in mm as needed */
   /* in the external routine 'drawaxis'.                    */
   origmm[0] = mmxlo;
   origmm[1] = mmylo;
   scale[0] = (wxhi - wxlo) / (mmxhi-mmxlo);
   scale[1] = (wyhi - wylo) / (mmyhi-mmylo);

   /* Set the viewport to the entire surface */
   nxlo = 0.0; nylo = 0.0; nxhi = 1.0; nyhi = 1.0;
   pgsvp_c( &nxlo, &nxhi, &nylo, &nyhi );
   /* What is this in mm? */
   pgqvp_c( &mm, &nxlo, &nxhi, &nylo, &nyhi );
   /* Set the window to this amount in mm because 'drawaxis' works in mm */
   pgswin_c( &nxlo, &nxhi, &nylo, &nyhi );

   /* Call the 'drawaxis' function. */
   fmake( Axtitle, 128 );
   fmake( Title_id, 1 );

   for (i = 0; i < 8; i++)
      titleXY[i] = dblank;

   gridmargin[0] = gridmargin[1] = 0.0;

   pgqch_c( &oldsize );
   setchmm( charmm );

   for (i = 0; i < 4; i++)
   {            
      r = drawaxis_c( tofchar( axiscommand[i] ),
                            gridmargin,
                            scale,
                            origmm,
                            box,
                            &setexist,
                            g->inset.Name,
                            &(g->inset.subsets[0]),
                            &ldev,
                            &ticksize,
                            tofchar(""),
                            tofchar(""),
                            &axminors,
                            tofchar(""),
                            axlogs,
                            &axloglen,
                            &cgstep,
                            Axtitle,
                            titleXY,
                            Title_id );

     
      if (i == 0)  /* Title below bottom axis */
      {
         float  x = (mmxlo+mmxhi)/2.0, y =  mmylo;
         float  angle = 0.0, fjust = 0.5;
         float  yoff;

         yoff = -TITLEOFF_Y * charmm;
         x = titleXY[0]; y = titleXY[1] + yoff;         
         pgptxt_c( &x, &y, &angle, &fjust, Axtitle );
      }
      if (i == 1)  /* Left axis */
      {
         float  x = mmxlo, y = (mmylo+mmyhi)/2.0;
         float  angle = 90.0, fjust = 0.5;
         float  xoff;

         xoff = -TITLEOFF_X * charmm;
         x = titleXY[6] + xoff; y = titleXY[7];                  
         pgptxt_c( &x, &y, &angle, &fjust, Axtitle );
      }
   }
   setchsize( oldsize );
   /* Reset the viewport */
   pgsvp_c( &vpxlo, &vpxhi, &vpylo, &vpyhi );
   pgswin_c( &wxlo, &wxhi, &wylo, &wyhi );
   setcolor( oldcol );
}



static void copyaxis( fchar Setin,
                      int   inpaxisnum,
                      fchar Setout,
                      int   outaxisnum )
/*------------------------------------------------------------*/
/* PURPOSE: Copy CDELT, DDELT, DTYPE from source axis         */
/*          (inpaxisnum) to destination (outaxisnum).         */
/*------------------------------------------------------------*/
{
   fchar     Ctype, Cunit;
   fchar     Dtype, Dunit;
   double    cdelt, ddelt;
   double    crpix;
   double    crval, drval;
   fint      naxis;
   fint      r1;
   char      message[128];


   (void) sprintf( message, "CRPIX%d", inpaxisnum );
   r1 = 0;
   gdsd_rdble_c( Setin, tofchar(message), &setlevel, &crpix, &r1 );

   (void) sprintf( message, "NAXIS%d", inpaxisnum );
   r1 = 0;
   gdsd_rint_c( Setin, tofchar(message), &setlevel, &naxis, &r1 );

   fmake( Ctype, FITSLEN );
   (void) sprintf( message, "CTYPE%d", inpaxisnum );
   r1 = 0;
   gdsd_rchar_c( Setin, tofchar(message), &setlevel, Ctype, &r1 );

   r1 = 0;
   gds_extend_c( Setout, Ctype, &crpix, &naxis, &r1 );

   fmake( Cunit, FITSLEN );
   (void) sprintf( message, "CUNIT%d", inpaxisnum );
   r1 = 0;
   gdsd_rchar_c( Setin, tofchar(message), &setlevel, Cunit, &r1 );
   if (r1 == 0)
   {
      (void) sprintf( message, "CUNIT%d", outaxisnum );
      gdsd_wchar_c( Setout, tofchar(message), &setlevel, Cunit, &r1 );
   }

   (void) sprintf( message, "CRVAL%d", inpaxisnum );
   r1 = 0;
   gdsd_rdble_c( Setin, tofchar(message), &setlevel, &crval, &r1 );
   if (r1 == 0)
   {
      (void) sprintf( message, "CRVAL%d", outaxisnum );
      gdsd_wdble_c( Setout, tofchar(message), &setlevel, &crval, &r1 );
   }


   (void) sprintf( message, "CDELT%d", inpaxisnum );
   r1 = 0;
   gdsd_rdble_c( Setin, tofchar(message), &setlevel, &cdelt, &r1 );
   if (r1 == 0)
   {
      (void) sprintf( message, "CDELT%d", outaxisnum );
      gdsd_wdble_c( Setout, tofchar(message), &setlevel, &cdelt, &r1 );
   }

   /* Secondary info for second axis */

   fmake( Dtype, FITSLEN );
   (void) sprintf( message, "DTYPE%d", inpaxisnum );
   r1 = 0;
   gdsd_rchar_c( Setin, tofchar(message), &setlevel, Dtype, &r1 );
   if (r1 == 0)
   {
      (void) sprintf( message, "DTYPE%d", outaxisnum );
      gdsd_wchar_c( Setout, tofchar(message), &setlevel, Dtype, &r1 );
   }
   
   r1 = 0;
   fmake( Dunit, FITSLEN );
   (void) sprintf( message, "DUNIT%d", inpaxisnum );
   gdsd_rchar_c( Setin, tofchar(message), &setlevel, Dunit, &r1 );
   if (r1 == 0)
   {
      (void) sprintf( message, "DUNIT%d", outaxisnum );
      gdsd_wchar_c( Setout, tofchar(message), &setlevel, Dunit, &r1 );
   }

   (void) sprintf( message, "DRVAL%d", inpaxisnum );
   r1 = 0;
   gdsd_rdble_c( Setin, tofchar(message), &setlevel, &drval, &r1 );
   if (r1 == 0)
   {
      (void) sprintf( message, "DRVAL%d", outaxisnum );
      gdsd_wdble_c( Setout, tofchar(message), &setlevel, &drval, &r1 );
   }
   
   (void) sprintf( message, "DDELT%d", inpaxisnum );
   r1 = 0;
   gdsd_rdble_c( Setin, tofchar(message), &setlevel, &ddelt, &r1 );
   if (r1 == 0)
   {
      (void) sprintf( message, "DDELT%d", outaxisnum );
      gdsd_wdble_c( Setout, tofchar(message), &setlevel, &ddelt, &r1 );
   }
}



void writexv( globaltype *g,
              int        currentxv )
/*------------------------------------------------------------*/
/* PURPOSE: Write the current XV map to a output set.         */
/* Create a set from scratch. The output has 2 axes. The      */
/* first is an offset axis (PARAM-OFFST) in 'Xunits', the     */
/* second is the V-axis, usually velocity.                    */
/*------------------------------------------------------------*/
{ 
   fint     r;
   char     errmes[128];
   fchar    Ctype, Bunit;
   double   crpix, cdelt, crval;
   fint     naxis;
   fint     axnum;
   float    *image = NULL;
   fint     cwloO, cwhiO;       
   char     mes[FILENAMELEN];
 

   gds_create_c( g->Outsetname, &r );
   if (r < 0)
   {
      sprintf( errmes, "GDS error nr %d", r );
      error_status("Cannot create this set!", errmes, "" );         
      return;    
   }


   if (g->slicemode == LINE)
   {     
      naxis = g->line[0].ndat;
      crpix =  (double) -g->line[0].offmin + 1.0;
      image = g->line[0].sliceimage;
   }
   else if (g->slicemode == ELLIPSE)
   {
      naxis = g->ellipse.ndat;
      crpix = 1.0;
      image = g->ellipse.sliceimage;
   }
   else if (g->slicemode == SPLINE) 
   {
      naxis = g->spline.ndatO; 
      crpix = 1.0;
      image = g->spline.sliceimage;
   }
   else
      return;
   
   
   fmake( Ctype, FITSLEN );
   strcpy( Ctype.a, "PARAM-OFFSET" );
   r = 0;   
   gds_extend_c( g->Outsetname, Ctype, &crpix, &naxis, &r ); 
   r = 0;
   gdsd_wchar_c( g->Outsetname, tofchar("CUNIT1"), &setlevel,
                 tofchar("GRIDS"), &r );
   cdelt = 1.0;
   r = 0;
   gdsd_wdble_c( g->Outsetname, tofchar("CDELT1"), &setlevel, &cdelt, &r );
   crval = 0.0;
   r = 0;
   gdsd_wdble_c( g->Outsetname, tofchar("CRVAL1"), &setlevel, &crval, &r );
      
   axnum = g->inset.axnum[ g->inset.setdim-1 ];
   copyaxis( g->inset.Name, axnum, g->Outsetname, 2 );


   /* Get units of the data */
   r = 0;
   fmake( Bunit, FITSLEN );
   gdsd_rchar_c( g->inset.Name, tofchar("BUNIT"), &setlevel, Bunit, &r );
   if (r == 0)
      gdsd_wchar_c( g->Outsetname, tofchar("BUNIT"), &setlevel, Bunit, &r );
      
   r = 0;
   gdsc_range_c( g->Outsetname, &setlevel, &cwloO, &cwhiO, &r ) ;

     
   /* Write the data */    
   {
      fint     pixelsdone;
      fint     numpoints = naxis * g->inset.nsubs;     
      fint     tidO = 0;
      
      gdsi_write_c( g->Outsetname,
                    &cwloO, &cwhiO,
                    image,
                    &numpoints,
                    &pixelsdone,
                    &tidO );      
   }
   r = 0;
   gds_close_c( g->Outsetname, &r );
   
   /* Give message in gui */
   sprintf( mes, "XV image written to set: [ %s ]", g->Outsetname.a );
   anyoutf( 3, mes );   
   if (g->slicemode == LINE)
   {     
      gui_line_status( 0, mes );
   }
   else if (g->slicemode == ELLIPSE)
   {
      gui_ell_status( 0, mes );
   }
   else if (g->slicemode == SPLINE) 
   {
      gui_spl_status( 0, mes );
   }   
}



int getgridspacings( settype  *set )
/*------------------------------------------------------------*/
/* PURPOSE: Return the grid spacings of the subset axes.      */
/* Routine is called by 'getset'.                             */
/*------------------------------------------------------------*/
{
   fint    subdim;
   fint    r1;
   int     n;
   char    cbuf[FITSLEN+1];


   subdim = gdsc_ndims_c( set->Name, &(set->subsets[0]) );
   for (n = 0; n < subdim; n++)
   {
      sprintf( cbuf, "CDELT%d", set->axnum[n] );
      r1 = 0;
      gdsd_rdble_c( set->Name, tofchar(cbuf), &setlevel, &set->cdelt[n], &r1 );
      if (r1 < 0)
      {
         error_status( "NOTE:", "Cannot obtain grid spacings. Zero substituted!", "" );
         anyoutf( DEBUG, "DEBUG (getgridspacings): Cannot obtain grid spacings. Zero substituted!" );
         for (n = 0; n < subdim; n++)
            set->cdelt[n] = 0.0;
         return( NO );
      }
      anyoutf( DEBUG, "DEBUG (getgridspacings): Grid spacing: %f", set->cdelt[n] );
   }
   return( YES );
}




int getlinesampledata( globaltype *g,
                       int         panelnr,
                       char       *errmes )
/*------------------------------------------------------------*/
/* Return number of sample points in box or a negative number */
/* if there is an error condition.                            */
/* Move along a line, starting from the centre, until the     */
/* distance to the start point is the sampling distance.      */
/* Store the position of this new sample point and go on      */
/* until the borders are reached or if the sample length      */
/* exceeds a user given length.                               */
/*------------------------------------------------------------*/
{   
   float xc = g->line[panelnr].xc;
   float yc = g->line[panelnr].yc;
   float angle = g->line[panelnr].angle;
   float delta =  g->line[panelnr].sampledist;
   float samlen = g->line[panelnr].samplelen;
   float xlo = (float) g->inset.blo[0];
   float xhi = (float) g->inset.bhi[0];
   float ylo = (float) g->inset.blo[1];
   float yhi = (float) g->inset.bhi[1];
   int   num;
   int   lambdamax, lambdamin;
   float p, q;
   float x, y;
   int   inside;
   int   i, indx;
   float *Xa, *Ya;
   float D, d, Dmax;


   if (xc < xlo || xc > xhi || yc < ylo || yc > yhi)
   {
      sprintf( errmes, "Center %g %g NOT INSIDE box", xc, yc );
      return( -1 );
   }
   
   Xa = g->line[panelnr].Xpos;
   Ya = g->line[panelnr].Ypos;
   if (Xa != NULL)
      free( Xa );
   if (Ya != NULL)
      free( Ya );



   Dmax = samlen / 2.0;

   /* Count the number of sample points in current box */
   /* The centre is always included. */
   num = 1;


   /*------------------------------------------------------------*/
   /* Rotate a point at distance delta on the x axis and with    */
   /* this rotated point create a line through the centre.       */
   /* each integer step in lambda equals a step in delta         */
   /* this rotated line.                                         */
   /*------------------------------------------------------------*/
   p = (delta)*cos(RAD(angle));
   q = (delta)*sin(RAD(angle));

   d = 1.0;
   lambdamax = 0;


   inside = YES;      
   for (; inside; )
   {
      inside = YES;      
      x = xc + (float)(lambdamax+1) * p;
      y = yc + (float)(lambdamax+1) * q;
      D = d * delta;
      /* Outside box? */      
      if (x < xlo || x > xhi || y < ylo || y > yhi || D > Dmax)  
      {
/* anyoutf( 1, "D, Dma =%f %f x,y=%f %f xlohi ylohi=%f %f %f %f", D, Dmax, x,y, 
         xlo, xhi, ylo, yhi ); */        

         inside = NO;
      }
      if (inside)
      {
         d += 1.0;
         num++;
         lambdamax++;
      }
   }


   d = 1.0;
   lambdamin = 0;
   do
   {
      x = xc + (float)(lambdamin-1) * p;
      y = yc + (float)(lambdamin-1) * q;
      inside = YES;
      D = d * delta;
      if (x < xlo || x > xhi || y < ylo || y > yhi || D > Dmax)  /* Outside box? */
      {
         inside = NO;
      }
      if (inside)
      {
         d += 1.0;
         lambdamin--;
         num++;
      }
   }
   while (inside);



   /* Now we have 'num' sample points */

   Xa = (float *) calloc( num, sizeof(float) );
   if (Xa == NULL)
   {
      sprintf( errmes, "Cannot allocate %d bytes for sample positions",
               num*sizeof(float) );
      return(-2);
   }
   Ya = (float *) calloc( num, sizeof(float) );
   if (Ya == NULL)
   {
      free( Xa );
      sprintf( errmes, "Cannot allocate %d bytes for sample positions",
               num*sizeof(float) );
      return(-3);
   }
   for (indx = 0, i = lambdamin; i <= lambdamax; i++, indx++)
   {
      Xa[indx] =  xc + ((float)i) * p;
      Ya[indx] =  yc + ((float)i) * q;
   }
   g->line[panelnr].Xpos = Xa;
   g->line[panelnr].Ypos = Ya;
   g->line[panelnr].offmin  = lambdamin * delta;
   g->line[panelnr].offplus = lambdamax * delta;


   /*---------------------------------------------------*/
   /* If a user wants a sample line of finite width then*/
   /* we need also an array with points that define a   */
   /* line perpendicular to the sample line. We need    */
   /* only to store the direction vector. In the routine*/
   /* that extracts the data, this vector will be       */
   /* applied to all positions along the sample line to */
   /* get an average pixel value.                       */
   /*---------------------------------------------------*/
   if (g->line[panelnr].slicewidth != 0.0)
   {
      g->line[panelnr].dirvect[0] = cos(RAD(angle));
      g->line[panelnr].dirvect[1] = sin(RAD(angle));      
   }

   return( num );
}




void getsliceim( globaltype *g,
                 int         panelnr,
                 int         arrowcol )
/*------------------------------------------------------------*/
/* PURPOSE:                                                   */
/* After a call to the routine that calculates the slice      */
/* positions, we can extract the data from the set and put    */
/* them in an array.                                          */
/*------------------------------------------------------------*/
{
   int         xlen = 0.0;
   int         ylen = g->inset.nsubs;
   fint        imagesize = (g->inset.bhi[0] - g->inset.blo[0] + 1) *
                           (g->inset.bhi[1] - g->inset.blo[1] + 1);
   fint        pixelsread = 0;
   float       **subsetdata = NULL;           /* Buffer for subset image data */
   int         subnr, count;
   int         integrate = NO;
   float       *sliceim = NULL;
   float       angle = 0.0;
   float       *X = NULL;
   float       *Y = NULL;
   float       *dummyx = NULL;
   float       xlo, xhi, ylo, yhi;
   ident       ggiplotid = 0;
   fint        oldplotid;   
   float       hw = 0.0;                                       /* Slice width */
   float       intsep = 0.0;                 /* Integration sample separation */



   /* Initialize */
   if (g->slicemode == LINE)
   {
      xlen = g->line[panelnr].ndat;
      angle = g->line[panelnr].angle;
      X = g->line[panelnr].Xpos;
      Y = g->line[panelnr].Ypos;
      sliceim = g->line[panelnr].sliceimage;
      dummyx = g->line[panelnr].dummyx;
      ggiplotid = g->line[panelnr].GGIplotid;
      hw = g->line[panelnr].slicewidth / 2.0;
      intsep = g->line[panelnr].intsep;
   }
   if (g->slicemode == ELLIPSE)
   {
      xlen = g->ellipse.ndat;
      angle = g->ellipse.angle;
      X = g->ellipse.Xpos;
      Y = g->ellipse.Ypos;
      sliceim = g->ellipse.sliceimage;
      dummyx = g->ellipse.dummyx;
      ggiplotid = g->ellipse.GGIplotid;      
      hw = g->ellipse.slicewidth / 2.0;
      intsep = g->ellipse.intsep;
   }
   if (g->slicemode == SPLINE)
   {
      xlen = g->spline.ndatO;
      X = g->spline.XposO;
      Y = g->spline.YposO;
      sliceim = g->spline.sliceimage;
      dummyx = g->spline.dummyx;
      ggiplotid = g->spline.GGIplotid;
      hw = g->spline.slicewidth / 2.0;      
      intsep = g->spline.intsep;      
   }
   

   /* We need a 2-dim array with size of the x axis equal to */
   /* the number of sample points and with y axis size equal */
   /* to the number of subsets. */

   subsetdata = fmatrix( g->inset.blo[0],   /* Allocate space for a 2-dim matrix */
                         g->inset.blo[1],
                         g->inset.bhi[0],
                         g->inset.bhi[1] );


   if (dummyx != NULL)
      free( dummyx );

   if (sliceim != NULL)
      free( sliceim );
   sliceim = (float *) calloc( xlen*ylen, sizeof(float) );
   if (sliceim  == NULL)
   {
      anyoutf( 3, "Cannot allocate %d bytes for slice image", xlen*ylen*sizeof(float) );
      return;
   }
   dummyx = (float *) calloc( xlen, sizeof(float) );
   if (dummyx == NULL)
   {
      anyoutf( 3, "Cannot allocate %d bytes for x axis of slice line", xlen );
      return;
   }

   /* Fill the dummy array */
   {
      int  j;
      for (j = 0; j < xlen; j++)
      {
         dummyx[j] = (float) j;
      }
   }
   integrate = (
                 (g->slicemode == LINE && g->line[panelnr].slicewidth > 0.0) ||
                 (g->slicemode == ELLIPSE && g->ellipse.slicewidth > 0.0) ||
                 (g->slicemode == SPLINE && g->spline.slicewidth > 0.0)
               );
   integrate = (integrate && (intsep != 0.0));
   count = 0;
   pgqid_c( &oldplotid );
   selectplot( g->PGmainplotid );
   pgbbuf_c();
   for (subnr = 0; subnr < ylen; subnr++)
   {
      int  j;
      fint tid  = 0;
      fint cwlo = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[subnr]), g->inset.blo );
      fint cwhi = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[subnr]), g->inset.bhi );
      gdsi_read_c( g->inset.Name, /* g->inset.Sethandle,*/
                   &cwlo, &cwhi,
                   &subsetdata[g->inset.blo[1]][g->inset.blo[0]],
                   &imagesize,
                   &pixelsread,
                   &tid );
      for (j = 0; j < xlen; j++)
      {
         /*--------------------------------------------------*/
         /* User wants to integrate over a finite width      */
         /* unequal to 0 or 1 grid. The width is always in   */
         /* integer grids. The points on the slice arrow are */
         /* always in the box, but the points on the parallel*/
         /* slices must be checked.                          */
         /*--------------------------------------------------*/
         if (integrate)
         {
            int   b;
            float p = 0.0, q = 0.0;
            float x, y;
            int   contrib = 0;
            float sum = 0.0;
            float mu = 0.0;
            int   insidewidth = YES;
            
            if (g->slicemode == LINE)
            {
               p = g->line[panelnr].dirvect[0];
               q = g->line[panelnr].dirvect[1];
            }
            if (g->slicemode == ELLIPSE || g->slicemode == SPLINE)
            {
               float dx, dy, norm;

               if (j < xlen-1)
               {
                  dx = X[j+1]-X[j];
                  dy = Y[j+1]-Y[j];
               }
               else
               {
                  dx = X[j]-X[j-1];
                  dy = Y[j]-Y[j-1];
               }
               norm = sqrt(dx*dx+dy*dy);
               if (norm == 0.0)        /* Two points are the same */
                  hw = 0.0;
               else
               {
                  p = dx/norm;
                  q = dy/norm;
               }
            }
            for (b = -1; b <= 1; b += 2)            
            {
               insidewidth = YES;
               /* Loop over the orthogonal sample line and get average */
               if (b < 0)
                  mu = 0.0;
               else
                  mu = MYMIN( intsep, hw );
               while (insidewidth)
               {
                  float val;
                  int   inside;
               
                  x = X[j] - mu * q;                   /* The orthogonal samples */
                  y = Y[j] + mu * p;
                  inside = ( NINT(x) >= g->inset.blo[0] && NINT(x) <= g->inset.bhi[0] &&
                             NINT(y) >= g->inset.blo[1] && NINT(y) <= g->inset.bhi[1] );
                           
                  /*----------------------------------------*/
                  /* For debug purposes, plot the pixels    */
                  /* that contribute with:                  */
                  /*----------------------------------------*/
                  if (subnr == 0)
                     plsymbol( x, y, 3, 1.0, 1, RED );      
   
               
                  if (!inside) 
                     val = fblank;
                  else
                  {                  
                     if (!g->interpol)
                        val = subsetdata[ NINT(y) ][ NINT(x) ];
                     else
                        val = interpol( x, y, subsetdata,
                                         g->inset.blo, g->inset.bhi, fblank );
                  }
                  if (val != fblank)
                  {
                     sum += val;
                     contrib++;
                  }                  
                  if (b > 0)
                  {
                     mu += intsep;
                     insidewidth = (mu <= hw);
                  }
                  else
                  {
                     mu -= intsep;
                     insidewidth = (mu >= -hw); 
                  }
               }
            }
            /* Store the average of these 'contrib' grids */
            if (contrib > 0)
               sliceim[count++] = sum/(float) contrib;
            else   
               sliceim[count++] = 0.0;
         }
         else
         {
            int   inside; 
            
            int  xi = NINT(X[j]);
            int  yi = NINT(Y[j]);
            inside = ( xi >= g->inset.blo[0] && xi <= g->inset.bhi[0] &&
                       yi >= g->inset.blo[1] && yi <= g->inset.bhi[1] );

            if (inside)
            {                           
               if (!g->interpol)
                  sliceim[count++] = subsetdata[ yi ][ xi ];
               else
                  sliceim[count++] = interpol( X[j], Y[j], subsetdata,
                                               g->inset.blo, g->inset.bhi, fblank );
            }
            else
               sliceim[count++] = fblank;
         }
      }
   }
   pgebuf_c();
   selectplot( oldplotid );
   /* Plot the slice image in another window */
   {
      /* Set viewport and window */

      float    xtick = 0.0, ytick = 0.0;
      fint     nxsub = 0, nysub = 0;
      float    oldsize;
      int      panel2 = NO;
      char     mes[128];


      if (g->slicemode == LINE && g->panel2)
         panel2 = YES;

      setstandardviewport();
      /* Set window to maximum size of two panels */
      if (panel2)
      {
         xlen = MYMAX( g->line[0].ndat, g->line[1].ndat );
      }
      xlo = 0.0; xhi = xlen;
      ylo = 0.0; yhi = ylen;
      angle = putinrangedeg( angle );
      
      /*--------------------------------------------------*/
      /* In line mode the x axis values increase in the   */
      /* direction of the horizontally projected sample   */
      /* arrow.                                           */
      /*--------------------------------------------------*/
      if (g->slicemode == LINE && angle > 90.0 && angle < 270.0)
      {
         FSWAP( xlo, xhi );
      }
      setwindow( xlo, ylo, xhi, yhi );
      clearpage();

      if (g->slicemode == LINE)
      {
         g->line[panelnr].dummyx = dummyx;
         g->line[panelnr].sliceimage = sliceim;
         displaysliceimage( g, panelnr, g->line[panelnr].sliceimage );
      }

      if (g->slicemode == ELLIPSE)
      {
         g->ellipse.dummyx = dummyx;
         g->ellipse.sliceimage = sliceim;
         displaysliceimage( g, 0, g->ellipse.sliceimage );
      }

      if (g->slicemode == SPLINE)
      {
         g->spline.dummyx = dummyx;
         g->spline.sliceimage = sliceim;
         displaysliceimage( g, 0, g->spline.sliceimage );
      }

      plarrow( 0.0, 0.0, xlen, 0.0, 3.5, 8, arrowcol );

      /*--------------------------------------------------*/
      /* Set another window to display correct offset/dis-*/
      /* tance and y axis labels.                         */
      /*--------------------------------------------------*/

      if (g->slicemode == LINE)
      {     
         int k = 0;
         if (panel2)
         {
            if (g->line[0].ndat < g->line[1].ndat)
               k = 1;
         }
         xlo = g->line[k].offmin;              /* In grids */
         xhi = g->line[k].offplus;
         strcpy( mes, "Offset grids" );
      }
      if (g->slicemode == ELLIPSE)
      {
         xlo  = 0.0;
         xhi  = ((float)(xlen-1)) * g->ellipse.sampledist;
         strcpy( mes, "Distance (grids) from end point major axis (ccw)" );
      }
      if (g->slicemode == SPLINE) 
      {
         xlo  = 0.0;
         /*--------------------------------------------------*/
         /* There is a fluctuation in the sample distance.   */
         /* This must be so because we always include the    */
         /* spline control points and adjust the sampling so */
         /* that the first and last sample of a spline       */
         /* segment coincide with two control points. There- */
         /* fore the equation:                               */
         /* xhi  = ((float)(xlen-1)) * g->spline.sampledist; */
         /* Generates different numbers along the x axis,    */
         /* as function of the sample distance entered by    */
         /* user. Instead of this number we use a distance   */
         /* estimated by the function spline.c, which calcu- */
         /* lates the distance in 'PRESAMPLES' subintervals  */
         /* in one spline segment.                           */
         /*--------------------------------------------------*/
         
         xhi = g->spline.lengrids;
         strcpy( mes, "Distance (grids) to start point of spline" );
      }

      xlo -=  0.5; xhi += 0.5;                 /* From boundary to boundary */

      if (g->slicemode == LINE)
      {
         if (angle > 90.0 && angle < 270.0)
         {
            FSWAP( xlo, xhi );
         }
      }
      ylo = g->yaxis.minph; yhi = g->yaxis.maxph;
      if (ylo == yhi)
      {
         ylo -=  0.5; yhi += 0.5;
      }
      setwindow( xlo, ylo, xhi, yhi );
      pgqch_c( &oldsize );
      setchmm( CHARHEI );
      pgbox_c( tofchar("BNIST" ), &xtick, &nxsub,
               tofchar("BNISTV"), &ytick, &nysub );
      pglab_c( tofchar(mes), tofchar(g->yaxis.headerunits), tofchar("") );
      
      /* Set another window to plot axis labels in grids at the right side */

      ylo = g->yaxis.mingrid - 0.5; 
      yhi = g->yaxis.maxgrid + 0.5;

      setwindow( xlo, ylo, xhi, yhi );
      setchmm( CHARHEI - 1.0 );
      pgbox_c( tofchar("CSIT" ), &xtick, &nxsub,
               tofchar("CMISTV"), &ytick, &nysub );

      setchsize( oldsize );
   }
   if (!g->hardcopy)
   {
      GgiPlotRecord( ggiplotid, 0 );
   }

   /* subsetarrow( g, panelnr ); werkt niet goed */

   freefmatrix( subsetdata, g->inset.blo[0], g->inset.blo[1] );
}




void linegraph( globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: Plot intensity line graph for one frequency, i.e. */
/*          plot intensities along sample curve.              */
/*------------------------------------------------------------*/
{
   float       xlo = 0.0, xhi = 0.0, ylo, yhi;
   float       xtick = 0.0, ytick = 0.0;
   fint        nxsub = 0, nysub = 0;
   int         panelnr;
   fint        framenr;
   fint        ndat;
   int         npanels;
   bool        plotline = UserLog("LINEGRAPH=");
   float       *X = NULL, *Y = NULL;
   fint        pggraphid = 0;
   ident       ggigraphid = (ident) NULL;
   fint        oldcol;
   float       vpylo = 0.3;


   if (!plotline)
      return;


   framenr = g->currentframe;
   
   /* Only line graphs if image is part of subsets */
   if (framenr >= g->inset.nsubs)
      return;

   npanels = 1;
   if (g->slicemode == LINE && g->panel2)
      npanels = 2; 

   if (g->slicemode == LINE)
   {
      pggraphid = g->line[0].PGgraphid;
      ggigraphid = g->line[0].GGIgraphid;
   }
   if (g->slicemode == ELLIPSE)
   {
      pggraphid = g->ellipse.PGgraphid; 
      ggigraphid = g->ellipse.GGIgraphid;
   }
   if (g->slicemode == SPLINE)
   {
      pggraphid = g->spline.PGgraphid;  
      ggigraphid = g->spline.GGIgraphid;
   }

   if (pggraphid == 0)
      return;

   /* Plot the labeled frames only once and store it as an image */
   if (g->newframe)
   {
      g->newframe = NO;

      for (panelnr = 0; panelnr < npanels; panelnr++)
      {
         float oldsize;
         char  mes[128];

         selectplot( pggraphid );
         clearpage();
         setviewport( VPXLO, vpylo, VPXHI, VPYHI );

         if (g->slicemode == LINE)
         {
            int k = 0;
            if (npanels == 2)
            {
               if (g->line[0].ndat < g->line[1].ndat)
                  k = 1;
            }
            xlo  = g->line[k].offmin;              /* In grids */
            xhi  = g->line[k].offplus;          
            ndat = g->line[panelnr].ndat;
            strcpy( mes, "Offset in grids" );
         }
         if (g->slicemode == ELLIPSE)
         {
            ndat = g->ellipse.ndat;
            xlo  = 0.0;
            xhi  = ((float)(ndat-1)) * g->ellipse.sampledist; 
            strcpy( mes, "Distance (grids) from end point major axis (ccw)" );
         }
         if (g->slicemode == SPLINE)
         {
            ndat = g->spline.ndatO;
            xlo  = 0.0;
            /*------------------------------------------*/
            /* User sets sample distance. Default is 1  */
            /* pixel. Number of samples times sample    */
            /* distance sets the width of the plot.     */
            /* -----------------------------------------*/
            xhi  = ((float)(ndat-1)) * g->spline.sampledist;
            strcpy( mes, "Distance (grids) to start point of spline" );
         }
         xlo -=  0.5; xhi += 0.5; /* Stretch with half pixel both sides */

         if (g->slicemode == LINE)
         {
            if (g->line[panelnr].angle > 90.0 && g->line[panelnr].angle < 270.0)
            {
               FSWAP( xlo, xhi );
            }
         }
         ylo = g->inset.clip[0];
         yhi = g->inset.clip[1];
         setwindow( xlo, ylo, xhi, yhi );  /* Set box to the real limits in world coordinates */
         pgqch_c( &oldsize );
         setchmm( CHARHEI );
         pgbox_c( tofchar("BCNST" ), &xtick, &nxsub,
                  tofchar("BCNSTV"), &ytick, &nysub );

         setchmm( CHARHEI - 1.0 );
         pglab_c( tofchar(mes), tofchar(g->inset.dataunits), tofchar("") );
         setchsize( oldsize );
         GgiPlotRecord( ggigraphid, 0 );
      }
   }


   pgqci_c( &oldcol );
   /* Plot an intensity graph at one (=current) frequency */
   for (panelnr = 0; panelnr < npanels; panelnr++)
   {
      if (panelnr == 0)
      {
         selectplot( pggraphid );
         GgiPlotShow( ggigraphid, 0 );
         setcolor( YELLOW ); 
      }
      else
      {
         setcolor( CYAN );
      }
      setviewport( VPXLO, vpylo, VPXHI, VPYHI );      


      xlo = 0.0;                  
      if (g->slicemode == LINE)
      {
         ndat = g->line[panelnr].ndat;
         X = g->line[panelnr].dummyx;
         /*------------------------------*/
         /* The Y values are one row     */
         /* the extracted image, i.e.    */
         /* one subset (e.g. frequency). */
         /*------------------------------*/
         Y = &(g->line[panelnr].sliceimage[framenr*ndat]);
         if (npanels == 2)
         {
            int delta;
            int m, n;
            if (panelnr == 0)
            {
               m = 0; n = 1;
            }
            else
            {
               m = 1; n = 0; 
            }
            delta = g->line[m].ndat - g->line[n].ndat;
            if (delta < 0)
            {
               xlo = delta / 2;
               xhi = MYMAX(1.0, g->line[n].ndat-1) + xlo;
            }
            else
               xhi = MYMAX(1.0, ndat-1 );
         }
         else
            xhi = MYMAX(1.0, ndat-1 );
      }
      if (g->slicemode == ELLIPSE)
      {
         ndat = g->ellipse.ndat;
         X = g->ellipse.dummyx;
         Y = &(g->ellipse.sliceimage[framenr*ndat]);
         xhi = MYMAX(1.0, ndat-1 );
      }
      if (g->slicemode == SPLINE)
      {
         ndat = g->spline.ndatO;
         X = g->spline.dummyx;
         Y = &(g->spline.sliceimage[framenr*ndat]);
         xhi = MYMAX(1.0, ndat-1 );
      }

      /*----------------------------------------*/
      /* Stretch a bit to get margins. These    */
      /* numbers are used to set the coordinate */
      /* system to another system of world      */
      /* coordinates. These are the pixels 0..n */
      /*----------------------------------------*/
      xlo -=  0.5; xhi += 0.5;

      if (g->slicemode == LINE)
      {
         if (g->line[panelnr].angle > 90.0 && g->line[panelnr].angle < 270.0)
         {
            FSWAP( xlo, xhi );
         }
      }
      ylo = g->inset.clip[0];
      yhi = g->inset.clip[1];
      setwindow( xlo, ylo, xhi, yhi );
      pgline_c( &ndat, X, Y );
   }
   setcolor( oldcol );
}




void subsetarrow( globaltype *g,
                  int         panelnr )
/*------------------------------------------------------------*/
/* PURPOSE: Plot an arrow at current subset grid in slice.    */
/*------------------------------------------------------------*/
{
   float       xlo, xhi, ylo, yhi;
   float       xlo_o, xhi_o, ylo_o, yhi_o;
   float       vpxlo, vpxhi;
   float       vpxlo_o, vpxhi_o, vpylo_o, vpyhi_o;
   fint        framenr;
   fint        units = 0;
   fint        pgplotid = 0;
   ident       ggiplotid = (ident) NULL; 


   if (g->slicemode == LINE)
   {
      pgplotid = g->line[panelnr].PGplotid;
      ggiplotid = g->line[panelnr].GGIplotid;
   }
   if (g->slicemode == ELLIPSE)
   {
      pgplotid = g->ellipse.PGplotid; 
      ggiplotid = g->ellipse.GGIplotid;
   }
   if (g->slicemode == SPLINE)
   {
      pgplotid = g->spline.PGplotid;  
      ggiplotid = g->spline.GGIplotid;
   }

   framenr = g->currentframe;
   {
      selectplot( pgplotid );
      /*clearpage();    */
      GgiPlotShow( ggiplotid, 0 );
      pgqwin_c( &xlo_o, &xhi_o, &ylo_o, &yhi_o );
      pgqvp_c( &units, &vpxlo_o, &vpxhi_o, &vpylo_o, &vpyhi_o );
      vpxlo = VPXHI+0.02; vpxhi = 1.0;
      setviewport( vpxlo, VPYLO, vpxhi, VPYHI );

      xlo = 0.0;  xhi = 1.0;
      ylo = -0.5; yhi = (float) g->inset.nsubs - 1.0 + 0.5;
      setwindow( xlo, ylo, xhi, yhi );

      plarrow( 1.0, framenr, 0.2, framenr, 4.0, 2, RED );
      setviewport( vpxlo_o, vpylo_o, vpxhi_o, vpyhi_o );  /* restore vp */ 
      setwindow( xlo_o, ylo_o, xhi_o, yhi_o );            /* restore window */
   }
}



void plotcontour( globaltype *g,
                  float      *image )
/*------------------------------------------------------------*/
/* PURPOSE: Plot a contour when specified.                    */
/*------------------------------------------------------------*/
{
   float        levels[32];
   fint         nitems = 32;
   fint         dfault = HIDDEN;
     
   float  trans[6];
   fint   startindexX, startindexY;
   fint   endindexX, endindexY;
   fint   idim, jdim;
   float  xlo, ylo;
   fint   nc;               /* Number of contour levels */
   fint   numcol, oldcol, color = 1;
   fint   oldlinewidth, linewidth = 1;
   fint   oldlinestyle, linestyle = 1;
   

   nc = userreal_c( levels,
                    &nitems,
                    &dfault,
                    tofchar("LEVELS="),
                    tofchar(" ") );
             
   /* There must be at least one level... */                  
   if (nc == 0)
      return;     

   nitems = 1;
   numcol = userint_c( &color,
                       &nitems,
                       &dfault,
                       tofchar("LEVCOL="),
                       tofchar(" ") );
        
   pgqci_c( &oldcol );
   setcolor( color );

   (void) userint_c( &linewidth,
                     &nitems,
                     &dfault,
                     tofchar("LEVTHICK="),
                     tofchar(" ") );
        
   pgqlw_c( &oldlinewidth );
   setwidth( linewidth );

   (void) userint_c( &linestyle,
                     &nitems,
                     &dfault,
                     tofchar("LEVSTYLE="),
                     tofchar(" ") );
        
   pgqls_c( &oldlinestyle );
   setlinestyle( linestyle );


   idim = g->inset.bhi[0] - g->inset.blo[0] + 1;
   jdim = g->inset.bhi[1] - g->inset.blo[1] + 1;

   startindexX = 1;
   startindexY = 1;
   endindexX   = idim;
   endindexY   = jdim;

   xlo = g->inset.blo[0];
   ylo = g->inset.blo[1];

   trans[0] =  xlo-1;      /* I = 1 -> X = xlo */
   trans[1] =  1.0;
   trans[2] =  0.0;
   trans[3] =  ylo-1;
   trans[4] =  0.0;
   trans[5] =  1.0;
   
   pgconb_c( image,
             &idim,            /* First dimension of 'image' */
             &jdim,            /* Second dimension of 'image' */
             &startindexX,     /* Start of range of first index */
             &endindexX,       /* End of range of first index */
             &startindexY,     /* Start of range of second index */
             &endindexY,       /* End of range of second index */
             levels,
             &nc,
             trans,            /* Transformation matrix between array grids and world coordinates */
             &fblank );
             
   setcolor( oldcol );
   setwidth( oldlinewidth );   
   setlinestyle( oldlinestyle );
}



void plotexternalcontour( globaltype *g )
/*------------------------------------------------------------*/
/* PURPOSE: Plot contours from external data in current       */
/*          frame.                                            */
/*------------------------------------------------------------*/
{
   float        levels[MAXLEVELS];
   fint         color[MAXLEVELS];
   fint         linewidth[MAXLEVELS];
   fint         linestyle[MAXLEVELS];
   fint         nitems = MAXLEVELS;
   fint         dfault = HIDDEN;
     
   float  trans[6];
   fint   startindexX, startindexY;
   fint   endindexX, endindexY;
   fint   idim, jdim;
   float  xlo, ylo;
   fint   nc;               /* Number of contour levels */
   fint   oldcol;
   fint   oldlinewidth;
   fint   oldlinestyle;
   fint   numcol, numwidth, numstyle;
   float *image = NULL;
   fint   imsize;
   int    i;
   int    first = YES;


   if (g->hardcopy)
      selectplot( g->PGhardcopyid );
   else
      selectplot( g->PGmainplotid );
   pgqci_c( &oldcol );
   pgqlw_c( &oldlinewidth );
   pgqls_c( &oldlinestyle );
   /*--------------------------------------------------*/
   /* Start a loop over the external sets. Are there   */
   /* contours defined then plot these contours for    */
   /* current frame.                                   */
   /*--------------------------------------------------*/
   for (i = 0; i < EXTRAFRAMES; i++)
   {
      int   indx;
      bool  getcontours;
      char  key[20];            
      
      sprintf( key, "LEVOVER%d=", i );      
      indx = g->currentframe - g->inset.nsubs;             
      
      /*--------------------------------------------------*/
      /* If the current frame is the same as the current  */
      /* image, then plot always the contours. For other  */
      /* frames, check the OVLY overlay button.           */
      /*--------------------------------------------------*/
      if (i == indx)      
         getcontours = YES;
      else
         getcontours = UserLog( key );
      
      if (g->external[i].exist && getcontours)
      {
         int    cont;
         
         sprintf( key, "LEVELS%d=", i );
         nc = userreal_c( levels,
                          &nitems,
                          &dfault,
                          tofchar(key),
                          tofchar(" ") );
             
         /* There must be at least one level... */           
         if (nc > 0)
         {
            if (first)
            {
               imsize = (g->inset.bhi[0] - g->inset.blo[0] + 1) *
                        (g->inset.bhi[1] - g->inset.blo[1] + 1);
               image = (float *) calloc( (int) imsize, sizeof(float) );
               if (image == NULL)
               {
                  char  mes[80];
                  sprintf( mes, "Cannot allocate %d bytes for subset(s)", imsize*sizeof(float) );
                  gui_error( mes );
                  return;
               }
               else
               {
                  first = NO;
               }
            }
            {
               fint  tid  = 0;
               fint  cwlo = gdsc_fill_c( tofchar(g->external[i].gdsname), &(g->external[i].subset), g->inset.blo );
               fint  cwhi = gdsc_fill_c( tofchar(g->external[i].gdsname), &(g->external[i].subset), g->inset.bhi );               
               fint  pixelsread = 0;
               gdsi_read_c( tofchar(g->external[i].gdsname),
                            &cwlo, &cwhi,
                            image,
                            &imsize,
                            &pixelsread,
                            &tid );
            }
            /* Now we have the contour data */
            {
               sprintf( key, "LEVCOL%d=", i );
               nitems = MAXLEVELS;
               color[0] = 1;
               numcol = userint_c( color, &nitems, &dfault, tofchar(key), tofchar(" ") );        
               if (numcol == 0)
                  numcol = 1;

               sprintf( key, "LEVTHICK%d=", i );
               linewidth[0] = 1;
               numwidth = userint_c( linewidth, &nitems, &dfault, tofchar(key), tofchar(" ") );           
               if (numwidth == 0)
                  numwidth = 1;

               sprintf( key, "LEVSTYLE%d=", i );
               linestyle[0] = FULL;
               numstyle = userint_c( linestyle, &nitems, &dfault, tofchar(key), tofchar(" ") );
               if (numstyle == 0)
                  numstyle = 1;

               idim = g->inset.bhi[0] - g->inset.blo[0] + 1;
               jdim = g->inset.bhi[1] - g->inset.blo[1] + 1;

               startindexX = 1;
               startindexY = 1;
               endindexX   = idim;
               endindexY   = jdim;
            
               xlo = g->inset.blo[0];
               ylo = g->inset.blo[1];
            
               trans[0] =  xlo-1;      /* I = 1 -> X = xlo */
               trans[1] =  1.0;
               trans[2] =  0.0;
               trans[3] =  ylo-1;
               trans[4] =  0.0;
               trans[5] =  1.0;


               if (numcol == 1 && numwidth == 1 && numstyle == 1)
               {
                  /* All contours same characteristics */
                  setcolor( color[0] );
                  setwidth( linewidth[0] );
                  setlinestyle( linestyle[0] );
                  pgconb_c( image,
                            &idim,            /* First dimension of 'image' */
                            &jdim,            /* Second dimension of 'image' */
                            &startindexX,     /* Start of range of first index */
                            &endindexX,       /* End of range of first index */
                            &startindexY,     /* Start of range of second index */
                            &endindexY,       /* End of range of second index */
                            levels,
                            &nc,
                            trans,            /* Transformation matrix between array grids and world coordinates */
                            &fblank );                  
               }
               else
               {
                  for (cont = 0; cont < nc; cont++)
                  {
                     fint  numconts = 1;
                     float onelev;

                     onelev = levels[cont];
                     setcolor( color[MYMIN(cont,numcol-1)] );
                     setwidth( linewidth[MYMIN(cont,numwidth-1)] );
                     setlinestyle( linestyle[MYMIN(cont,numstyle-1)] );
                     pgconb_c( image,
                               &idim,            /* First dimension of 'image' */
                               &jdim,            /* Second dimension of 'image' */
                               &startindexX,     /* Start of range of first index */
                               &endindexX,       /* End of range of first index */
                               &startindexY,     /* Start of range of second index */
                               &endindexY,       /* End of range of second index */
                               &onelev,
                               &numconts,
                               trans,            /* Transformation matrix between array grids and world coordinates */
                               &fblank );
                  }
               }                            
            }
         }
      }
   }    

   setcolor( oldcol );
   setwidth( oldlinewidth );
   setlinestyle( oldlinestyle );
   if (image != NULL)
      free( image );
}




void plotimage( globaltype *g,
                float      *image )
/*------------------------------------------------------------*/
/* PURPOSE: Plot subset image in frame.                       */
/*------------------------------------------------------------*/
{
   float  trans[6];
   fint   startindexX, startindexY;
   fint   endindexX, endindexY;
   fint   idim, jdim;
   float  datmin = g->inset.clip[0];
   float  datmax = g->inset.clip[1];
   float  xlo, ylo;
   fint   c1, c2;

   idim = g->inset.bhi[0] - g->inset.blo[0] + 1;
   jdim = g->inset.bhi[1] - g->inset.blo[1] + 1;

   startindexX = 1;
   startindexY = 1;
   endindexX   = idim;
   endindexY   = jdim;

   xlo = g->inset.blo[0];
   ylo = g->inset.blo[1];

   trans[0] =  xlo-1;      /* I = 1 -> X = xlo */
   trans[1] =  1.0;
   trans[2] =  0.0;
   trans[3] =  ylo-1;
   trans[4] =  0.0;
   trans[5] =  1.0;


   pgqcol_c( &c1, &c2 );
   c1 = 17;
   pgscir_c( &c1, &c2 );       /* Set the color index range */
   c1 = 16;
   pgsbci_c( &c1 );

   setinterpolation( g->pginterpol );
   if (g->hardcopy)
   {
      gui_applycol();
   }
   pgimag_c( image,
             &idim,            /* First dimension of 'image' */
             &jdim,            /* Second dimension of 'image' */
             &startindexX,     /* Start of range of first index */
             &endindexX,       /* End of range of first index */
             &startindexY,     /* Start of range of second index */
             &endindexY,       /* End of range of second index */
             &datmin,
             &datmax,
             trans);           /* Transformation matrix between array grids and world coordinates */
}




void displaysliceimage( globaltype *g,
                        int         panelnr,
                        float      *image )
/*------------------------------------------------------------*/
/* PURPOSE: Extracted XV data put on screen.                  */
/*------------------------------------------------------------*/
{
   float  trans[6];
   fint   startindexX, startindexY;
   fint   endindexX, endindexY;
   fint   idim = g->line[panelnr].ndat;
   fint   jdim = g->inset.nsubs;
   float  datmin = g->inset.clip[0];
   float  datmax = g->inset.clip[1];
   fint   c1, c2;
   float  off = 0.0;


   if (g->slicemode == LINE)
      idim = g->line[panelnr].ndat;
   if (g->slicemode == ELLIPSE)
      idim = g->ellipse.ndat;
   if (g->slicemode == SPLINE)
      idim = g->spline.ndatO;

   /* Adjust start position of smallest image if there are 2 images */
   if (g->slicemode == LINE && g->panel2)
   {
      float  l1 = g->line[0].ndat;
      float  l2 = g->line[1].ndat;
      if ( (panelnr == 0 && l1 < l2) || (panelnr == 1 && l2 < l1))
         off = (MYMAX(l1,l2)-MYMIN(l1,l2)) / 2.0;
   }

   startindexX = 1;
   startindexY = 1;
   endindexX   = idim;
   endindexY   = jdim;

   trans[0] =  -0.5 + off;
   trans[1] =   1.0;
   trans[2] =   0.0;
   trans[3] =  -0.5;
   trans[4] =   0.0;
   trans[5] =   1.0;


   pgqcol_c( &c1, &c2 );
   c1 = 17;
   pgscir_c( &c1, &c2 );       /* Set the color index range */
   c1 = 16;
   pgsbci_c( &c1 );

   setinterpolation( g->pginterpol ); 
   if (g->hardcopy)
   {
      gui_applycol();
   } 
   pgimag_c( image,
             &idim,            /* First dimension of 'image' */
             &jdim,            /* Second dimension of 'image' */
             &startindexX,     /* Start of range of first index */
             &endindexX,       /* End of range of first index */
             &startindexY,     /* Start of range of second index */
             &endindexY,       /* End of range of second index */
             &datmin,
             &datmax,
             trans);           /* Transformation matrix between array grids and world coordinates */
}



fint getcword( fchar  Setin,
               fint   profaxnum )
/*------------------------------------------------------------*/
/* PURPOSE: Find the coordinate word that corresponds to the  */
/*          axis with this axis number.                       */
/*                                                            */
/* The grids of all other axes are supposed to be 0.          */
/* This coordinate words enables the transformation between   */
/* grids and physical coordinates for the profile axis        */
/* (usually the velocity axis).                               */
/*------------------------------------------------------------*/
{
   int   i;
   fint  cw = 0;
   fint  setdim;


   setdim  = gdsc_ndims_c( Setin, &setlevel );
   for (i = 0; i < setdim; i++)
   {
      fint  igrid = 0;
      fint  axnr = (fint) i + 1;

      if (axnr != profaxnum)
      {
         fint  r1 = 0;
         cw = gdsc_word_c( Setin, &axnr, &igrid, &cw, &r1 );
      }
   }
   return( cw );
}



static void profileframe( globaltype *g,
                          float       xlogr,
                          float       xhigr,
                          float       xloph,
                          float       xhiph,
                          float       ylo,
                          float       yhi )
/*------------------------------------------------------------*/
/* PURPOSE: Draw a labeled frame for z profiles.              */
/*------------------------------------------------------------*/
{
   float  xtick = 0.0, ytick = 0.0;
   fint   nxsub = 0, nysub = 0;

   
   setviewport( VPXLO, VPYLO, VPXHI, 0.9 );

   pgpage_c();
   setchmm( CHARHEI );
   setcolor( FOREGROUND );

   if (xloph == xhiph)
   {
      xloph -=  0.5; xhiph += 0.5;
   }
   pgswin_c( &xloph, &xhiph, &ylo, &yhi );      
   setwindow( xloph, ylo, xhiph, yhi );

   pgbox_c( tofchar("BNST" ), &xtick, &nxsub,
            tofchar("BNSTV"), &ytick, &nysub );
   pglab_c( tofchar(g->yaxis.headerunits), tofchar(g->inset.dataunits), tofchar("") );

   if (xlogr == xhigr)
   {
      xlogr -=  0.5; xhigr += 0.5;
   }
   setchmm( CHARHEI - 1.0 );
   setwindow( xlogr, ylo, xhigr, yhi );
   pgbox_c( tofchar("CMST" ), &xtick, &nxsub,
            tofchar("CMSTV"), &ytick, &nysub );

}


void getphysraw( globaltype  *g,
                 float        x,
                 float        y, 
                 int          subnr,
                 double       *xph,
                 double       *yph )
/*------------------------------------------------------------*/
/* PURPOSE: Return a string with physical coordinates for     */
/*          grid x, y.                                        */
/*------------------------------------------------------------*/
{
   fint        r;
   double      grid[2];
   double      phys[2];

   if (subnr < 0) 
      subnr = 0;
   if (subnr >= g->inset.nsubs)
      subnr = g->inset.nsubs - 1;

   grid[0] = (double) x;
   grid[1] = (double) y;   
   r = grtoph_c( g->inset.Name,
                 &(g->inset.subsets[subnr]),
                 grid,
                 phys  );
   if (r == 0)
   {
      *xph = phys[0];
      *yph = phys[1];
   }
   else
   {
      *xph = *yph = -999.999;   /* Return a dummy */
   }
}




static void getphysposition( globaltype  *g,
                             float        x,
                             float        y, 
                             int          subnr, 
                             char        *position )
/*------------------------------------------------------------*/
/* PURPOSE: Return a string with physical coordinates for     */
/*          grid x, y.                                        */
/*------------------------------------------------------------*/
{
   fint        r;
   double      grid[2];
   double      phys[2];

   strcpy( position, "" );   
   if (subnr < 0) 
      subnr = 0;
   if (subnr >= g->inset.nsubs)
      subnr = g->inset.nsubs - 1;

   grid[0] = (double) x;
   grid[1] = (double) y;   
   r = grtoph_c( g->inset.Name,
                 &(g->inset.subsets[subnr]),
                 grid,
                 phys  );
   if (r == 0)
   {
      char hmsstr[80];
      char dmsstr[80];
      
      hmsC( phys[0], hmsstr, 2 );
      dmsC( phys[1], dmsstr, 1 );
      sprintf( position, "%s  %s", hmsstr, dmsstr );
   }
}




static void  plotZIprofile( globaltype  *g,
                            float       *Xpos,
                            float       *Ypos,
                            int         ndat )
/*------------------------------------------------------------*/
/* PURPOSE: Get subset data within masked box.                */
/* The mask is set by the vertices of the plotted spline.     */
/*------------------------------------------------------------*/
{
   typedef struct 
   {
      float Xi[10];
      float Yi[10];
      int   nis;
   } intersect;

   intersect   ins[10000];
      
   fint    blo[2];
   fint    bhi[2];
   int     n = ndat;
   int     i, j;
   int     agreed;
   float   x, y;
   int     xi, yi;
   float   Y1, Y2, X1, X2; 
   int     nsect;
   float   *vertX;
   float   *vertY;
   int     **mask = NULL;
   float   **subsetdata = NULL;
   float   pmin, pmax;
   int     subnr;
   float   zx[MAXSUBSETS];
   float   zy[MAXSUBSETS]; 
   fint    axnum = g->inset.axnum[ g->inset.setdim-1 ];
   int     scanline;
   int     numscanlines;
   float   xlo, ylo, xhi, yhi;
   float   step = g->fluxregrid;
   float   area;
   fint    hatchstyle = 3;
      

   if (n < 3)
   {
      if (g->slicemode == ELLIPSE)
         error_status( "Not enough points to make a closed polygon!",
                       "Resample ellipse", "" );
      if (g->slicemode == SPLINE)
         error_status( "Not enough points to make a closed polygon!",
                       "Enter more points with left mouse button", "" );
      helpinstatus( g->slicemode );
      return;            
   }

   /* Allocate memory for vertices and possible closing position */
   vertX = (float*) malloc( (n+1) * sizeof(float) );
   vertY = (float*) malloc( (n+1) * sizeof(float) );
   
   /* Copy the data */
   for (i = 0; i < n; i++)
   {
      vertX[i] = Xpos[i];
      vertY[i] = Ypos[i];      
   }
  
   /* If polygon is not closed then close first */
   if (Xpos[0] != Xpos[n-1] ||
      (Ypos[0] != Ypos[n-1])  )
   {
       vertX[n] = Xpos[0];      
       vertY[n] = Ypos[0];
       n++;
   }
   
   selectplot( g->PGmainplotid );    

   setcolor( GREEN );   
   pgsfs_c( &hatchstyle );
   pgpoly_c( (fint *)&n, vertX, vertY );
   
   /* Find minimum sized box that encloses these positions */
   /* Initialize */
   xlo = xhi = vertX[0];
   ylo = yhi = vertY[0];
   for (i = 1; i < n; i++)
   {
      float xf = vertX[i], yf = vertY[i];
      
      if (xf <  xlo) 
         xlo =  xf;
      if (xf > xhi) 
          xhi = xf;
      if (yf < ylo) 
         ylo =  yf;
      if (yf > yhi) 
         yhi = yf;          
   }
   
   /* Draw frame around enclosing box */
   setcolor( RED );
   plmove( xlo, ylo );
   pldraw( xhi, ylo );
   pldraw( xhi, yhi );
   pldraw( xlo, yhi );
   pldraw( xlo, ylo ); 
   
   blo[0] = NINT( xlo );
   blo[1] = NINT( ylo );
   bhi[0] = NINT( xhi );
   bhi[1] = NINT( yhi );

   agreed = ( (blo[0] >= g->inset.blo[0]) && (blo[1] >= g->inset.blo[1]) &&
              (bhi[0] <= g->inset.bhi[0]) && (bhi[1] <= g->inset.bhi[1]) ); 
   if (!agreed) 
   {
      error_status( "Contour partially outside frame!", "", "" );
      return;
   }
   anyoutf( DEBUG, "DEBUG box: %d %d %d %d", blo[0], blo[1], bhi[0], bhi[1] );
   mask = imatrix( blo[0],                  /* Allocate space for mask matrix */
                   blo[1],
                   bhi[0],
                   bhi[1] );
                   
   subsetdata = fmatrix( blo[0],       /* Allocate space for part of a subset */
                         blo[1],
                         bhi[0],
                         bhi[1] );
   

   if (step <= 0.0)
   {
      error_status( "Pixel regrid must be >= 0.0", "", "" );
      return;
   }
   /*--------------------------------------------------*/
   /* Ordered edge list algorithm from 'Procedural     */
   /* elements for computer graphics', David F. Rogers */
   /*--------------------------------------------------*/      
   for (scanline = 0, y = ylo; y <= yhi; y += step, scanline++)
   {
      nsect = 0;
      /* For each line determine intersections */
      for (i = 1; i < n; i++) 
      {
         X1 = vertX[i-1]; X2 = vertX[i];
         Y1 = vertY[i-1]; Y2 = vertY[i];
         /* Does current scan line intersect this vertices connection line? */
         if (  (y >= Y1 && y <= Y2) ||
               (y <= Y1 && y >= Y2)  )
         {
            /* Calculate the intersection */
            if (Y1 != Y2)
            {
               /* Ignore Horizontal line */
               float Y = y;               

               ins[scanline].Xi[nsect] = ( X1 + (X2-X1) * (Y-Y1) / (Y2-Y1) );
               ins[scanline].Yi[nsect] = Y;  
               nsect++;
            }
         }
      } /* These were all the vertice lines */       
      ins[scanline].nis = nsect;
      /* Sort these intersections to increasing x on the scan line */      
      for (i = 1; i < nsect; i++) 
      {
         for (j = 0; j <= i; j++) 
         {
            float temp;
            if (ins[scanline].Xi[j] > ins[scanline].Xi[i]) 
            {
               temp  = ins[scanline].Xi[j];
               ins[scanline].Xi[j] = ins[scanline].Xi[i];
               ins[scanline].Xi[i] = temp;
               /* No need to sort the Y values because these are the */
               /* same for each scan line */
            }
         }
      }      
   } /* These were all the scan lines */
   numscanlines = scanline;   
   

#if (0)  
   for (i = 0; i < scanline; i++)
   {
      for (j = 0; j < ins[i].nis; j++) 
      {
         anyoutf( 1, "scanline=%d int#=%d %f %f", i, j, ins[i].Xi[j],
                              ins[i].Yi[j] );
      }
   }
#endif

   /* Initialize matrix */
   for (yi = blo[1]; yi <= bhi[1]; yi++)
   {
      for (xi = blo[0]; xi <= bhi[0]; xi++) 
      {
         mask[yi][xi] = 0;
      }
   }
  
   area = 0.0;  
   for (scanline = 0, y = ylo; y <= yhi; y += step, scanline++)
   {
      for (x = xlo; x <= xhi; x += step)
      {
         for (i = 0; i < ins[scanline].nis/2; i++)
         {
            float x1 = ins[scanline].Xi[i*2+0];
            float x2 = ins[scanline].Xi[i*2+1];
            float X = (float) x;
            if (X >= x1 && X <= x2)
            {
               int  xi = NINT(x);
               int  yi = NINT(y);
               /* Mark the points inside the contour */
/*               plsymbol( x, y, 3, 1.0, 1, RED );*/
               area += 1.0;                   
               mask[yi][xi] += 1;
               break;
            }
         }
      }
   }
   area *= (step*step);

   for (y = ylo; y <= yhi; y += step)      
   {
      for (x = xlo; x <= xhi; x += step)    
      {
         int  xi = NINT(x);
         int  yi = NINT(y);
         if (mask[yi][xi] != 0)
         {
/*            plsymbol( x, y, 3, 1.0, 1, mask[yi][xi]/10.0 );*/
         }         
      }
   }

   
   /* Now extract box from all subsets */
   for (subnr = 0; subnr < g->inset.nsubs; subnr++)
   {
      double  sum = 0.0;
      fint    tid  = 0;
      fint    cwlo = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[subnr]), blo );
      fint    cwhi = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[subnr]), bhi );
      fint    imagesize = (bhi[0]-blo[0]+1)*(bhi[1]-blo[1]+1);
      fint    pixelsread;
      fint    cwsub;
      fint    r;
      
      gdsi_read_c( g->inset.Name,
                   &cwlo, &cwhi,
                   &subsetdata[blo[1]][blo[0]],
                   &imagesize,
                   &pixelsread,
                   &tid );

      cwsub = g->inset.subsets[subnr];
      r = 0;
      zx[subnr] = gdsc_grid_c( g->inset.Name, &axnum, &cwsub, &r );
     
      for (yi = blo[1]; yi <= bhi[1]; yi++)      
      {
         for (xi = blo[0]; xi <= bhi[0]; xi++)    
         {
            float v;
            v = subsetdata[yi][xi];
            if (mask[yi][xi] && v != fblank)
            {  
               double pixelratio = (double) mask[yi][xi] * (double) (step*step);
               sum += (double) subsetdata[yi][xi] / pixelratio;
            }
         }
      }            
      zy[subnr] = (float) sum;
   }    
   
  
   minmax1_c( zy, &(g->inset.nsubs), &pmin, &pmax );
   if (pmin == fblank || pmax == fblank)
   {
      error_status( "Cannot plot because min. or max. is blank!", "", "" );
      return;
   }
   else
   {
      char   mes[80]; 
     
      selectplot( g->PGinfoid );
      profileframe( g, 
                    zx[0], zx[g->inset.nsubs-1],
                    g->yaxis.minph, g->yaxis.maxph,      /* is x-axis in plot */
                    pmin, pmax );

      setcolor( GREEN );
      pgline_c( &g->inset.nsubs, zx, zy );            /* The actual sum graph */
      plpoints(  zx, zy, g->inset.nsubs,SMALLCIRCLE );
      sprintf( mes, "Area within closed contour is %g grids", area );      
      gui_zprof_info( 0, mes );
      sprintf( mes, "Minimum SUM is %g, maximum is %g (%s)", pmin, pmax,
               g->inset.dataunits );
      gui_zprof_info( 1, mes );  
   }

   freefmatrix( subsetdata, blo[0], blo[1] );   
   freeimatrix( mask, blo[0], blo[1] );
   free( vertY );
   free( vertX );    
}



float getimagevalue( globaltype  *g,
                     int          xi,
                     int          yi,
                     int          framenr )
/*------------------------------------------------------------*/
/* PURPOSE: Get subset data at position x, y for one subset.  */
/*------------------------------------------------------------*/
{                            
   fint   blo[2];
   fint   bhi[2];                           
   float  zy;
   fint   subset = 0;
   fchar  Set;
   int    indx = - 1;
   int    externalset = (framenr >= g->inset.nsubs);
                   
                 
   if (framenr < 0 )
      return( fblank );
                 
   if (externalset)
   {
      /* This is a special set */
      indx = g->currentframe - g->inset.nsubs;      
      if (!g->external[indx].exist)
      {
         /* Not yet an image */
         return( fblank ); 
      }
      subset = g->external[indx].subset;
      Set.a = g->external[indx].gdsname;
      Set.l = strlen( g->external[indx].gdsname );
   }
   else
   {
      /* It is a movie subset */
      fint  subnr = framenr;
      subset = g->inset.subsets[subnr];
      Set.a = g->inset.name;
      Set.l = strlen( g->inset.name );
   }
                        
   blo[0] = bhi[0] = xi;
   blo[1] = bhi[1] = yi;
 
   {
      fint   imagesize = 1;
      fint   pixelsread;      
      fint   tid  = 0;
      fint   cwlo = gdsc_fill_c( Set, &subset, blo );
      fint   cwhi = gdsc_fill_c( Set, &subset, bhi );
      
      gdsi_read_c( Set,
                   &cwlo, &cwhi,
                   &zy,
                   &imagesize,
                   &pixelsread,
                   &tid );
   }
   return( zy );
}




static void plotzprofile( globaltype  *g,
                          float        x,
                          float        y,
                          int          redrawZframe,
                          float        *minmax )
/*------------------------------------------------------------*/
/* PURPOSE: Get subset data at position x, y for each subset  */
/*          and plot it in a graph.                           */
/*          Return min & max profile value.                   */
/*------------------------------------------------------------*/
{
   static float  zx[MAXSUBSETS];
   static float  zy[MAXSUBSETS];
   int    subnr;
   fint   blo[2];
   fint   bhi[2];
   fint   axnum = g->inset.axnum[ g->inset.setdim-1 ];
   fint   r;
   fint   cwsub;
   fint   imagesize = 1;
   fint   pixelsread;
   int    redraw;
   static int oldnum = 0;

    
   selectplot( g->PGinfoid );   
   redraw = (g->inset.nsubs != oldnum || redrawZframe);
   if (!redraw)   /* Wipe previous line */
   {
      bool curmode;
      curmode = GgiPlotXor( YES );
      setcolor( GREEN );
      pgline_c( &g->inset.nsubs, zx, zy );
      (void) GgiPlotXor( curmode );
   }

   blo[0] = bhi[0] = NINT(x);
   blo[1] = bhi[1] = NINT(y);

   for (subnr = 0; subnr < g->inset.nsubs; subnr++)
   {
      fint tid  = 0;
      fint cwlo = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[subnr]), blo );
      fint cwhi = gdsc_fill_c( g->inset.Name, &(g->inset.subsets[subnr]), bhi );
      gdsi_read_c( g->inset.Name,
                   &cwlo, &cwhi,
                   &zy[subnr],
                   &imagesize,
                   &pixelsread,
                   &tid );

      cwsub = g->inset.subsets[subnr];
      r = 0;
      zx[subnr] = gdsc_grid_c( g->inset.Name, &axnum, &cwsub, &r );
   }
   minmax1_c( zy, &(g->inset.nsubs), &minmax[0], &minmax[1] );

   if (redraw)
   {
      profileframe( g, 
                    zx[0], zx[g->inset.nsubs-1],
                    g->yaxis.minph, g->yaxis.maxph,      /* is x-axis in plot */
                    g->inset.clip[0], g->inset.clip[1] );

      oldnum = g->inset.nsubs;
   }
   {
      bool    curmode;
      curmode = GgiPlotXor( YES );
      setcolor( GREEN );
      pgline_c( &g->inset.nsubs, zx, zy );
      (void) GgiPlotXor( curmode );
   }
   return;
}


#if 0
static void markposition( float x, 
                          float y )
/*------------------------------------------------------------*/
/* PURPOSE: Mark a position (in non slice mode) using currrent*/
/*          marker settings                                   */
/* Utility frunction currently not in use. Could be handy if  */
/* we want to put a marker without storing its position.      */
/*------------------------------------------------------------*/
{
   fint   col = GREENCYAN, mwidth = 4, symbol = CROSS;
   float  chsize = 2.0;
   

   /* Get the properties first */
   {
      fint   dfault = HIDDEN;
      fint   nitems = 1;
      (void) userint_c( &col, &nitems, &dfault, tofchar("FLAGCOL="), tofchar(" ") );
      (void) userint_c( &mwidth, &nitems, &dfault, tofchar("MARKWIDTH="), tofchar(" ") );      
      (void) userint_c( &symbol, &nitems, &dfault, tofchar("MARKSYM="), tofchar(" ") );      
      (void) userreal_c( &chsize, &nitems, &dfault, tofchar("MARKSIZE="), tofchar(" ") );
      
      if (col < 1) col = 1;
      if (col > 15) col = 15;
      if (mwidth < 1) mwidth = 1;
      if (mwidth > 21) mwidth = 21;      
      if (symbol < 1) symbol = 1;
      if (chsize < 0.0) chsize = 1.0;
   }
   plsymbol( x, y, symbol, chsize, mwidth, col );
}
#endif


static XVflag *updateflags( XVflag   *flag,
                            int       nearest,
                            int       *numflags )
/*------------------------------------------------------------*/
/* PURPOSE: A flag is added or deleted. Update the flags      */
/*          array.                                            */
/* Input is the old flags array. the new index (or the index  */
/* of the toggle and the flags array length. Returned is a    */
/* pointer to the updated flags array and the new length.     */
/*------------------------------------------------------------*/
{
   int    alreadyflagged = NO;
   int    flagindx = -1;
   int    i, n;
   fint   col = GREENCYAN, fwidth = 4, mwidth = 4, 
          style = FULL, symbol = CROSS;
   float  chsize = 2.0;
   

   /* Get the properties first */
   {
      fint   dfault = HIDDEN;
      fint   nitems = 1;
      (void) userint_c( &col, &nitems, &dfault, tofchar("FLAGCOL="), tofchar(" ") );
      (void) userint_c( &fwidth, &nitems, &dfault, tofchar("FLAGWIDTH="), tofchar(" ") );
      (void) userint_c( &mwidth, &nitems, &dfault, tofchar("MARKWIDTH="), tofchar(" ") );      
      (void) userint_c( &style, &nitems, &dfault, tofchar("FLAGSTYLE="), tofchar(" ") );
      (void) userint_c( &symbol, &nitems, &dfault, tofchar("MARKSYM="), tofchar(" ") );      
      (void) userreal_c( &chsize, &nitems, &dfault, tofchar("MARKSIZE="), tofchar(" ") );
      
      if (col < 1) col = 1;
      if (col > 15) col = 15;
      if (fwidth < 1) fwidth = 1;
      if (fwidth > 21) fwidth = 21;      
      if (mwidth < 1) mwidth = 1;
      if (mwidth > 21) mwidth = 21;      
      if (style < 1) style = 1;
      if (style > 4) style = 4;
      if (symbol < 1) symbol = 1;
      if (chsize < 0.0) chsize = 1.0;
   }
   
   n = *numflags;
   /* Is this point already flagged? */
   for (i = 0; i < n; i++)
   {
      if (flag[i].index == nearest)
      {
         flagindx = i;
         alreadyflagged = YES;
      }
   }
   if (!alreadyflagged)        /* Add a new flag */
   {
      flag = (XVflag *) realloc( (XVflag *) flag, (n+1)*sizeof(XVflag) );
      flag[n].index = nearest;
      flag[n].index = nearest;            
      flag[n].colour = col;
      flag[n].linewidth = fwidth;
      flag[n].markwidth = mwidth;      
      flag[n].linestyle = style;
      flag[n].symbol = symbol;
      flag[n].size = chsize;
      n++;
   }
   else                        /* Delete the one that was already marked */
   {
      int j;
      for (i = 0, j = 0; i < n; i++)
      {
         if (i != flagindx)
         {
            /* Copy this flag */
            flag[j].index = flag[i].index;
            flag[j].colour = flag[i].colour;
            flag[j].linewidth = flag[i].linewidth;
            flag[j].markwidth = flag[i].markwidth;            
            flag[j].linestyle = flag[i].linestyle;
            flag[j].symbol = flag[i].symbol;
            flag[j].size = flag[i].size;
            j++;
         }
      }
      n--;      
   }   
   *numflags = n;
   return( flag );
}



void doslice(ident id, void *arg)
{
   *(bool *)arg = YES;
}


void xvcursor( ident         id,
               GgiPlotInfo   info,
               void          *arg )
/*------------------------------------------------------------*/
/* PURPOSE: React to cursor actions in a slice window         */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float       x=info->x, y=info->y;                     /* World coordinates */
   int         button=info->button, state=info->state;
   float       ylo, yhi;
   int         fnr;
   int         inside;

   ylo = g->yaxis.minph; yhi = g->yaxis.maxph;
   if (ylo == yhi)
   {
      ylo -=  0.5; yhi += 0.5;
   }
   ylo = g->yaxis.mingrid;
   yhi = g->yaxis.maxgrid;

   x = 0.0; /*button = -1;*/ /* Dummies */
   inside = (y <= yhi && y >= ylo);
   if (inside && state&ggiButn1 && state == 1)
   {
      fnr = NINT(y) - (int)ylo;
      if (button&ggiButn1)
      {
         g->skipsliceupdate = 0;
         /* Do an update of frame and slice (subset arrow in slice plot) */
      }
      else
      {
         g->skipsliceupdate = 1;       /* Skip update of the xv image */
      }
      /* Now update frame in main window. Usually after this update */
      /* the xv image(s) are updated also. But if only mouse button */
      /* 1 was used in the slice windows to change frames in the    */
      /* main window, there is no need to update the xv images. The */
      /* update process is skipped because we have set the flag     */
      /* 'skipsliceupdate'.                                         */
      wkeyf( "FRAME=%d", fnr );
   }
}


void cursor( ident         id,
             GgiPlotInfo   info,
             void          *arg )
/*------------------------------------------------------------*/
/* PURPOSE: React to cursor actions in mainplot window        */
/*------------------------------------------------------------*/
{
   globaltype  *g = (globaltype*) arg;
   float       x=info->x, y=info->y;                     /* World coordinates */
   int         button=info->button, state=info->state;
   int         button1ON, button1OFF; 
   int         button2ON, button2OFF;         
   int         button3ON, button3OFF;   
   float       nearmax = 0.0;
   float       imval;            

   static int    redrawZframe = YES; 
   static ident  timer;
   static bool   elapsed;
   static int    splineinsertmode = NO;
   static int    splinedeletemode = NO;
   static int    splineaddmode = NO;   


   int         inside;
   int         xi = NINT(x);
   int         yi = NINT(y);
   int         zoomin, zoomout, reset, move;
   int         mousezoomin, mousezoomout;
   int         arleft, arright, arup, ardown, arrows;
         
   
   inside = ( xi >= g->inset.blo[0] && xi <= g->inset.bhi[0] &&
              yi >= g->inset.blo[1] && yi <= g->inset.bhi[1] );   

   button1ON  = ((button&ggiButn1) && !(state&ggiButn1));
   button1OFF = ((button&ggiButn1) &&  (state&ggiButn1));
   button2ON  = ((button&ggiButn2) && !(state&ggiButn2));
   button2OFF = ((button&ggiButn2) &&  (state&ggiButn2));
   button3ON  = ((button&ggiButn3) && !(state&ggiButn3));
   button3OFF = ((button&ggiButn3) &&  (state&ggiButn3));

   /*anyoutf( 1, "button=%d state=%d", button, state ); */

   if (button1ON || button2ON || button3ON)
   {
      gui_error(" ");  /* Clear possible error message */
   }

   /* Display cursor position information first */
   {      
      char        mes[128];
      
      if (inside)
      {
         char        position[128];
         int         framenr = g->currentframe;
         
         /* Framenr is the same as the current subset index. */
         imval = getimagevalue( g, NINT(x), NINT(y), framenr );         
        
         if (g->inset.grid2hmsdms)
         {
            getphysposition( g, x, y, framenr, position );
            if (imval != fblank)
               sprintf( mes, "%+5d %+5d    %+-20g  %20s", NINT(x), NINT(y), imval, position );
            else
               sprintf( mes, "%+5d %+5d    %-20s  %20s",
                        NINT(x), NINT(y), "blank", position );
         }
         else
         {
            if (imval != fblank)
               sprintf( mes, "%+5d %+5d    %+-20g", NINT(x), NINT(y), imval );
            else
               sprintf( mes, "%+5d %+5d    %-20s", NINT(x), NINT(y), "blank" );
         }
      }      
      else
         strcpy( mes, "outside box" );   
      gui_info( SECONDLINE, mes );
   }
         
   if  (!inside)
   {
      /* Nothing to do */
      return;
   }

   if (g->slicemode == -1)
   {
      if (state == 1)  /* i.e. left mouse button is moving */
      {	      
         float lx = fabs(g->inset.bhi[0]-g->inset.blo[0]) + 1.0;
         float ly = fabs(g->inset.bhi[1]-g->inset.blo[1]) + 1.0;      
         float xoff = (x - g->inset.blo[0]) / lx;
         float yoff = (y - g->inset.blo[1]) / ly;
         xoff -= 0.5;
         yoff *= 5.0;
         wkeyf( "CE_SHIFT1=%f", xoff );
         wkeyf( "CE_SLOPE1=%f", yoff );         
      }
   }

#if 0
   /* Put markers without storing their positions */
   if (g->slicemode == -1)
   {
      if (button1OFF || toupper(info->key) == 'M' )
      {
         anyoutf( 1, "%10.3f  %10.3f  %g", x, y, imval );
         markposition( x, y );
      }
   }
#endif

   /*------------------------------------------------------------*/
   /* Calculate the maximum distance in pixels in which a sample */
   /* point can be marked. This number depends on the box. We    */
   /* suggest to use two character heights for this.             */
   /*------------------------------------------------------------*/   
   {
      float x1 = fabs(g->inset.bhi[0]-g->inset.blo[0]);
      float x2 = fabs(g->inset.bhi[1]-g->inset.blo[1]);
      nearmax = MYMIN( x1, x2 )/ 20.0;
   }


   /* Zoom OUT */
   mousezoomin = (button==1 && state==8);
   mousezoomout = (button==1 && state==16);
   zoomout = (info->key == '-' || info->key == '_'  || mousezoomout);
   zoomin  = (info->key == '+' || info->key == '='  || mousezoomin);
   arleft  = (info->key == (char) ggiLeftArrow);
   arright = (info->key == (char) ggiRightArrow);
   arup    = (info->key == (char) ggiUpArrow);
   ardown  = (info->key == (char) ggiDownArrow);
   reset   = (info->key == '0');      /* Reset to flo, fhi box */
   move    = (info->key == '9');      /* Pan to mouse position without zooming */
   
   arrows = ( arleft || arright || arup || ardown );
   if (zoomin || zoomout || arrows || reset || move)
   {
      float lx = fabs(g->inset.bhi[0]-g->inset.blo[0]) + 1.0;
      float ly = fabs(g->inset.bhi[1]-g->inset.blo[1]) + 1.0;
      float zoomoutfact, zoominfact;
      int   xlo, xhi, ylo, yhi;
      int   indx;
      int   i;
      

      /*----------------------------------------*/
      /* For each frame (also external set      */
      /* frames), set a flag that it must be    */
      /* reloaded.                              */
      /*----------------------------------------*/
      for (i = 0; i < g->inset.nsubs + 3; i++)
      {
         g->updateframe[i] = 1;
      }

      /* Set the zoom factors. Use 1.0 for panning only */
      if (move)
      {
         zoominfact = zoomoutfact = 1.0;
      }      
      else
      {
         zoomoutfact = sqrt(2.0);
         zoominfact = 1.0/zoomoutfact;               
      }
      
      if (zoomout)
      {
         lx *= zoomoutfact;
         ly *= zoomoutfact;
      }
      else
      {
         lx = MYMAX( lx * zoominfact, 1 );
         ly = MYMAX( ly * zoominfact, 1 );
      }      
      if (zoomout)
      {
      	 if (g->inset.blo[0] > g->inset.flo[0])      
            xlo = MYMAX( NINT(x - 0.5*lx), g->inset.flo[0] );
         else
            xlo = g->inset.flo[0];
      	 if (g->inset.bhi[0] < g->inset.fhi[0])                  
            xhi = MYMIN( NINT(x + 0.5*lx), g->inset.fhi[0] ); 
         else
            xhi = g->inset.fhi[0];
      	 if (g->inset.blo[1] > g->inset.flo[1])         
            ylo = MYMAX( NINT(y - 0.5*ly), g->inset.flo[1] );
         else
            ylo = g->inset.flo[1];
      	 if (g->inset.bhi[1] < g->inset.fhi[1])               
            yhi = MYMIN( NINT(y + 0.5*ly), g->inset.fhi[1] ); 
         else
            yhi = g->inset.fhi[1];
      }
      if (zoomin || move)
      {
            xlo = MYMAX( NINT(x - 0.5*lx), g->inset.flo[0] );
            xhi = MYMIN( NINT(x + 0.5*lx), g->inset.fhi[0] ); 
            ylo = MYMAX( NINT(y - 0.5*ly), g->inset.flo[1] );
            yhi = MYMIN( NINT(y + 0.5*ly), g->inset.fhi[1] ); 
      }      
      if (arrows)
      {
         int deltax = MYMAX( 1, lx / 20 );
         int deltay = MYMAX( 1, ly / 20 );         
         if (arleft)
         {
            float dmax = MYMIN( deltax, g->inset.blo[0] - g->inset.flo[0] );
            if (dmax > 0)
            {
               xlo = MYMAX( g->inset.blo[0] - dmax, g->inset.flo[0] );
               xhi = MYMIN( g->inset.bhi[0] - dmax, g->inset.fhi[0] );
               ylo = g->inset.blo[1]; yhi = g->inset.bhi[1];
            }
            else
               return;            
         }
         if (arright)
         {
            float dmax = MYMIN( deltax, g->inset.fhi[0] - g->inset.bhi[0] );
            if (dmax > 0)            
            {
               xlo = MYMAX( g->inset.blo[0] + dmax, g->inset.flo[0] );
               xhi = MYMIN( g->inset.bhi[0] + dmax, g->inset.fhi[0] );
               ylo = g->inset.blo[1]; yhi = g->inset.bhi[1];           
            }
            else
               return;            
         }
         if (ardown)
         {
            float dmax = MYMIN( deltay, g->inset.blo[1] - g->inset.flo[1] );
            if (dmax > 0)            
            {
               ylo = MYMAX( g->inset.blo[1] - dmax, g->inset.flo[1] );
               yhi = MYMIN( g->inset.bhi[1] - dmax, g->inset.fhi[1] );
               xlo = g->inset.blo[0]; xhi = g->inset.bhi[0];
            }
            else
               return;            
         }
         if (arup)
         {
            float dmax = MYMIN( deltax, g->inset.fhi[1] - g->inset.bhi[1] );            
            if (dmax > 0)            
            {
               ylo = MYMAX( g->inset.blo[1] + dmax, g->inset.flo[1] );
               yhi = MYMIN( g->inset.bhi[1] + dmax, g->inset.fhi[1] );
               xlo = g->inset.blo[0]; xhi = g->inset.bhi[0];            
            }
            else
               return;
         }
      }
      if (reset)
      {
      	 /* Maximize (i.e. reset) with '0' */
         xlo = g->inset.flo[0]; xhi = g->inset.fhi[0];
         ylo = g->inset.flo[1]; yhi = g->inset.fhi[1];         
      }
     
      /*--------------------------------------------------*/
      /* The box must be updated first because we need    */
      /* blo, bhi in the 'readsinglesub' routine.         */
      /* This construction avoids the use of              */
      /* GgiHandleEvents().                               */
      /*--------------------------------------------------*/      
      SuppressKeyevent( getbox, "BOX=" ); 
      wkeyf( "BOX=%d %d %d %d", xlo, ylo, xhi, yhi );
      getbox( NULL, "BOX=", KEYCHANGE, g ); 
            
      indx = g->currentframe - g->inset.nsubs;
      if (indx >= 0)
      {
         /* Display again the current external set */
         displayexternalset( indx, g );
      }
      else
      {
         /* Display again the current subset */
         readsinglesub( g->currentframe, g );
      }
      g->updateframe[g->currentframe] = 0;                     /* Need not to be loaded later */
      return;
   } 

   

   if (g->slicemode == LINE || g->slicemode == ELLIPSE)
   {
      /* Activate a timer to prevent too many slice updates */ 
      if (button1OFF || button2OFF)
      {
         if (timer) Deschedule( &timer );                      /* Timer off */
      }
      if (button1ON || button2ON)
      {
         timer = ScheduleTimer( doslice, 250, &elapsed );         /* Timer on */
      }
   }

   /* Sample from a line */
   if (g->slicemode == LINE)
   {
      if (!state && button&ggiButn1)
      {
         Herevents( FALSE );
      }
      if (state&ggiButn1 && state==1)
      {
         /* Button 1 pressed */
         float Dx = x - g->line[0].xc;
         float Dy = y - g->line[0].yc;                    
         double angle;
         double dist;

         angle = DEG(atan2( Dy, Dx ));
         dist = 2.0 * sqrt( Dx*Dx + Dy*Dy );

         
         /* Is button 1 just released? */
         if (button&ggiButn1)
         {
            elapsed = YES;
            Herevents( TRUE );
            SuppressKeyevent( getsampleangle, "POSANG=" );
            wkeyf( "POSANG=%.2f", putinrangedeg(angle - 90.0) );


            /* SuppressKeyevent( getsamplelen, "SAMPLEN1=" ); */
            /* The reason not to suppress this event is the   */
            /* coupling of the line slices. If we release the */
            /* the mouse button we want to check whether a    */
            /* second line is coupled.                        */
            wkeyf( "SAMPLEN1=%g", dist );            
         }
         g->line[0].angle = putinrangedeg( angle );
         g->line[0].samplelen = dist;                  

         if (elapsed)
         {
            getxvfromline( g, EXTRACT );
            elapsed = NO;            
         }
         else
         {
            getxvfromline( g, NOEXTRACT );
         }
      }
      if (state&ggiButn2)
      {
         /* Is button 2 just released? */
         if (button&ggiButn2)
         {
            elapsed = YES;
         }          
         g->line[0].xc = x;
         g->line[0].yc = y;
         SuppressKeyevent( getxcyc, "CENTRE=" );
         wkeyf( "CENTRE=%.2f %.2f", x, y );         
         if (elapsed) 
         {
            elapsed = NO;
            getxvfromline( g, EXTRACT );
         }
         else
         {
            getxvfromline( g, NOEXTRACT );
         }
      }
      if (toupper(info->key) == 'M' )
      {
          int   nearest = nearestinarray( x, y, 
                                          g->line[0].Xpos, 
                                          g->line[0].Ypos, 
                                          g->line[0].ndat,
                                          nearmax );           
          if (nearest < 0)
             return;
      
          g->line[0].flag = updateflags( g->line[0].flag, 
                                         nearest,
                                         &(g->line[0].numflags) );
          getxvfromline( g, EXTRACT );
      }
      if (toupper(info->key) == 'E' )
      {
         wkeyf("CLEARFLAGS=Y");
      }      
   }
    
   if (g->slicemode == ELLIPSE)
   {
      if (state&ggiButn1 && state==1) 
      {
         float Dx = x - g->ellipse.xc;
         float Dy = y - g->ellipse.yc;
         double angle, a1, a2;
         double dist; 
         int    maj;
        
         /* Is button 1 just released? */
         if (button&ggiButn1)
         {
            elapsed = YES;
         }       
         dist = sqrt( Dx*Dx + Dy*Dy );
         angle = DEG(atan2( Dy, Dx ));
         a1 = putinrangedeg( angle );
         a2 = putinrangedeg( g->ellipse.angle );
         maj = ( ABS(a1-a2) <= 45.0  || ABS(a1-a2) >= 270 ||
                (ABS(a1-a2) > 135.0 && ABS(a1-a2) < 270) );
       
         if (maj)
         {
            SuppressKeyevent( getsampleangle, "E_POSANG=" );
            wkeyf( "E_POSANG=%.2f", putinrangedeg(angle - 90.0) );
            g->ellipse.angle = putinrangedeg( angle );
            SuppressKeyevent( getsamplelen, "E_SAMPLEN1=" ); 
            g->ellipse.major = MYMAX(g->ellipse.minor, dist);            
            wkeyf( "E_SAMPLEN1=%g", g->ellipse.major );
         }
         else
         {
            SuppressKeyevent( getsampleangle, "E_POSANG=" );
            wkeyf( "E_POSANG=%.2f", putinrangedeg(angle + 180.0) );
            g->ellipse.angle = putinrangedeg(angle - 90);
            SuppressKeyevent( getsamplelen, "E_SAMPLEN2=" ); 
            g->ellipse.minor = MYMIN(g->ellipse.major, dist);
            wkeyf( "E_SAMPLEN2=%g", g->ellipse.minor );
         }
         if (elapsed) 
         {
            elapsed = NO; 
            getxvfromellipse( g, EXTRACT );
         }
         else
         {
            getxvfromellipse( g, NOEXTRACT );
         }
      }
      if (state&ggiButn2) /* Move centre of ellipse */
      {
         /* Is button 2 just released */
         if (button&ggiButn2)
         {
            elapsed = YES;
         }         
         g->ellipse.xc = x;
         g->ellipse.yc = y;
         SuppressKeyevent( getxcyc, "E_CENTRE=" );
         wkeyf( "E_CENTRE=%.2f %.2f", x, y );
         if (elapsed) 
         {
            elapsed = NO;
            getxvfromellipse( g, EXTRACT ); 
         }
         else
         {
            getxvfromellipse( g, NOEXTRACT );
         }
      }
      if (toupper(info->key) == 'M' )
      {
         int   nearest = nearestinarray( x, y, 
                                         g->ellipse.Xpos, 
                                         g->ellipse.Ypos, 
                                         g->ellipse.ndat,
                                         nearmax );
         if (nearest < 0)
            return;
               
         g->ellipse.flag = updateflags( g->ellipse.flag, 
                                        nearest,
                                        &(g->ellipse.numflags) );
         getxvfromellipse( g, EXTRACT );
      }      
      if (toupper(info->key) == 'E' )
      {
         wkeyf("CLEARFLAGS=Y");
      }      
      if (toupper(info->key) == 'Z' && g->PGinfoid)             
      {
         plotZIprofile( g, g->ellipse.Xpos, g->ellipse.Ypos, g->ellipse.ndat );
         redrawZframe = YES;
      }               
   }

   if (g->slicemode == SPLINE)
   {
      char    mes[80];               
      /*--------------------------------------------------*/
      /* Add, insert or delete spline points or close     */
      /* polygon.                                         */
      /*--------------------------------------------------*/      
      /* Is this event caused by a keyboard character? */      
      if (info->button & ggiKeybd)
      {
         char    mes[80];            

         /*----------------------------------------*/
         /* Close contour.                         */         
         /*----------------------------------------*/
         if (toupper(info->key) == 'C' )
         {
            if (g->spline.ndat > 2)
            {
               x = g->spline.Xpos[0];
               y = g->spline.Ypos[0];            
            
               /* Is this point different from the previous? */
               if (x != g->spline.Xpos[g->spline.ndat-1] || y != g->spline.Ypos[g->spline.ndat-1])
               {
                  g->spline.Xpos[g->spline.ndat] = x;
                  g->spline.Ypos[g->spline.ndat] = y;
                  if (g->spline.ndat < MAXPAR-1)
                  {
                     g->spline.ndat++;
                     gui_error( "" );
                     sprintf( mes, "Closed to position: %.1f   %.1f", x, y );
                     gui_status( mes, 0 );
                  }
               }
               getxvfromspline( g );
            }
            else
            {
               gui_error( "Need at least 3 points to close polygon" );
               gui_status( "Add another point first", 0 );
            }
         }
         
         /*----------------------------------------*/
         /* Calculate flux in area                 */         
         /*----------------------------------------*/
         if (toupper(info->key) == 'Z' && g->PGinfoid)
         {        
            /*--------------------------------------------------*/
            /* Only with a spline it is important to close the  */
            /* contour and recalculate the interpolated points. */
            /* Only for a closed contour the spline end tangent */
            /* and begin vectors are adapted.                   */
            /* This results in a more smooth connection of the  */
            /* closed contour.                                  */
            /*--------------------------------------------------*/
            if (g->spline.Xpos[0] != g->spline.Xpos[g->spline.ndat-1] || 
                g->spline.Ypos[0] != g->spline.Ypos[g->spline.ndat-1])
            {
               g->spline.Xpos[g->spline.ndat] = g->spline.Xpos[0];
               g->spline.Ypos[g->spline.ndat] = g->spline.Ypos[0];
               if (g->spline.ndat < MAXPAR-1)
               {
                  g->spline.ndat++; 
                  getxvfromspline( g );
               }
            }
            plotZIprofile( g, g->spline.XposO, g->spline.YposO, g->spline.ndatO );
            redrawZframe = YES;                     
         }
         
         /* The spline modes are static variables */
         if (toupper(info->key) == 'I' )
         {
            splineinsertmode = YES;
            gui_status( "INSERT mode", 0 );
         }
         if (toupper(info->key) == 'D' )
         {
            splinedeletemode = YES;
            gui_status( "DELETE mode", 0 );
         }         
         if (toupper(info->key) == 'A' )
         {
            splineinsertmode = splinedeletemode = NO;
            gui_status( "ADD mode", 0 ); 
         }
         if (toupper(info->key) == 'M' )
         {
            int   nearest = nearestinarray( x, y, 
                                            g->spline.XposO, 
                                            g->spline.YposO, 
                                            g->spline.ndatO,
                                            nearmax );           
            if (nearest < 0)
               return;
               
            g->spline.flag = updateflags( g->spline.flag, 
                                          nearest,
                                          &(g->spline.numflags) );

            getxvfromspline( g );
         }
         if (toupper(info->key) == 'E' )
         {
            wkeyf("CLEARFLAGS=Y");
         }
         if (toupper(info->key) == 'S' )
         {
            wkeyf("SPLINECLEAR=Y");
         }         
      }
      if (!splinedeletemode && !splineinsertmode)
      {
         splineaddmode = YES;
      }
      else
      {
         splineaddmode = NO;
      }

      /* Press MB1 for a new spline point */     
      if (button==1 && state==1)
      {
         if (splineaddmode)
         {
            if (g->spline.ndat > 0)
            {
               /* Is this point different from the previous? */
               if (x != g->spline.Xpos[g->spline.ndat-1] || y != g->spline.Ypos[g->spline.ndat-1])
               {
                  g->spline.Xpos[g->spline.ndat] = x;
                  g->spline.Ypos[g->spline.ndat] = y;
                  if (g->spline.ndat < MAXPAR-1)
                  {
                     g->spline.ndat++;
                     sprintf( mes, "Added position: %.1f   %.1f", x, y );
                     gui_status( mes, 0 );
                  }
               }
            }
            else
            {
               /* First point, copy always */
               g->spline.Xpos[g->spline.ndat] = x;
               g->spline.Ypos[g->spline.ndat] = y;
               if (g->spline.ndat < MAXPAR-1)
               {
                  g->spline.ndat++;
                  sprintf( mes, "Start position: %.1f   %.1f", x, y );
                  gui_status( mes, 0 ); 
               }
            }
            getxvfromspline( g );
         }
      }

      if (splinedeletemode)
      {
         /* Delete a point */
         int   n = g->spline.ndat;
         g->spline.ndat = splinedelete( x, y, &(g->spline) );
         if (n != g->spline.ndat)
         {
            sprintf( mes, "Deleted position: %.1f   %.1f", x, y );
            gui_status( mes, 0 );
         }
         splinedeletemode = NO;
         getxvfromspline( g );
      }
      if (splineinsertmode)
      {
         /* insert a point in the spline array */
         g->spline.ndat = splineinsert( x, y, &(g->spline) );
         sprintf( mes, "Inserted position: %.1f   %.1f", x, y );
         gui_status( mes, 0 );
         splineinsertmode = NO;
         getxvfromspline( g );
      }            
   }



   /*------------------------------------------------------------*/
   /* For all modes, if button 3 is moved, give z profile at     */
   /* mouse position x, y.                                       */
   /*------------------------------------------------------------*/
   if ( (state&ggiButn3 && !(state&ggiShift)) || button3ON )        
   {
      char        mes[128];

      if (g->PGinfoid)
      {
         float  minmax[2];         

         plotzprofile( g, x, y, redrawZframe, minmax );
         redrawZframe = NO;                  
         sprintf( mes, "Profile Grid: %5d %5d", NINT(x), NINT(y) );
         gui_zprof_info( 0, mes );
         sprintf( mes, "Profile minimum: %14g   maximum: %14g (%s)", 
                  minmax[0], minmax[1], g->inset.dataunits );
         gui_zprof_info( 1, mes );
      }
      else
      {
         /* Pop up the z-profile window */
         wkeyf( "_POP_ZPROF=Y" );
      }
   }
}
#<

#>            ellsam.c
/* ellsam.c
                           COPYRIGHT (c) 2000
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/

#include    "common.h"
#include    "ellsam.h"
#include    "plot.h"
#include    "pgplot.h"


extern double dblank;  



#define ERRTOL 0.05
#define TINY 1.0e-25
#define BIG 4.5e21
#define C1 (3.0/14.0)
#define C2 (1.0/6.0)
#define C3 (9.0/22.0)
#define C4 (3.0/26.0)
#define C5 (0.25*C3)
#define C6 (1.5*C4)


static float rd(float x, float y, float z)
{
   float alamb,ave,delx,dely,delz,ea,eb,ec,ed,ee,fac,sqrtx,sqrty,
         sqrtz,sum,xt,yt,zt;

   if (MYMIN(x,y) < 0.0 || MYMIN(x+y,z) < TINY || MYMAX(MYMAX(x,y),z) > BIG)
   {
      anyoutf( 1, "Invalid arguments in routine rd that calculates ellipse sample" );
      return( 0.0 );
   }


   xt=x;
   yt=y;
   zt=z;
   sum=0.0;
   fac=1.0;
   do 
   {
      sqrtx=sqrt(xt);
      sqrty=sqrt(yt);
      sqrtz=sqrt(zt);
      alamb=sqrtx*(sqrty+sqrtz)+sqrty*sqrtz;
      sum += fac/(sqrtz*(zt+alamb));
      fac=0.25*fac;
      xt=0.25*(xt+alamb);
      yt=0.25*(yt+alamb);
      zt=0.25*(zt+alamb);
      ave=0.2*(xt+yt+3.0*zt);
      delx=(ave-xt)/ave;
      dely=(ave-yt)/ave;
      delz=(ave-zt)/ave;
   } 
   while (MYMAX(MYMAX(fabs(delx),fabs(dely)),fabs(delz)) > ERRTOL);
   
   ea=delx*dely;
   eb=delz*delz;
   ec=ea-eb;
   ed=ea-6.0*eb;
   ee=ed+ec+ec;
   return 3.0*sum+fac*(1.0+ed*(-C1+C5*ed-C6*delz*ee)
           +delz*(C2*ee+delz*(-C3*ec+delz*C4*ea)))/(ave*sqrt(ave));
}
#undef ERRTOL
#undef TINY
#undef BIG
#undef C1
#undef C2
#undef C3
#undef C4
#undef C5
#undef C6



#define NRANSI
#define ERRTOL 0.08
#define TINY 1.5e-38
#define BIG 3.0e37
#define THIRD (1.0/3.0)
#define C1 (1.0/24.0)
#define C2 0.1
#define C3 (3.0/44.0)
#define C4 (1.0/14.0)


double rf(double x, double y, double z)
{
   double alamb,ave,delx,dely,delz,e2,e3,sqrtx,sqrty,sqrtz,xt,yt,zt;

   if (MYMIN(MYMIN(x,y),z) < 0.0 || MYMIN(MYMIN(x+y,x+z),y+z) < TINY ||
       MYMAX(MYMAX(x,y),z) > BIG)
   {
      anyoutf( 1, "Invalid arguments in routine rf that calculates ellipse sample" );
      return( 0 );
   }
        
   xt=x;
   yt=y;
   zt=z;
   do 
   {
      sqrtx=sqrt(xt);
      sqrty=sqrt(yt);
      sqrtz=sqrt(zt);
      alamb=sqrtx*(sqrty+sqrtz)+sqrty*sqrtz;
      xt=0.25*(xt+alamb);
      yt=0.25*(yt+alamb);
      zt=0.25*(zt+alamb);
      ave=THIRD*(xt+yt+zt);
      delx=(ave-xt)/ave;
      dely=(ave-yt)/ave;
      delz=(ave-zt)/ave;
   } 
   while (MYMAX(MYMAX(fabs(delx),fabs(dely)),fabs(delz)) > ERRTOL);
   
   e2=delx*dely-delz*delz;
   e3=delx*dely*delz;
   return (1.0+(C1*e2-C2-C3*e3)*e2+C4*e3)/sqrt(ave);
}
#undef ERRTOL
#undef TINY
#undef BIG
#undef THIRD
#undef C1
#undef C2
#undef C3
#undef C4




float elle(float phi, float ak)
{
   float cc,q,s;

   s=sin(phi);
   cc=cos(phi)*cos(phi);
   q=(1.0-s*ak)*(1.0+s*ak);
   return s*(rf(cc,q,1.0)-((s*ak)*(s*ak))*rd(cc,q,1.0)/3.0);
}



static double funczero( double  x1,
                        double  x2,
                        double  a,
                        double  k,
                        double  arclen )
/*------------------------------------------------------------*/
/* PURPOSE: Evaluate the polynomial for which to find a zero. */
/*------------------------------------------------------------*/
{
   double res = a*(elle( asin( x2/a ), k )-elle( asin( x1/a ), k )) - arclen;
   /*anyoutf( 1, "fun(%g)=%g",x2, res );*/
   return( res ); 
}




static double newX( double x1,
                    double arclen,
                    double a,
                    double k )
/*------------------------------------------------------------*/
/* PURPOSE: Use simple bisection to get zero value.           */
/*------------------------------------------------------------*/
{
   int     j;
   double  dx, f, fmid, xmid, rtb;
   double  xacc = 1.0e-8;
   int     maxiters = 100; 
   double  x2 = MYMIN(x1 + arclen, a);


   if (x1 == x2)
      return( dblank );
      
   f = funczero( x1, x1, a, k, arclen );
   fmid = funczero( x1, x2, a, k, arclen );
   if (f*fmid >= 0.0)
   {
      return( dblank );
   }

   rtb = f < 0.0 ? (dx=x2-x1,x1) : (dx=x1-x2,x2);
   for (j = 1; j <= maxiters; j++)
   {
      fmid = funczero( x1, xmid=rtb+(dx *= 0.5), a, k, arclen );
      if (fmid <= 0.0)
         rtb = xmid;
      if (fabs(dx) < xacc || fmid == 0.0)
         return rtb;
   }
   return( dblank );
}



int sampleellipse( double  x0,
                   double  y0,
                   double  maj,
                   double  min,
                   double  arclen,
                   double  angle,
                   double  start,
                   double  end,
                   float  *xsam,
                   float  *ysam,
                   int     Nmax )
/*------------------------------------------------------------*/
/* PURPOSE: Get sample points on ellipse at equal distances   */
/*          along the arc.                                    */
/* The angle enters in degrees and is calculated wrt. The +X  */
/* axis. Write the ellipse in the parametric form x = a.cos(t)*/
/* and y = b.sin(t). Note that t is not the eccentric anomaly */
/* (or polar angle). The arc length of an ellipse is:         */
/* s = I[sqrt(x'^2+y'^2)]]. With x and y in parametric form   */
/* we find that s = a.I[sqrt(1-(1-b^2/a^2)(sint)^2)]dt ==     */
/* a.E(t,k) with k = (1-b^2/a^2) and E is the incomplete      */
/* Elliptic Integral of the Second Kind. The eccentric anomaly*/
/* follows from theta = arctan(y/x).                          */
/*                                                            */
/* What this routine does is calculating positions on the     */
/* ellipse with current parameters, so that they are equi-    */
/* distant along the arc with distance 'arclen'. However the  */
/* distance 'arclen' is adjusted so that the end points of    */
/* both semi major and minor axes are include in the sample.  */
/* For small smaple distances it usually means a small change */
/* in sample distance.                                        */
/*                                                            */
/* The elliptic                                               */
/* integral can only be solved numerically. This means that   */
/* we need a root solving method to find the next sample      */
/* position (bisection is used for this). Sampling starts in  */
/* an unrotated ellipse at the minor axis position x = 0 and  */
/* y = minor axis length. Each sampling position is copied    */
/* to the other quadrants.                                    */
/*                                                            */
/* Current maximum number of sample points in one quadrant is */
/* 1000.                                                      */
/*------------------------------------------------------------*/
#define MAXSAM   1000   
{
   double   xstart, xend;
   double   CosP, SinP;
   double   k;
   double   peri;
   double   h;
   double   dist = 0.0;
   int      n;
   int      nseg;
   int      nearmaj = NO;
   static   int    first = YES;
   static   double majO, minO;       /* Store lengths of major and minor axes */
   static   double arclenO;                   /* Store sample distance on arc */
   static   double xu[MAXSAM];              /* Unrotated quadrant sample points */
   static   double yu[MAXSAM]; 
   static   int    nO;
   int      changed;
   int      i, j;
   int      ndat;
   double   startrad, endrad;


   if (maj < min)
   {
      double  s = maj;
      angle += 90.0;
      maj = min;
      min = s;
   }
    
   /*--------------------------------------------------*/
   /* Adjust the current sampling distance along the   */
   /* curve, so that both minor and major axis ends    */
   /* are included in the sample. For this we need a   */
   /* good approximation of the perimeter in 1         */
   /* quadrant.                                        */
   /* For the perimeter we use the approximation by    */
   /* Ramanujan. See also:                             */
   /* mathworld.wolfram.com resource library/ellipse.  */
   /*--------------------------------------------------*/ 
   h = (maj-min)/(maj+min);
   h *= h;
   peri = (PI/4.0) * (maj+min) * (1.0 + (3.0*h/(10.0+sqrt(4.0-3.0*h)) ));
   
   /*--------------------------------------------------*/ 
   /* Calculate the number of segments and add one     */
   /* segment to get a smaller new arc length.         */
   /* Recalculate the arc length for a better fit so   */
   /* that both minor and major axis ends are included.*/
   /*--------------------------------------------------*/ 
   nseg = (int) (peri/arclen) + 1;           
   arclen = peri / (double) (nseg);          /* New arclen fits better */ 


   if (first)
   {
      arclenO = arclen;
   }
   
   if (first)
      changed = YES;
   else
      changed = (arclen != arclenO || maj != majO || min != minO);

   if (changed)
   {
      xstart = 0.0;
      dist = 0.0;
      k = sqrt(1.0 - (min*min)/(maj*maj));     /* Eccentricity is a parameter */
      xu[0] = 0.0;                             /* Store first point */
      yu[0] = min;
      n = 1;
      do
      {
         xend = newX( xstart, arclen, maj, k );   /* Next point 'arclen' away */
         dist += arclen;         
         if (ABS(peri-dist) < arclen/2.0)
         {
            /* Must be near the major axis */
            nearmaj = YES;
            xend = maj;
         } 
         else if (xend == dblank)
         {
            break;
         }
         xu[n] = xend;
         yu[n] = min * sqrt( ABS(1.0 - (xend*xend)/(maj*maj)) );  /* Ellipse formula */
         n++;
         xstart = xend;         
      }
      while (xend <= maj && n < MAXSAM); 
      nO = n;
   }      
  
   /* Help variables for the rotation */
   CosP = cos( RAD(angle) );
   SinP = sin( RAD(angle) );
  
   
   /* Assemble the points in the other quadrants */
   j = 0;
   
   /* from major to minor: */
   for (i = nO-1; i >= 0; i--)
   {
      double x =  xu[i];
      double y =  yu[i]; 
      if (j < Nmax)
      {
         xsam[j]  = x;
         ysam[j]  = y;
         j++;
      }
   }
   
   /* from minor to -major */
   for (i = 1; i < nO; i++)
   {
      double x = -xu[i];
      double y =  yu[i];
      if (j < Nmax)
      {
         xsam[j]  = x;
         ysam[j]  = y;
         j++;
      }
   }
   
   /* from -major to -minor */
   for (i = nO-2; i >= 0; i--)
   {
      double x = -xu[i];
      double y = -yu[i];
      if (j < Nmax)
      {
         xsam[j]  = x;
         ysam[j]  = y;
         j++;
      }
   }

   /* from -minor to major */
   for (i = 1; i < nO - 1; i++)
   {
      double x =  xu[i];
      double y = -yu[i];
      if (j < Nmax)
      {
         xsam[j]  = x;
         ysam[j]  = y;
         j++;
      }
   }
 
   startrad = RAD( start );
   endrad = RAD( end );   
   ndat = 0;   
   for (i = 0; i < j; i++)
   {
      double x = xsam[i];
      double y = ysam[i];      
      double curangle = atan2(y, x);
      int    inside; 
     
      if (curangle < 0.0)
         curangle = 2*PI + curangle;
      if (startrad <= endrad)
         inside = (curangle >= startrad && curangle <= endrad);
      else
         inside = (curangle <= endrad || curangle >= startrad);
      if (inside)
      {
         xsam[ndat]  = x * CosP - y * SinP + x0;
         ysam[ndat]  = x * SinP + y * CosP + y0;
         ndat++;
      }
   }

   majO = maj; minO = min; arclenO = arclen;
   first = NO;   
   return( ndat );    
} 
#undef MAXSAM

#<

#>            spline.c
/* spline.c
                           COPYRIGHT (c) 2000
                      Kapteyn Astronomical Institute
                University of Groningen, The Netherlands
                           All Rights Reserved.
*/

#include    "sliceview.h"
#include    "utils.h"
#include    "spline1.h"
#include    "matrix.h"


static fint invmat( float **matrix2, int nfree )
/*
 * invmat calculates the inverse of matrix2. The algorithm used is the
 * Gauss-Jordan algorithm described in Stoer, Numerische matematik, 1 Teil.
 */
{
   double even;
   double hv[MAXPAR];
   double mjk;
   double rowmax;
   fint   evin;
   fint   i;
   fint   j;
   fint   k;
   fint   per[MAXPAR];
   fint   row;

   for (i = 0; i < nfree; i++) per[i] = i;	/* set permutation array */
   for (j = 0; j < nfree; j++) {		/* in j-th column, ... */
      rowmax = fabs( matrix2[j][j] );		/* determine row with ... */
      row = j;					/* largest element. */
      for (i = j + 1; i < nfree; i++) {
         if (fabs( matrix2[i][j] ) > rowmax) {
            rowmax = fabs( matrix2[i][j] );
            row = i;
         }
      }
      if (matrix2[row][j] == 0.0) return( -6 );	/* determinant is zero! */
      if (row > j) {				/* if largest element not ... */
         for (k = 0; k < nfree; k++) {		/* on diagonal, then ... */
            even = matrix2[j][k];		/* permutate rows. */
            matrix2[j][k] = matrix2[row][k];
            matrix2[row][k] = even;
         }
         evin = per[j];				/* keep track of permutation */
         per[j] = per[row];
         per[row] = evin;
      }
      even = 1.0 / matrix2[j][j];		/* modify column */
      for (i = 0; i < nfree; i++) matrix2[i][j] *= even;
      matrix2[j][j] = even;
      for (k = 0; k < j; k++) {
         mjk = matrix2[j][k];
         for (i = 0; i < j; i++) matrix2[i][k] -= matrix2[i][j] * mjk;
         for (i = j + 1; i < nfree; i++) matrix2[i][k] -= matrix2[i][j] * mjk;
         matrix2[j][k] = -even * mjk;
      }
      for (k = j + 1; k < nfree; k++) {
         mjk = matrix2[j][k];
         for (i = 0; i < j; i++) matrix2[i][k] -= matrix2[i][j] * mjk;
         for (i = j + 1; i < nfree; i++) matrix2[i][k] -= matrix2[i][j] * mjk;
         matrix2[j][k] = -even * mjk;
      }
   }
   for (i = 0; i < nfree; i++) {		/* finally, repermute the ... */
      for (k = 0; k < nfree; k++) {		/* columns. */
         hv[per[k]] = matrix2[i][k];
      }
      for (k = 0; k < nfree; k++) {
         matrix2[i][k] = hv[k];
      }
   }
   return( 0 );					/* all is well */
}





void cubicspline( float  *Xus,
                  float  *Yus,
                  int    np,           /* Number of controls */
                  float  sampdist,
                  float  **XusO,       /* Unscaled output */
                  float  **YusO,
                  int    *nout,
                  fint   *blo,
                  fint   *bhi,
                  float  *splineleningrids )
/*------------------------------------------------------------------*/
/* PURPOSE: Cubic spline through X and Y.                           */
/* Piecewise cubic spline trough 'np' two dimensional positions     */
/* stored in arrays 'X' and 'Y', using 'cord' approximation.        */
/* See 'Mathematical Elements for Computer Graphics', 2nd ed.       */
/* David F. Rogers, J. Alan Adams. p. 262.                          */
/*------------------------------------------------------------------*/
{
   float    **matrix;
   int      row, col;
   float    *t;
   float    *Vx;               /* matrix.P' = Vxy */
   float    *Vy;
   float    *VRx;              /* P' = matrix^-1.VRxy */
   float    *VRy;
   int      i;
   int      seg;
   int      nO = 0;
   float    xlo = blo[0];
   float    ylo = blo[1];
   float    xhi = bhi[0];
   float    yhi = bhi[1];
   float    *X, *Y;
   float    *XO = NULL, *YO = NULL;
   float    m;                 /* Slope for scaling */
   float    disttot = 0.0;     /* Total distance along spline in scaled frame */
   float    xold, yold;        /* Used to calculate distance to previous position */   
   float    scaledsampdist;


   if (np == 0 || np == 1)
      return;

   matrix = fmatrix( 0, 0, np-1, np-1 );
   Vx  = (float *) calloc( np, sizeof(float) );
   Vy  = (float *) calloc( np, sizeof(float) );
   VRx = (float *) calloc( np, sizeof(float) );
   VRy = (float *) calloc( np, sizeof(float) );
   t   = (float *) calloc( np, sizeof(float) );
   X   = (float *) calloc( np, sizeof(float) );
   Y   = (float *) calloc( np, sizeof(float) );
   
   if (*XusO != NULL)
      free( *XusO );
   if (*YusO != NULL)
      free( *YusO );

   XO  = (float *) calloc( 1, sizeof(float) );     
   YO  = (float *) calloc( 1, sizeof(float) );   

   if (matrix == NULL || Vx == NULL || Vy == NULL ||
       VRx == NULL || VRy == NULL || t == NULL || X == NULL || Y == NULL ||
       XO == NULL || YO == NULL )
   {
      anyoutf( 1, "Cannot allocate memory for cubic spline routine!" );
      return;
   }

   /* Scale the positions to numbers between 0 and 1, otherwise you could */
   /* run into problems with calculating splines */
   
   m = 1.0 / MYMAX( (xhi-xlo),(yhi-ylo) );
   for (i = 0; i < np; i++)
   {
      /* Do not alter the array with unscaled positions */
      X[i] = m*(Xus[i]-xlo);
      Y[i] = m*(Yus[i]-ylo);
   }
   scaledsampdist = sampdist * m;

   t[0] = 0.0;
   for (i = 1; i < np; i++)
   {
      t[i] = sqrt( (X[i]-X[i-1])*(X[i]-X[i-1])+(Y[i]-Y[i-1])*(Y[i]-Y[i-1]) );
   }

   /* Initialize matrix */
   for (row = 0; row < np; row++)
   {
      for (col = 0; col < np; col++)
      {
         matrix[row][col] = 0.0;
      }
   }
   matrix[0][0] = matrix[np-1][np-1] = 1.0;

   for (row = 1; row < np-1; row++)
   {
      col = row - 1;
      matrix[row][col]   = t[row+1];
      matrix[row][col+1] = 2.0*( t[row] + t[row+1] );
      matrix[row][col+2] = t[row];
   }
   /* Now get P' = matrix^-1.VRxy */
   invmat( matrix, np );

   /*--------------------------------------------------*/
   /* Tangent vectors at the end points are set equal  */
   /* to the slope of the connecting lines of the      */
   /* first two and last two points.                   */
   /*--------------------------------------------------*/
   Vx[0] = X[1]-X[0];
   Vy[0] = Y[1]-Y[0];
   /* Is contour closed? */
   if (X[np-1] == X[0] && Y[np-1] ==Y[0])
   {
      Vx[np-1] = X[1] - X[np-2];
      Vy[np-1] = Y[1] - Y[np-2];
      Vx[0] = Vx[np-1];
      Vy[0] = Vy[np-1];      
   }
   else
   {
      Vx[np-1] = X[np-1] - X[np-2];
      Vy[np-1] = Y[np-1] - Y[np-2];
   }

   for (row = 1; row < np -1; row++)
   {
      Vx[row] = (3.0/(t[row]*t[row+1])) *
                (
                ( t[row]*t[row]    *(X[row+1]-X[row]) )
                +
                ( t[row+1]*t[row+1]*(X[row]-X[row-1]) )
                );
      Vy[row] = (3.0/(t[row]*t[row+1])) *
                (
                ( t[row]*t[row]    *(Y[row+1]-Y[row]) )
                +
                ( t[row+1]*t[row+1]*(Y[row]-Y[row-1]) )
                );
   }

   for (row = 0; row < np; row++)
   {
      VRx[row] = 0.0;
      VRy[row] = 0.0;
      for (i = 0; i < np; i++)
      {
         VRx[row] += matrix[row][i]*Vx[i];
         VRy[row] += matrix[row][i]*Vy[i];
      }
   }

   /*--------------------------------------------------*/
   /* For each segment, take a sufficient number of    */
   /* values for tau. If a calculated spline point x,y */
   /* has a cord distance n*sample distance, than      */
   /* store this point as a sample point. This way you */
   /* will not include the spline controls as sample   */
   /* points, but the sample distance is constant.     */
   /* The alternative method includes the controls but */
   /* has not an exact equidistant sampling.           */
   /*--------------------------------------------------*/

   /* First control point is always included in the sample */
   XO[0] = X[0]; YO[0] = Y[0];
   xold = X[0]; yold = Y[0];   
   /* And make space for the next one */
   nO++;
   XO = (float *) realloc( (float *) XO,  (nO+1)*sizeof(float) );
   YO = (float *) realloc( (float *) YO,  (nO+1)*sizeof(float) ); 
   
   /* Number of segments is one less than the number of spline controls */
   for (seg = 0; seg < np-1; seg++)
   {
      float   nt;
      float   nta;
      float   Lseg = sqrt( (X[seg+1]-X[seg])*(X[seg+1]-X[seg]) + 
                           (Y[seg+1]-Y[seg])*(Y[seg+1]-Y[seg]) );
      /*-----------------------------------*/
      /* Divide segment in small parts.    */
      /* The number is a function of the   */
      /* cord length (approximated by the  */
      /* linear distance) and the sampling */
      /* distance. The sampling is refined */
      /* by a constant.                    */
      /*-----------------------------------*/ 
      nta = (float) ( (int) (50.0*Lseg/scaledsampdist) );

      for (nt = 1.0; nt < nta; nt += 1.0)
      {
         float F[4];
         float ta = nt/nta;
         float ta2 = ta * ta;
         float ta3 = ta2 * ta;
         float x, y;
         float D;

         F[0] = 2.0*ta3 - 3.0*ta2 + 1.0;
         F[1] = 1.0 - F[0];
         F[2] = ta*(ta2-2.0*ta+1.0) * t[seg+1];
         F[3] = ta*(ta2-ta) * t[seg+1];

         x = F[0] * X[seg] + F[1]*X[seg+1] + F[2]*VRx[seg] + F[3]*VRx[seg+1];
         y = F[0] * Y[seg] + F[1]*Y[seg+1] + F[2]*VRy[seg] + F[3]*VRy[seg+1];

         D = sqrt( (x-xold)*(x-xold)+(y-yold)*(y-yold) );         
         disttot += D;
         xold = x;
         yold = y;
         /*----------------------------------------*/
         /* Is this calculated position on the     */
         /* spline suitable to be stored as a      */
         /* sample point?                          */
         /*----------------------------------------*/
         if (disttot >= (nO)*scaledsampdist && D < (nO+1)*scaledsampdist)
         {
            XO[nO] = x;
            YO[nO] = y;
            nO++;
            XO = (float *) realloc( (float *) XO,  (nO+1)*sizeof(float) );
            YO = (float *) realloc( (float *) YO,  (nO+1)*sizeof(float) );
         }
      }
   }
            
   /* Rescale total distance to original frame and store */
   *splineleningrids = disttot / m;    
   
   /* Scale box to original coordinates */
   for (i = 0; i < nO; i++)
   {
      XO[i] = xlo + XO[i]/m;
      YO[i] = ylo + YO[i]/m;
#if(0)      
      if (i == 0)
      {
         anyoutf( 1, "Spline sample %d = (%g %g) at  D= 0", i, XO[i] , YO[i] );
      }
      else
      {
         anyoutf( 1, "Spline sample %d = (%g %g) at  D= %g", i, XO[i] , YO[i],
                  sqrt( (XO[i]-XO[i-1])*(XO[i]-XO[i-1])+
                        (YO[i]-YO[i-1])*(YO[i]-YO[i-1]) )  );
      }
#endif      
   }
   
   *nout = nO;
   *XusO = &XO[0];
   *YusO = &YO[0];
  
   free( Y );
   free( X );
   free( t );
   free( VRy );
   free( VRx );
   free( Vy );
   free( Vx );
   freefmatrix( matrix, 0, 0 );
}



int splineinsert( float x,
                  float y,
                  splineslice *spline )
/*------------------------------------------------------------------*/
/* PURPOSE: Insert x,y in spline array at nearest point in array.   */
/*------------------------------------------------------------------*/
{
   float   D, D1, D2, Dmin = 0.0;
   int     i, j;
   int     indxmin = -1;
   int     n = spline->ndat;
   float   dumX[MAXPAR], dumY[MAXPAR];


   for (i = 0; i < n-1; i++)
   {
      float dx = spline->Xpos[i] - x;
      float dy = spline->Ypos[i] - y;
      D1 = sqrt( dx*dx + dy*dy );
      /* Calculate distance to next point and add to previous */
      dx = spline->Xpos[i+1] - x;
      dy = spline->Ypos[i+1] - y;
      D2 = sqrt( dx*dx + dy*dy );
      if (D1 == 0.0 || D2 == 0.0)
      {
         /* Two points coincide, nothing to insert! */
         return( n );
      }
      D = D1 + D2;
      if (i == 0)
      {
         Dmin = D;
         indxmin = i;
      }
      else
      {
         if (D < Dmin)
         {
            Dmin = D;
            indxmin = i;
         }
      }
   }
   
   /* Insert this point */
   for (j = 0, i = 0; i < n; i++)
   {
      if (j < MAXPAR)
      {
         dumX[j] = spline->Xpos[i];
         dumY[j] = spline->Ypos[i];
         j++;
         if (i == indxmin)
         {
            dumX[j] = x;
            dumY[j] = y;
            j++;
         }
      }
   }
   n++;                                                 /* One point is added */

   /* Copy back to original array */
   for (i = 0; i < n; i++)
   {
      spline->Xpos[i] = dumX[i];
      spline->Ypos[i] = dumY[i];
   }

   return( n );
}



int splinedelete( float x,
                  float y,
                  splineslice *spline )
/*------------------------------------------------------------------*/
/* PURPOSE: Delete nearest x,y in spline array.                     */
/*          Mouse positions further away than 10 pixels from the    */
/*          nearest spline control point, are omitted.              */ 
/*------------------------------------------------------------------*/
{
   float D, Dmin, Dmax = 10;
   float blank;
   int   i, j;
   int   indxmin = -1;
   int   n = spline->ndat;


   setfblank_c( &blank );
   Dmin = blank;

   for (i = 0; i < n; i++)
   {
      float dx = spline->Xpos[i] - x;
      float dy = spline->Ypos[i] - y;
      D = sqrt( dx*dx + dy*dy );
      if (D < Dmax)
      {
         if (Dmin == blank)
         {
            Dmin = D;
            indxmin = i;
         }
         else
         {
            if (D < Dmin)
            {
               Dmin = D;
               indxmin = i;
            }
         }
      }
   }

   /* Copy all except the deleted point with index 'indxmin' */
   for (i = 0, j = 0; i < n; i++)
   {
      if (indxmin != i)
      {
         spline->Xpos[j] = spline->Xpos[i];                           /* Copy */
         spline->Ypos[j] = spline->Ypos[i];
         j++;
      }
   }
   n = j;

   return( n );
}



int splinenearestpoint( float x,
                        float y,
                        splineslice *spline )
/*------------------------------------------------------------------*/
/* PURPOSE: Find nearest point on spline with respect to the mouse  */
/*          position x, y. Include all spline points in search.     */
/*          Mouse positions further away than 10 pixels from the    */
/*          nearest spline control point, are omitted.              */ 
/*------------------------------------------------------------------*/
{
   float D, Dmin, Dmax = 10;
   float blank;
   int   i;
   int   indxmin = -1;
   int   n = spline->ndatO;


   setfblank_c( &blank );
   Dmin = blank;

   for (i = 0; i < n; i++)
   {
      float dx = spline->XposO[i] - x;
      float dy = spline->YposO[i] - y;
      D = sqrt( dx*dx + dy*dy );
      if (D < Dmax)
      {
         if (Dmin == blank)
         {
            Dmin = D;
            indxmin = i;
         }
         else
         {
            if (D < Dmin)
            {
               Dmin = D;
               indxmin = i;
            }
         }
      }
   }
   /* The index is either a value between 0..n-1 or -1 if there is not */
   /* a nearest position (i.e. mouse too far away (10 grids) from all  */
   /* spline (control+calculated) points.                              */

   return( indxmin );
}

#<

#>            splinepop.c
/* spline.c
                              COPYRIGHT (c) 2000
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "Spline slice parameters"
#define SELKEY "_GUI_SPLINE="
#define SELINX SLICE_SPLINE
#define MARGIN 115

#include "stddef.h"
#include "stdio.h"
#include "gipsyc.h"
#include "userfio.h"
#include "wkey.h"
#include "ggi.h"
#include "gui.h"
#include "splinepop.h"

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}

static ident s_spline;                  /* spline keywords shell     */
static ident i_box;
static  bool state=FALSE;

/* -------------------------------------------------------------------------- */
/*                                 xslice                                     */
/* -------------------------------------------------------------------------- */
static void xslice(ident id, char *key, int code, void *arg)
{
   fint choice=-1;
    
   (void)userfint(&choice, 1, 2, key, " ");
   wkeyf("%s%s", SELKEY, choice==SELINX?"YES":"NO");
}

/* -------------------------------------------------------------------------- */
/*                                 selself                                    */
/* -------------------------------------------------------------------------- */
static void selself(ident id, char *key, int code, void *arg)   
{
   bool button=toflog(FALSE);
   
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      (void)SuppressKeyevent(xslice, "SLICE=");
      wkeyf("SLICE=%d", SELINX);
      GgiActivate(i_box);
   } else {
      GgiDeactivate(i_box);
   }
}
   
/* -------------------------------------------------------------------------- */
/*                                 readfile                                   */
/* -------------------------------------------------------------------------- */
static void readfile(ident id, char *key, int code, void *arg)
{
   bool button=toflog(FALSE);
   ident browser;
   
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      wkeyf(key);
      browser = GgiFileBrowser(ggiIdent, "SPLINEIN=");
      if (browser) {
         (void)GgiFileBrowser(ggiDelete, browser);
      } else {
         browser = GgiFileBrowser(ggiCreate, "SPLINEIN=",
                      "Spline points input file", NULL);
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 savefile                                   */
/* -------------------------------------------------------------------------- */
static void savefile(ident id, char *key, int code, void *arg)
{
   bool button=toflog(FALSE);
   
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      wkeyf(key);
      GgiPrompter("SPLINEOUT=", "File to save spline points");
   }
}

/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut, selbut;
   ident sam_t, lig_b, read_b, save_b, clr_b;

   s_spline = GgiShell(NAME);
   (void)GgiUseShell(s_spline);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   selbut   = GgiSetLabel(GgiButton(SELKEY, "Select window"), "SELECT", 0);
   (void)ScheduleKeyevent(selself, SELKEY, KEYCHANGE, NULL);
   i_box = GgiForm(NAME, 1);
   GgiSetPosition(i_box,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, i_box);
   GgiSetPosition(selbut,   -GgiWidth(selbut)-4, i_box, 0, i_box);

   (void)GgiUseShell(i_box);
   sam_t = GgiSetLabel(GgiTextField("S_SAMP=", NULL, 10),
                        "Sample separation", MARGIN);
                        
   lig_b = GgiSetLabel(GgiButton("LINEGRAPH=", "Line graphs on/off"),"GRAPH",0);
   read_b = GgiSetLabel(GgiButton("_RSPL=", "Read points from file"), "READ",0);
   (void)ScheduleKeyevent(readfile, "_RSPL=", KEYCHANGE, NULL);
   save_b = GgiSetLabel(GgiButton("_WSPL=", "Save points to file"), "SAVE",0);
   (void)ScheduleKeyevent(savefile, "_WSPL=", KEYCHANGE, NULL);
   clr_b = GgiSetLabel(GgiButton("SPLINECLEAR=", "Delete points"), "CLEAR",0);

   GgiSetPosition(sam_t,   0, NULL,   0, NULL);
   GgiSetPosition(lig_b,   0, NULL,   0, sam_t);
   GgiSetPosition(read_b,  0, lig_b,  0, sam_t);
   GgiSetPosition(save_b,  0, read_b, 0, sam_t);
   GgiSetPosition(clr_b,   0, save_b, 0, sam_t);
   
   (void)GgiUseShell(NULL);
   (void)ScheduleKeyevent(xslice, "SLICE=", KEYCHANGE, NULL);
}

/* -------------------------------------------------------------------------- */
/*                                 spline                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void spline(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_spline, !state);
      state = !state;
      wkey_c(tofchar(key));
   }
}

/* ========================================================================== */
/*                                 Splinepop                                  */
/* -------------------------------------------------------------------------- */
/*  Splinepop() creates a pop-up shell for spline keywords. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern void Splinepop(char *key)
{
   if (key) {
      initialize(key);
      ScheduleKeyevent(spline, key, KEYCHANGE, NULL);
   } else {
      state = TRUE;
      GgiShowShell(s_spline, state);
   }
}
#<

#>            frames.c
/* frames.c
                           COPYRIGHT (c) 2000-2004
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands

Author: J.P. Terlouw
*/

#define NAME      "Special frames"
#define EBW       30           /* width of extra frame button */

#include "gipsyc.h"
#include "stddef.h"
#include "stdio.h"
#include "string.h"
#include "math.h"
#include "userfio.h"
#include "ggi.h"
#include "radiogroup.h"
#include "guipar.h"
#include "gui.h"
#include "helptext.h"
#include "frames.h"

typedef struct {
   ident form, showbut;
   ident label;
   int   frame;
} _ExtraFrame, *ExtraFrame;

static ident s_load;
static ident s_prev, e_lab, e_box;
static ident frame_t, frame_g, speed_t, speed_g;
static ident back_b, forw_b, bafo_b, stop_b, stepb, stepf, last2_b;
static ident closebut;
static _ExtraFrame eframes[EXTRAFRAMES];

static char *menulabels[]={"0th moment", 
                           "1st moment",
                           "2nd moment",
                           "External set",
                           "DSS FITS file", NULL};
typedef enum {MOMENT0, MOMENT1, MOMENT2, EXTSET, DSSFITS} choices;


static int   nframes=13, mframes=10;          /* total frames, movie frames */
static ident plotter;
static ident controls;
static int   interval;
static int   expect=0;
static int   frame=-1, prev_frame, curr_frame;
static int   increment=1;
static fint  extra=-1;
static bool  hew=FALSE;                       /* back-and-forth */
static bool  framepending=FALSE;
static bool  stopping=FALSE;
static bool  playing=FALSE;
static bool  last2=FALSE;                     /* limit to last two frames */
static bool  recording=FALSE;                 /* MPEG recording flag */
static bool  dontshow=FALSE;
static FrameProc frameproc=NULL;

/* -------------------------------------------------------------------------- */
/*                                 set_bool                                   */
/* -------------------------------------------------------------------------- */
/*  set_bool() sets the boolean variable associated with a keyword.
 */
static void set_bool(ident id, char *key, int code, void *arg)
{
   bool value=toflog(FALSE);
   
   (void)userflog(&value, 1, 2, key, " ");
   *(bool*)arg = tobool(value);
}

/* -------------------------------------------------------------------------- */
/*                                 nextframe                                  */
/* -------------------------------------------------------------------------- */
/*  nextframe() increments frame according to the current settings
 *  - called by player()
 */
static void nextframe(void)
{
   if (last2) {
      frame = prev_frame;
   } else {
      frame += increment;
      if (hew) {
         if (frame<0) {
            frame = 1;
            increment = 1;
         } else if (frame>mframes-1) {
            frame = mframes-2;
            increment = -1;
         }
      } else {
         frame = (frame+mframes)%(mframes);
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 clear_extra                                */
/* -------------------------------------------------------------------------- */
/*  Clear "extra-status"; revert to movie mode.
 */
static void clear_extra(void)
{
   if (extra>=0) wkeyf("EFRAME%d=", extra);
}

/* -------------------------------------------------------------------------- */
/*                                 handle_menu                                */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for the extra frames "TYPE" menu. It only reacts to the
 *  external set and DSS FITS choices; other choices are handled in the
 *  main application.
 */
static void handle_menu(ident id, char *key, int code, void *arg)
{
   int frameno=(int)arg;
   
   fint choice=-1;
   ident composer, browser;
   char set[KEYLEN], name[KEYLEN], dss[KEYLEN], message[80];
    
   (void)userfint(&choice, 1, 2, key, " ");
   if (choice==EXTSET) {
      sprintf(name, "EXTNAME%d=", frameno);
      composer = GgiInset(ggiIdent, name);
      if (!composer) {
         sprintf(message, "Map to be loaded in special frame %d", frameno+1);
         sprintf(set, "EXTSET%d=", frameno);
         composer = GgiInset(ggiCreate, name, set, NULL, message);
         (void)GgiInset(ggiNdims, composer, 2);
         (void)GgiInset(ggiCloseOnOK, composer);
      }
      TriggerKey(name);
   } else if (choice==DSSFITS) {
      sprintf(dss, "EXTDSS%d=", frameno);
      browser = GgiFileBrowser(ggiIdent, dss);
      if (!browser) {
         sprintf(message, "DSS FITS file to be loaded in special frame %d",
                 frameno+1);
         browser = GgiFileBrowser(ggiCreate, dss, message, NULL);
         (void)GgiFileBrowser(ggiCloseOnOK, browser);
      }
   }
}
/* -------------------------------------------------------------------------- */
/*                                 loadproc                                   */
/* -------------------------------------------------------------------------- */
/*  handle "LOAD" keyword for special frame. When the application has
 *  loaded the frame, i.e. when "key" becomes "NO" again, it updates
 *  FRAME= and, if necessary EFRAMEn=.
 */
static void loadproc(ident id, char *key, int code, void *arg)
{
   bool button=toflog(FALSE);

   (void)userflog(&button, 1, 2, key, " ");
   if (!tobool(button)) {
      int frameno=(int)arg;
      bool thisframe=toflog(FALSE);
      char framekey[KEYLEN];
      wkeyf("FRAME=%d", eframes[frameno].frame);
      sprintf(framekey, "EFRAME%d=", frameno);
      (void)userflog(&thisframe, 1, 2, framekey, " ");
      if (!tobool(thisframe)) {
         wkeyf("%sYES", framekey);
      }
      GgiActivate(controls);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 extra_frame                                */
/* -------------------------------------------------------------------------- */
/*  extra_frame creates a form with "extra frame"-controls.
 */
static ident extra_frame(int frameno)
{
   ident form, prev, label, tag, typemenu, cliptext, loadbut;
   char  keybuf[KEYLEN];
    
   form = GgiForm(NAME, 1);
   prev = GgiUseShell(form);
   
   sprintf(keybuf, "%d:", frameno+1);
   tag  = GgiLabel(keybuf);
   label = GgiLabel(" ");
   sprintf(keybuf, "EXTTYPE%d=", frameno);
   typemenu = GgiSetLabel(GgiMenu(keybuf, NULL, menulabels), "TYPE", 0);
   (void)ScheduleKeyevent(handle_menu, keybuf, KEYCHANGE, (void*)frameno);
   sprintf(keybuf, "EXTCLIP%d=", frameno);
   cliptext = GgiSetLabel(GgiTextField(keybuf, H_EXT_CLIP, 15), "Clip:", 0);
   sprintf(keybuf, "EXTLOAD%d=", frameno);
   loadbut = GgiSetLabel(GgiButton(keybuf, H_EXT_LOAD), "LOAD", 0);
   (void)ScheduleKeyevent(loadproc, keybuf, KEYCHANGE, (void*)frameno);
    
   GgiSetPosition(tag,      0, NULL,     0, NULL);
   GgiSetPosition(label,    0, tag,      0, NULL);
   GgiSetPosition(typemenu, 0, NULL,     0, tag);
   GgiSetPosition(cliptext, 0, typemenu, 0, tag);
   GgiSetPosition(loadbut,  0, cliptext, 0, tag);
   (void)GgiUseShell(prev);
   
   eframes[frameno].form  = form;
   eframes[frameno].label = label;

   GgiDeactivate(form);   
   return form;
}

/* -------------------------------------------------------------------------- */
/*                                 stepper                                    */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for stepping backward or forward.
 */
static void stepper(ident id, char *key, int code, void *arg)
{
   int direction=(int)arg;
   int curframe=frame; 
   bool button=toflog(FALSE);
   
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      if (last2) {
         curframe = prev_frame;
      } else {
         curframe += direction;
         curframe = curframe<0?0:(curframe<mframes?curframe:mframes-1);
      }
      if (curframe<mframes) {
         clear_extra();
         wkeyf("FRAME=%d", curframe);
      } else {
         wkeyf("EFRAME%d=YES", curframe-eframes[0].frame);
      }
      wkeyf(key);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 popshell                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void popshell(ident id, char *key, int code, void *arg)
{  
   static bool state=FALSE;
   bool button=toflog(FALSE);
 
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell((ident)arg, !state);
      state = !state;
      wkeyf(key);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 stopmovie                                  */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the movie to stop.
 */
static void stopmovie(ident id, char *key, int code, void *arg)
{
   bool button=toflog(FALSE);
   
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      wkeyf("BACK= BAFO= FORW=");
      wkeyf(key);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 realspeed                                  */
/* -------------------------------------------------------------------------- */
/*  Keyword handler converting logarithmic to real speed.
 */
static void realspeed(ident id, char *key, int code, void *arg)
{
   float speed;
    
   if (!expect) {
      expect++;
      (void)userfreal(&speed, 1, 2, key, " ");
      wkeyf("%s%.1f", (char*)arg, exp(speed));
      interval = (float)(1 SECOND)/exp(speed);
   } else expect--;
}

/* -------------------------------------------------------------------------- */
/*                                 logspeed                                   */
/* -------------------------------------------------------------------------- */
/*  Keyword handler converting real to logarithmic speed and updating
 *  the frame interval.
 */
static void logspeed(ident id, char *key, int code, void *arg)
{
   float speed;
    
   if (!expect) {
      (void)userfreal(&speed, 1, 2, key, " ");
      if (speed>0.5) {
         wkeyf("%s%.1f", (char*)arg, log(speed));
         expect++;
         interval = (float)(1 SECOND)/speed;
      }
   } else expect--;
}

/* -------------------------------------------------------------------------- */
/*                                 showframe                                  */
/* -------------------------------------------------------------------------- */
/*  Keyword handler displaying specified frame.
 */
static void showframe(ident id, char *key, int code, void *arg)
{
   fint f;

   framepending = FALSE;
   (void)userfint(&f, 1, 2, key, " ");
   frame = f;
   if (frame>=0 && frame<nframes) {
      if (frame != curr_frame) {
         prev_frame = curr_frame;
         curr_frame = frame;
      }
      if (dontshow) dontshow = FALSE;
      else GgiPlotShow(plotter, frame);
      if (!playing && frameproc) frameproc();    /* notify "interested party" */
      if (recording) {
         if (GgiMpeg(plotter, ggiNext)) {
            recording = FALSE;
            wkeyf("REC=");
         }
      }
      if (frame<mframes) clear_extra();    /* clear "extra" if in movie range */
   }
}

/* -------------------------------------------------------------------------- */
/*                                 player                                     */
/* -------------------------------------------------------------------------- */
/*  Timer handler playing the movie.
 */
static void player(ident id, void *arg)
{
   ident *timer=(ident *)arg;
   static int prvint=-1;
    
   if (!framepending && !stopping) { /* only if previous frame has been shown */
      nextframe();
      wkeyf("FRAME=%d", frame);
      framepending = TRUE;
   }
   if (interval != prvint) {
      prvint = interval;
      Deschedule(timer);
      *timer = ScheduleTimer(player, interval, timer);
   }
}


/* -------------------------------------------------------------------------- */
/*                                 playmovie                                  */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for starting and stopping the movie.
 */
static void playmovie(ident id, char *key, int code, void *arg)
{
   bool button=toflog(FALSE);
   static ident timer;
    
   stopping = FALSE;
   (void)userflog(&button, 1, 2, key, " ");
   button = tobool(button);
   if (button && !timer) {
      timer = ScheduleTimer(player, interval, &timer);
      playing = TRUE;
   } else if (timer && !button) {
      Deschedule(&timer);
      playing = FALSE;
      if (frame<mframes) {
         if (frameproc) frameproc();
      } else {
         wkeyf("EFRAME%d=YES", frame-eframes[0].frame);
      }
   }
   gui_colupd(!playing);    /* no limits update in color wedge while playing */
}

/* -------------------------------------------------------------------------- */
/*                                 momode                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler for setting movie direction and  back-and-forward mode.
 */
static void momode(ident id, char *key, int code, void *arg)
{
   bool button=toflog(FALSE);
   static char playing[KEYLEN]="";

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      clear_extra();
      if (!strcmp(key,"BACK=")) {
         hew = FALSE;
         increment = -1;
         wkeyf("BAFO= FORW=");
      } else if (!strcmp(key,"BAFO=")) {
         hew = TRUE;
         wkeyf("BACK= FORW=");
      } else {
         hew = FALSE;
         increment =  1;
         wkeyf("BACK= BAFO=");
      }
      if (!playing[0]) {
         wkeyf("PLAY=YES");
      }
      strcpy(playing,key);
   } else {
      if (!strcmp(key,playing)) {
         wkeyf("PLAY=NO");
         strcpy(playing,"");
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_extra                               */
/* -------------------------------------------------------------------------- */
/*  Keyword handler responsible for the "extra frames".
 */
static void handle_extra(ident id, char *key, int code, void *arg)
{
   fint current;
   static fint frame=-1;
   
   extra = -1;
   if (userfint(&extra, 1, 2, key, " ")==1) {
      (void)userfint(&current, 1, 2, "FRAME=", " "); /* get current frame */
      if (current<mframes) frame = current;
      stopping = TRUE;
      wkeyf("BACK= BAFO= FORW= FRAME=%d", eframes[extra].frame);
   } else if (!last2) {
      (void)userfint(&current, 1, 2, "FRAME=", " ");     /* get current frame */
      if (current>=mframes) wkeyf("FRAME=%d", frame);        /* restore frame */
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_rec                                 */
/* -------------------------------------------------------------------------- */
/*  Keyword handler responsible for recording MPEG movies.
 */
static void handle_rec(ident id, char *key, int code, void *arg)
{
   bool rec;
   (void)userflog(&rec, 1, 2, key, " ");
   if (rec) {
      int   nc;
      fchar name;
      char  namec[81];
      name.a = namec;
      name.l = 80;
      nc = userftext(name, 2, "MPEG=", " ");
      if (nc) {
         namec[nc] = '\0';
      } else {
         strcpy(namec, "sliceview.mpg");
      }
      statusf("MPEG recorder started");
      if (!GgiMpeg(plotter, ggiStart, namec)) {
         recording = TRUE;
      } else {
         wkeyf(key);
      }
   } else {
      if (recording) GgiMpeg(plotter, ggiStop);
      statusf(" ");
      recording = FALSE;
   }
}

/* ========================================================================== */
/*                                 Frames                                     */
/* -------------------------------------------------------------------------- */
/*  Frames() fills a form with controls for showing an animated sequence and
 *  the "special frames".
 *  It also creates a pop-up for loading special frames.
 *  The argument 'key' is the GIPSY keyword (type LOGICAL)
 *  which, when set to "YES", will cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
void Frames(char *key,  ident plotdev, ident ctrls)
{    
   s_load = GgiShell(NAME);
   s_prev = GgiUseShell(s_load);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   e_lab = GgiLabel("Load special set");
   e_box = GgiForm(NAME, 0);
   GgiSetPosition(e_lab,    0, NULL,  0, NULL);
   GgiSetPosition(e_box,    0, NULL,  0, e_lab);
   GgiSetPosition(closebut, 0, NULL,  0, e_box);
  
/*  -------------------------  Movie control -------------------------------- */
   controls = ctrls; 
   (void)GgiUseShell(controls);

   back_b  = GgiSetLabel(GgiButton("BACK=", NULL), "< <", 0);
   bafo_b  = GgiSetLabel(GgiButton("BAFO=", NULL), "<->", 0);
   forw_b  = GgiSetLabel(GgiButton("FORW=", NULL), "> >", 0);
   stop_b  = GgiButton("STOP=", NULL);
   last2_b = GgiSetLabel(GgiButton("LAST2=", "Limit to last two frames"),
                         "LAST 2", 0);;
   stepb   = GgiSetLabel(GgiButton("STEPBW=", NULL), " < ", 0);
   stepf   = GgiSetLabel(GgiButton("STEPFW=", NULL), " > ", 0);

   wkeyf("FRAME= LAST2=");
   frame_t = GgiSetLabel(GgiTextField("FRAME=", "Current frame", 4),
                         "Frame", 45);
   frame_g = GgiSetLabel(GgiGauge("FRAME=", NULL, 150, 0.0, (float)(mframes-1)),
                         " ", 1);
   GgiSetFormat(frame_g, "%.0f");
   speed_t = GgiSetLabel(GgiTextField("SPEED=", "Speed (frames/s)", 4),
                         "Speed", 45);
   speed_g = GgiSetLabel(GgiGauge("LSP=", NULL, 150,
                                   log(2.5), log(25.0)), " ", 1);

   GgiSetPosition(speed_t,  0, NULL,    0, NULL);
   GgiSetPosition(speed_g, -1, speed_t, 0, NULL);
   GgiSetPosition(frame_t,  0, NULL,    0, speed_t);
   GgiSetPosition(frame_g, -1, frame_t, 0, speed_t);

   GgiSetPosition(back_b,  10, speed_g, 0, NULL);
   GgiSetPosition(bafo_b,  -1, back_b,  0, NULL);
   GgiSetPosition(forw_b,  -1, bafo_b,  0, NULL);
   GgiSetPosition(stop_b,  10, forw_b,  0, NULL);
   GgiSetPosition(last2_b, 10, stop_b,  0, NULL);
   
   GgiSetPosition(stepb,  10, frame_g, 0, back_b);
   GgiSetPosition(stepf,  -1, stepb,   0, back_b);


/*  -------------------------  Extra frames -------------------------------- */
{
   int i;
   ident topref=NULL;       /* for stacking in load pop-up */
   ident leftref=stepf;     /* for positioning in controls form */
   ident recbtn, mpgname;   /* MPEG recording controls */
   ident curframe;
   ident group=RadioGroup("EFRAME=");
   char key[KEYLEN], val[5];
    
   (void)GgiUseShell(e_box);
   for (i=0; i<EXTRAFRAMES; i++) {
      sprintf(key, "EFRAME%d=", i);
      wkeyf(key);
      GgiHandleEvents();
      sprintf(val, "%d", i);
      RadioAddKey(group, key, val);
      eframes[i].frame = i;
      curframe = extra_frame(i);
      GgiSetPosition(curframe,  0, NULL, 0, topref);
      topref = curframe;
      {
         (void)GgiUseShell(controls);
         eframes[i].showbut = GgiSetLabel(GgiButton(key, NULL), " ", EBW);
         GgiDeactivate(eframes[i].showbut);
         GgiSetPosition(eframes[i].showbut,
                        leftref==stepf?10:-1, leftref, 0, back_b);
         leftref = eframes[i].showbut;
         (void)GgiUseShell(e_box);
      }
   }
   (void)ScheduleKeyevent(handle_extra, "EFRAME=", KEYCHANGE, NULL);
   
/*  ------------------------ MPEG recording -------------------------------- */

   (void)GgiUseShell(controls);
   recbtn  = GgiSetLabel(GgiButton("REC=", "Record MPEG movie"), "REC:", 0);
   mpgname = GgiSetLabel(GgiTextField("MPEG=", "MPEG movie filename", 14),
                         "", 0);
   GgiSetPosition(recbtn,  10, leftref, 0, back_b);
   GgiSetPosition(mpgname, -1, recbtn, 0, back_b);
   (void)GgiUseShell(e_box);
   (void)ScheduleKeyevent(handle_rec, "REC=", KEYCHANGE, NULL);

}
   

   (void)GgiUseShell(s_prev);
   ScheduleKeyevent(popshell, key, KEYCHANGE, s_load);
   ScheduleKeyevent(realspeed, "LSP=", KEYCHANGE, "SPEED=");
   ScheduleKeyevent(logspeed, "SPEED=", KEYCHANGE, "LSP=");
   ScheduleKeyevent(showframe, "FRAME=", KEYCHANGE, NULL);
   ScheduleKeyevent(playmovie, "PLAY=", KEYCHANGE, NULL);
   ScheduleKeyevent(momode, "FORW=", KEYCHANGE, NULL);
   ScheduleKeyevent(momode, "BAFO=", KEYCHANGE, NULL);
   ScheduleKeyevent(momode, "BACK=", KEYCHANGE, NULL);
   ScheduleKeyevent(stopmovie, "STOP=", KEYCHANGE, NULL);
   ScheduleKeyevent(stepper, "STEPBW=", KEYCHANGE, (void*)-1);
   ScheduleKeyevent(stepper, "STEPFW=", KEYCHANGE, (void*)+1);
   ScheduleKeyevent(set_bool, "LAST2=", KEYCHANGE, &last2);
   wkeyf("PLAY=");
   if (!TriggerKey("SPEED=")) wkeyf("SPEED=10");
   wkeyf("BACK= BAFO= FORW=");
   plotter = plotdev;
}

/* ========================================================================== */
/*                                 MovieFrames                                */
/* -------------------------------------------------------------------------- */
void MovieFrames(int newframes, int extra)
{
   int i;
   char butlab[5];
   
   nframes = newframes;
   mframes = nframes-extra;
   if (mframes<=1) {
      GgiDeactivate(controls);
   } else {
      GgiActivate(controls);
      GgiSetRange(frame_g, 0.0, (float)(mframes-1));   /* adjust slider range */
   }
   for (i=0; i<EXTRAFRAMES; i++) {
      if (i<extra) {
         eframes[i].frame = mframes+i;
         GgiActivate(eframes[i].form);
         sprintf(butlab, "%d", i+1);
         GgiSetLabel(eframes[i].showbut, butlab, EBW);
         GgiSetLabel(eframes[i].label, "- empty -", 0);
      } else {
         GgiDeactivate(eframes[i].form);
         GgiSetLabel(eframes[i].showbut, " ", EBW);
         GgiSetLabel(eframes[i].label, "- not available -", 0);
      }
      GgiDeactivate(eframes[i].showbut);
   }
}

/* ========================================================================== */
/*                                 ScheduleFrame                              */
/* -------------------------------------------------------------------------- */
void ScheduleFrame(FrameProc proc)
{
   frameproc = proc;
}

/* ========================================================================== */
/*                                 FrameText                                  */
/* -------------------------------------------------------------------------- */
void FrameText(int frame, char* text)
{
   GgiSetLabel(eframes[frame-eframes[0].frame].label, text, 0);
   GgiHelpText(eframes[frame-eframes[0].frame].showbut, text);
   GgiActivate(eframes[frame-eframes[0].frame].showbut);
}   
         
/* ========================================================================== */
/*                                 SuppressFrame                              */
/* -------------------------------------------------------------------------- */
void SuppressFrame(void)
{
   dontshow = TRUE;
}
	
#<

#>            guilines.c
/* guilines.c
                              COPYRIGHT (c) 2000
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "Line slice"
#define SELKEY "_GUI_LINES="
#define SELINX SLICE_LINES
#define MARGIN  115
#define MARGIN2  60
#define PANELWIDTH 235
#define SEP 10

#include "stddef.h"
#include "stdio.h"
#include "string.h"
#include "gipsyc.h"
#include "userfio.h"
#include "wkey.h"
#include "pgplot.h"
#include "ggi.h"
#include "guipar.h"
#include "helptext.h"
#include "gui.h"
#include "guilines.h"


static void relay_angle(ident id, char *key, int code, void *arg);

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}
#define MINSIZE(x,y) GgiSetPosition(GgiCanvas("canvas",1,1), x, NULL, y, NULL)

static char *filelabels[]={"Save XV to set", "Save sample", "Save plot", NULL};
typedef enum              {FILE_XV,   FILE_SAMPLE,   FILE_PLOT} filechoices;

static char *helplabels[]={"Line slice panel", "_LINE", "User Interface", NULL};
static char *helpdocs[]={"sliceview.dc1#lines", NULL, "ggi.doc"};

static ident s_lines;                         /* slice keywords shell        */
static ident mainform;                        /* active components container */
static ident info[3];                         /* frame labels                */
static ident len1g, len1t, len2g, len2t;
static ident xvplot, xiplot, yvplot;          /* plotters                    */
static bool  state=FALSE;                     /* visibility                  */
static bool  selected=FALSE;                  /* select state                */
static fint  choice=-1;                       /* current slice selection     */
static bool  initialized=FALSE;
static char  popkey[KEYLEN];

/* -------------------------------------------------------------------------- */
/*                                 xslice                                     */
/* -------------------------------------------------------------------------- */
static void xslice(ident id, char *key, int code, void *arg)
{
   choice=-1; 
   (void)userfint(&choice, 1, 2, key, " ");
   wkeyf("%s%s", SELKEY, choice==SELINX?"YES":"NO");
}

/* -------------------------------------------------------------------------- */
/*                                 selself                                    */
/* -------------------------------------------------------------------------- */
static void selself(ident id, char *key, int code, void *arg)
{
   bool previous=selected;
   
   (void)userflog(&selected, 1, 2, key, " ");
   if (tobool(selected)) {
      (void)SuppressKeyevent(xslice, "SLICE=");      
      wkeyf("SLICE=%d", SELINX);
      choice = SELINX;
      GgiActivate(mainform);
   } else {
      GgiDeactivate(mainform);
      if (previous && choice==SELINX) {
         wkeyf("SLICE="); 
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 couple                                     */
/* -------------------------------------------------------------------------- */
static void couple(ident id, char *key, int code, void *arg)
{
   bool button=toflog(FALSE);
    
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiDeactivate(len2g);
      GgiDeactivate(len2t);
   } else {
      GgiActivate(len2g);
      GgiActivate(len2t);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 fine_angle                                 */
/* -------------------------------------------------------------------------- */
static void fine_angle(ident id, char *key, int code, void *arg)
{
   float angle=0.0, minang, maxang;
   ident gauge=(ident)arg;
   
   (void)userfreal(&angle, 1, 2, key, " "); 
   minang = angle-5.0;
   maxang = angle+5.0;
   if (maxang>360.0) {
      maxang -= 360.0;
      minang -= 360.0;
   } else if (minang<=-360.0) {
      maxang += 360.0;
      minang += 360.0;
   }
   SuppressKeyevent(relay_angle, "_GUI_ANGLE=");
   wkeyf("_GUI_ANGLE=%.2f", (maxang+minang)/2.0);
   (void)GgiSetRange(gauge, maxang, minang);
}
   
/* -------------------------------------------------------------------------- */
/*                                 relay_angle                                */
/* -------------------------------------------------------------------------- */
static void relay_angle(ident id, char *key, int code, void *arg)
{
   float angle=0.0;
   
   (void)userfreal(&angle, 1, 2, key, " ");
   SuppressKeyevent(fine_angle, "POSANG=");  
   wkeyf("POSANG=%.2f", angle);
}  

/* -------------------------------------------------------------------------- */
/*                                 handle_menu                                */
/* -------------------------------------------------------------------------- */
static void handle_menu(ident id, char *key, int code, void *arg)
{
   fint choice=-1;
    
   if (userfint(&choice, 1, 2, key, " ")==1) {
      wkeyf("_MENUCONTEXT=%d", MENU_LINES);
      switch (choice) {
         case FILE_XV: {
            GgiPrompter("XVOUT=", "Set to save XV slice(s)");
            break;
         }
         case FILE_SAMPLE: {
            GgiPrompter("SAMPOUT=", "File to save sample");
            break;
         }
         case FILE_PLOT: {
            GgiPlotPrompter("HCFILENAME=", "HCDEVICE=",
                            "Line slice plot.\nPostScript filename:");
            break;
         }
      }
      wkeyf(key);
   }
}
   
/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut, selbut;
   ident topbar, xvform, grform, yvform;
   ident file_m, iintp_b, intp_b, help_m;
   ident pos_t, ang_t, ang_d, ang_g, sam_t, sam_g, wid_t, wid_g, sep_t, sep_g;
   ident lig_l, lig_b;
   ident pan_l, pan_b, ofs_t, rat_t, cpl_b;

   fint xvwidth=XVWIDTH, xvheight=XVHEIGHT, xiheight=XIHEIGHT;

   (void)userfint(&xvwidth,  1, 2, "XVWIDTH=",  " ");
   (void)userfint(&xvheight, 1, 2, "XVHEIGHT=", " ");
   (void)userfint(&xiheight, 1, 2, "XIHEIGHT=", " ");
      
   strcpy(popkey, key);
   s_lines = GgiShell(NAME);
   (void)GgiUseShell(s_lines);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   selbut   = GgiSetLabel(GgiButton(SELKEY, "Select window"), "SELECT", 0);
   (void)ScheduleKeyevent(selself, SELKEY, KEYCHANGE, NULL);
   mainform = GgiForm(NAME, 0);
   GgiSetPosition(mainform,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, mainform);
   GgiSetPosition(selbut,   -GgiWidth(selbut)-4, mainform, 0, mainform);

   (void)GgiUseShell(mainform);
   topbar = GgiForm(NAME, 1);
   xvform = GgiForm(NAME, 1);
   grform = GgiForm(NAME, 1);
   yvform = GgiForm(NAME, 1);
   GgiSetPosition(topbar, 0, NULL, 0, NULL);
   GgiSetPosition(xvform, 0, NULL, 0, topbar);
   GgiSetPosition(grform, 0, NULL, 0, xvform);
   GgiSetPosition(yvform, 0, NULL, 0, grform);


/* --------------------------------- top bar -------------------------------- */
   (void)GgiUseShell(topbar);
   MINSIZE(xvwidth+PANELWIDTH,0);
   file_m = GgiSetLabel(GgiMenu("_LINE_FILE=", NULL, filelabels), "FILE", 0);  
   (void)ScheduleKeyevent(handle_menu, "_LINE_FILE=", KEYCHANGE, NULL);
   iintp_b = GgiSetLabel(GgiButton("PGINTERP=",
                          "Interpolate displayed images"), "INTP", 0);
   intp_b = GgiSetLabel(GgiButton("INTERPOL=", "Interpolate data"), "DINTP", 0);
   help_m = GgiHelpMenu("_HELP_LINES=", "HELP", NULL, helplabels, helpdocs);
   GgiSetPosition(file_m,  0, NULL,    0, NULL);
   GgiSetPosition(iintp_b, 0, file_m,  0, NULL);
   GgiSetPosition(intp_b,  0, iintp_b, 0, NULL);
   GgiSetPosition(help_m, xvwidth+PANELWIDTH-GgiWidth(help_m), NULL, 0, NULL);
    
/* --------------------------------- XV plot -------------------------------- */
   (void)GgiUseShell(xvform);
   MINSIZE(xvwidth+PANELWIDTH,0);
   info[0] = GgiLabel(" ");
   xvplot = GgiPlotField("LINEPLOT1", xvwidth, xvheight);
   GgiPlotMapColors(xvplot, 0, 16, 16, IMAGECOLORS, -1);
   ang_t = GgiSetLabel(GgiTextField("POSANG=", H_POSANG, 9), "Angle", 40);
   ang_g = GgiSetLabel(GgiGauge("_GUI_ANGLE=", NULL, 70, 5.0, -5.0),
                       "Fine", 40);
   ang_d = GgiSetLabel(GgiDial("POSANG=", NULL, 25, 0-180, 360-180, 12, 0.5, 0.95, 1.0,
                               360.0, 0.0), NULL, 0);
   GgiSetCircular(ang_d, TRUE);
   GgiSetFormat(ang_d,"%.2f");
   (void)ScheduleKeyevent(fine_angle, "POSANG=", KEYCHANGE, ang_g);
   (void)ScheduleKeyevent(relay_angle, "_GUI_ANGLE=", KEYCHANGE, NULL);
   (void)GgiSetFormat(ang_g, "%.2f");
   pos_t = GgiSetLabel(GgiTextField("CENTRE=", H_CENTRE, 10), "Position", MARGIN);
   len1t = GgiSetLabel(GgiTextField("SAMPLEN1=", H_SAMPLEN1, 5),
                       "Sam.len", MARGIN2);
   len1g = GgiSetLabel(GgiGauge("SAMPLEN1=", H_SAMPLEN1, 100, 0.0, 100.0),
                       " ", 1);
   (void)GgiSetFormat(len1g, "%.1f");
   sam_t = GgiSetLabel(GgiTextField("SAMP=", H_SAMP, 5),
                        "Sam.sep", MARGIN2);
   sam_g = GgiSetLabel(GgiGauge("SAMP=", H_SAMP, 100, 0.0, 10.0 ), "", 1);
   (void)GgiSetFormat(sam_g, "%.2f");
   wid_t = GgiSetLabel(GgiTextField("SWIDTH=", H_SWIDTH, 5),
                        "Int.wid", MARGIN2);
   wid_g = GgiSetLabel(GgiGauge("SWIDTH=", H_SWIDTH, 100, 0.0, 10.0 ), "", 1);
   (void)GgiSetFormat(wid_g, "%.2f");
   sep_t = GgiSetLabel(GgiTextField("INTSEP=", H_INTSEP, 5),
                        "Int.sep", MARGIN2);
   sep_g = GgiSetLabel(GgiGauge("INTSEP=", H_INTSEP, 100, 0.0, 1.0 ), "", 1);
   (void)GgiSetFormat(sep_g, "%.2f");

   GgiSetPosition(xvplot,  0, NULL,   0, NULL);
   GgiSetPosition(info[0], 0, NULL,   0, xvplot);
   GgiSetPosition(ang_t, SEP, xvplot, 0, NULL);
   GgiSetPosition(ang_g, SEP, xvplot, 0, ang_t);
   GgiSetPosition(ang_d,   0, ang_t,  0, NULL);
   GgiSetPosition(pos_t, SEP, xvplot, 0, ang_d);
   GgiSetPosition(len1t, SEP, xvplot, 0, pos_t);
   GgiSetPosition(len1g,   0, len1t,  0, pos_t);   
   GgiSetPosition(sam_t, SEP, xvplot, 0, len1g);
   GgiSetPosition(sam_g,   0, sam_t,  0, len1g);
   GgiSetPosition(wid_t, SEP, xvplot, 0, sam_t);
   GgiSetPosition(wid_g,   0, wid_t,  0, sam_t);
   GgiSetPosition(sep_t, SEP, xvplot, 0, wid_t );
   GgiSetPosition(sep_g, 0,   sep_t,  0, wid_t );

/* --------------------------------- line graph ----------------------------- */
   (void)GgiUseShell(grform);
   MINSIZE(xvwidth+PANELWIDTH,0);
   info[1] = GgiLabel(" ");
   xiplot  = GgiPlotField("LINEGRAPH", xvwidth, xiheight);
   lig_l   = GgiLabel("Line graph: ");
   lig_b   = GgiSetLabel(GgiButton("LINEGRAPH=", "Line graphs on/off"),
                       "ON/OFF", 0);
   GgiSetPosition(xiplot,  0, NULL,   0, NULL);
   GgiSetPosition(info[1], 0, NULL,   0, xiplot);
   GgiSetPosition(lig_l, SEP, xiplot, 0, NULL); 
   GgiSetPosition(lig_b, SEP, xiplot, 0, lig_l);

/* --------------------------------- YV plot -------------------------------- */
   (void)GgiUseShell(yvform);
   MINSIZE(xvwidth+PANELWIDTH,0);
   info[2] = GgiLabel(" ");
   yvplot  = GgiPlotField("LINEPLOT2", xvwidth, xvheight);
   GgiPlotMapColors(yvplot, 0, 16, 16, IMAGECOLORS, -1);
   pan_l   = GgiLabel("Panel 2: ");
   pan_b   = GgiSetLabel(GgiButton("PANEL2=", NULL), "ON/OFF", 0);
   ofs_t   = GgiSetLabel(GgiTextField("OFFSETPA=", H_OFFSETPA, 10),
                         "Offset P.A.", 0);
   len2t   = GgiSetLabel(GgiTextField("SAMPLEN2=", H_SAMPLEN2, 5),
                         "Sam.len", MARGIN2);
   len2g   = GgiSetLabel(GgiGauge("SAMPLEN2=", H_SAMPLEN2, 100, 0.0, 100.0),
                       " ", 1);
   (void)GgiSetFormat(len2g, "%.1f");
   rat_t = GgiSetLabel(GgiTextField("RATIO=", H_RATION, 10), "Ratio", MARGIN2);
   cpl_b = GgiButton("COUPLE=", "Couple sample lenghts");
   (void)ScheduleKeyevent(couple, "COUPLE=", KEYCHANGE, NULL);
   (void)TriggerKey("COUPLE=");
   GgiSetPosition(yvplot,  0, NULL,   0, NULL);
   GgiSetPosition(info[2], 0, NULL,   0, yvplot);
   GgiSetPosition(pan_l, SEP, yvplot, 0, NULL);
   GgiSetPosition(pan_b, SEP, yvplot, 0, pan_l);
   GgiSetPosition(ofs_t, SEP, yvplot, 8, pan_b);
   GgiSetPosition(len2t, SEP, yvplot, 0, ofs_t);
   GgiSetPosition(len2g,   0, len2t,  0, ofs_t);
   GgiSetPosition(rat_t, SEP, yvplot, 0, len2t);
   GgiSetPosition(cpl_b,   0, rat_t,  0, len2t);
   
   (void)GgiUseShell(NULL);
   (void)ScheduleKeyevent(xslice, "SLICE=", KEYCHANGE, NULL);
   
}

/* -------------------------------------------------------------------------- */
/*                                 pop_shell                                  */
/* -------------------------------------------------------------------------- */
static void pop_shell(bool newstate)
{
   GgiShowShell(s_lines, newstate);
   if (newstate && !initialized) {
      (void)pgopen_c(tofchar("LINEPLOT1")); pgclos_c();
      (void)pgopen_c(tofchar("LINEPLOT2")); pgclos_c();
      (void)pgopen_c(tofchar("LINEGRAPH")); pgclos_c();
      GgiPlotFrames(xvplot, 1);
      GgiPlotFrames(yvplot, 1);
      GgiPlotFrames(xiplot, 1);
      initialized = TRUE;
      wkeyf(popkey);
   }
   state = newstate;
   if (!state && selected) wkeyf("%sNO", SELKEY);
}

/* -------------------------------------------------------------------------- */
/*                                 slice                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void slice(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      pop_shell(!state);
      wkey_c(tofchar(key));
   }
}

/* ========================================================================== */
/*                                 Guilines                                   */
/* -------------------------------------------------------------------------- */
/*  Guilines() creates a pop-up shell for line slices. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern void Guilines(char *key)
{
   if (key) {
      initialize(key);
      ScheduleKeyevent(slice, key, KEYCHANGE, NULL);
   } else {
      pop_shell(TRUE);
   }
}

/* ========================================================================== */
/*                                 gui_samlen                                 */
/* -------------------------------------------------------------------------- */
extern void gui_samlen(float length)
{
   (void)GgiSetRange(len1g, 0.0, length);
   (void)GgiSetRange(len2g, 0.0, length);
}

/* ========================================================================== */
/*                                 gui_line_status                            */
/* -------------------------------------------------------------------------- */
extern void gui_line_status(int n, char *text)
{
   GgiSetLabel(info[n], text, 0);
}
#<

#>            zprof.c
/* zprof.c
                              COPYRIGHT (c) 2000
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "Z-profile"
#define NLINES 4

#include "stddef.h"
#include "gipsyc.h"
#include "userfio.h"
#include "guipar.h"
#include "gui.h"
#include "ggi.h"

static ident label[NLINES];

/* -------------------------------------------------------------------------- */
/*                                 popshell                                   */
/* -------------------------------------------------------------------------- */
static void popshell(ident id, char *key, int code, void *arg)
{
   static bool state=FALSE;
   bool button=toflog(FALSE);
   
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      wkeyf(key);                                /* reset button              */
      GgiShowShell((ident)arg, !state);          /* pop up/down               */
      state = !state;                            /* update state              */
   }
}

/* ========================================================================== */
/*                                 Zprof                                      */
/* -------------------------------------------------------------------------- */
void Zprof(char *key)
{
   static ident shell;
   ident prev, frame, plotter, close;
   ident topref;
   fint   zwidth=ZWIDTH, zheight=ZHEIGHT;
   int   i;


   (void)userfint(&zwidth,  1, 2 , "ZWIDTH=",  " ");
   (void)userfint(&zheight, 1, 2 , "ZHEIGHT=", " ");
   shell = GgiShell(NAME);                       /* shell container           */
   prev  = GgiUseShell(shell);                   /* save current, use shell   */
   frame = GgiForm("Filename", 1);               /* frame, thickness 1 pixel  */
   close = GgiSetLabel(GgiButton(key, NULL), "CLOSE", 0);

   GgiSetPosition(frame, 0, NULL, 0, NULL);
   GgiSetPosition(close, 0, NULL, 0, frame);

   GgiUseShell(frame);
   plotter = GgiPlotField("ZPROF", zwidth, zheight);
   GgiSetPosition(plotter, 0, NULL, 0, NULL);
   topref = plotter;
   for (i=0; i<NLINES; i++) {
      label[i] = GgiSetLabel(GgiLabel("infoline"), " ", 0);
      GgiSetPosition(label[i], 0, NULL, 0, topref);
      topref = label[i];
   }
   (void)GgiUseShell(prev);
   ScheduleKeyevent(popshell, key, KEYCHANGE, shell);
}

/* ========================================================================== */
/*                                 gui_zprof_info                             */
/* -------------------------------------------------------------------------- */
void gui_zprof_info(int n, char *text)
{
   if (n<NLINES) GgiSetLabel(label[n], text, 0);
}
#<

#>            guiellipse.c
/* guiellipse.c
                              COPYRIGHT (c) 2000
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "Ellipse slice"
#define SELKEY "_GUI_ELLIPSE="
#define SELINX SLICE_ELLIPSE
#define MARGIN  115
#define MARGIN2  60
#define PANELWIDTH 235
#define SEP 10

#include "stddef.h"
#include "stdio.h"
#include "string.h"
#include "gipsyc.h"
#include "userfio.h"
#include "wkey.h"
#include "pgplot.h"
#include "ggi.h"
#include "guipar.h"
#include "helptext.h"
#include "gui.h"
#include "guiellipse.h"


static void relay_angle(ident id, char *key, int code, void *arg);

#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}
#define MINSIZE(x,y) GgiSetPosition(GgiCanvas("canvas",1,1), x, NULL, y, NULL)

static char *filelabels[]={"Save XV to set", "Save sample", "Save plot", NULL};
typedef enum              {FILE_XV,   FILE_SAMPLE,   FILE_PLOT} filechoices;

static char *helplabels[]={"Ellipse slice panel", "_LINE",
                           "User Interface", NULL};
static char *helpdocs[]={"sliceview.dc1#ellipse", NULL, "ggi.doc"};

static ident s_ellipse;                       /* slice keywords shell        */
static ident mainform;                        /* active components container */
static ident info[2];                         /* frame labels                */
static ident len1g, len1t, len2g, len2t;
static ident xvplot, xiplot;                  /* plotters                    */
static bool  state=FALSE;                     /* visibility                  */
static bool  selected=FALSE;                  /* select state                */
static fint  choice=-1;                       /* current slice selection     */
static bool  initialized=FALSE;
static char  popkey[KEYLEN];

/* -------------------------------------------------------------------------- */
/*                                 xslice                                     */
/* -------------------------------------------------------------------------- */
static void xslice(ident id, char *key, int code, void *arg)
{
   choice=-1; 
   (void)userfint(&choice, 1, 2, key, " ");
   wkeyf("%s%s", SELKEY, choice==SELINX?"YES":"NO");
}

/* -------------------------------------------------------------------------- */
/*                                 selself                                    */
/* -------------------------------------------------------------------------- */
static void selself(ident id, char *key, int code, void *arg)
{
   bool previous=selected;
   
   (void)userflog(&selected, 1, 2, key, " ");
   if (tobool(selected)) {
      (void)SuppressKeyevent(xslice, "SLICE=");      
      wkeyf("SLICE=%d", SELINX);
      choice = SELINX;
      GgiActivate(mainform);
   } else {
      GgiDeactivate(mainform);
      if (previous && choice==SELINX) {
         (void)SuppressKeyevent(xslice, "SLICE=");
         wkeyf("SLICE=");
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 couple                                     */
/* -------------------------------------------------------------------------- */
static void couple(ident id, char *key, int code, void *arg)
{
   bool button=toflog(FALSE);
    
   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiDeactivate(len2g);
      GgiDeactivate(len2t);
   } else {
      GgiActivate(len2g);
      GgiActivate(len2t);
   }
}

/* -------------------------------------------------------------------------- */
/*                                 fine_angle                                 */
/* -------------------------------------------------------------------------- */
static void fine_angle(ident id, char *key, int code, void *arg)
{
   float angle=0.0, minang, maxang;
   ident gauge=(ident)arg;
   
   (void)userfreal(&angle, 1, 2, key, " "); 
   minang = angle-5.0;
   maxang = angle+5.0;
   if (maxang>360.0) {
      maxang -= 360.0;
      minang -= 360.0;
   } else if (minang<=-360.0) {
      maxang += 360.0;
      minang += 360.0;
   }
   SuppressKeyevent(relay_angle, "_E_GUI_ANGLE=");
   wkeyf("_E_GUI_ANGLE=%.2f", (maxang+minang)/2.0);
   (void)GgiSetRange(gauge, maxang, minang);
}
   
/* -------------------------------------------------------------------------- */
/*                                 relay_angle                                */
/* -------------------------------------------------------------------------- */
static void relay_angle(ident id, char *key, int code, void *arg)
{
   float angle=0.0;
   
   (void)userfreal(&angle, 1, 2, key, " ");
   SuppressKeyevent(fine_angle, "E_POSANG=");  
   wkeyf("E_POSANG=%.2f", angle);
}  

/* -------------------------------------------------------------------------- */
/*                                 handle_menu                                */
/* -------------------------------------------------------------------------- */
static void handle_menu(ident id, char *key, int code, void *arg)
{
   fint choice=-1;
    
   if (userfint(&choice, 1, 2, key, " ")==1) {
      wkeyf("_MENUCONTEXT=%d", MENU_ELLIPSE);
      switch (choice) {
         case FILE_XV: {
            GgiPrompter("XVOUT=", "Set to save XV slice(s)");
            break;
         }
         case FILE_SAMPLE: {
            GgiPrompter("SAMPOUT=", "File to save sample");
            break;
         }
         case FILE_PLOT: {
            GgiPlotPrompter("HCFILENAME=", "HCDEVICE=",
                            "Ellipse slice plot.\nPostScript filename:");
            break;
         }
      }
      wkeyf(key);
   }
}
   
/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut, selbut;
   ident topbar, xvform, grform;
   ident file_m, iintp_b, intp_b, help_m;
   ident pos_t, ang_t, ang_d, ang_g, para_t;
   ident sam_t, sam_g, wid_t, wid_g, sep_t, sep_g;
   ident lig_l, lig_b;
   ident rat_t, cpl_b;

   fint xvwidth=XVWIDTH, xvheight=XVHEIGHT, xiheight=XIHEIGHT;

   (void)userfint(&xvwidth,  1, 2, "XVWIDTH=",  " ");
   (void)userfint(&xvheight, 1, 2, "XVHEIGHT=", " ");
   (void)userfint(&xiheight, 1, 2, "XIHEIGHT=", " ");
      
   strcpy(popkey, key);
   s_ellipse = GgiShell(NAME);
   (void)GgiUseShell(s_ellipse);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   selbut   = GgiSetLabel(GgiButton(SELKEY, "Select"), "SELECT", 0);
   (void)ScheduleKeyevent(selself, SELKEY, KEYCHANGE, NULL);
   mainform = GgiForm(NAME, 0);
   GgiSetPosition(mainform,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, mainform);
   GgiSetPosition(selbut,   -GgiWidth(selbut)-4, mainform, 0, mainform);

   (void)GgiUseShell(mainform);
   topbar = GgiForm(NAME, 1);
   xvform = GgiForm(NAME, 1);
   grform = GgiForm(NAME, 1);
   GgiSetPosition(topbar, 0, NULL, 0, NULL);
   GgiSetPosition(xvform, 0, NULL, 0, topbar);
   GgiSetPosition(grform, 0, NULL, 0, xvform);


/* --------------------------------- top bar -------------------------------- */
   (void)GgiUseShell(topbar);
   MINSIZE(xvwidth+PANELWIDTH,0);
   file_m = GgiSetLabel(GgiMenu("_ELLIPSE_FILE=", NULL, filelabels), "FILE", 0);
   (void)ScheduleKeyevent(handle_menu, "_ELLIPSE_FILE=", KEYCHANGE, NULL);
   iintp_b = GgiSetLabel(GgiButton("PGINTERP=",
                          "Interpolate displayed images"), "INTP", 0);
   intp_b = GgiSetLabel(GgiButton("INTERPOL=", "Interpolate data"), "DINTP", 0);
   help_m = GgiHelpMenu("_HELP_ELLIPSE=", "HELP", NULL, helplabels, helpdocs);
   GgiSetPosition(file_m,  0, NULL,    0, NULL);
   GgiSetPosition(iintp_b, 0, file_m,  0, NULL);
   GgiSetPosition(intp_b,  0, iintp_b, 0, NULL);
   GgiSetPosition(help_m, xvwidth+PANELWIDTH-GgiWidth(help_m), NULL, 0, NULL);
    
/* --------------------------------- XV plot -------------------------------- */
   (void)GgiUseShell(xvform);
   MINSIZE(xvwidth+PANELWIDTH,0);
   info[0] = GgiLabel(" ");
   xvplot = GgiPlotField("ELLPLOT", xvwidth, xvheight);
   GgiPlotMapColors(xvplot, 0, 16, 16, IMAGECOLORS, -1);
   ang_t = GgiSetLabel(GgiTextField("E_POSANG=", H_E_POSANG, 9), "Angle", 40);
   ang_g = GgiSetLabel(GgiGauge("_E_GUI_ANGLE=", NULL, 70, 5.0, -5.0),
                       "Fine", 40);
   ang_d = GgiSetLabel(GgiDial("E_POSANG=", NULL, 25, 0-180, 360-180, 12,
                                  0.5, 0.95, 1.0, 360.0, 0.0), NULL, 0);
   GgiSetCircular(ang_d, TRUE);
   GgiSetFormat(ang_d,"%.2f");
   (void)ScheduleKeyevent(fine_angle, "E_POSANG=", KEYCHANGE, ang_g);
   (void)ScheduleKeyevent(relay_angle, "_E_GUI_ANGLE=", KEYCHANGE, NULL);
   (void)GgiSetFormat(ang_g, "%.2f");
   para_t = GgiSetLabel(GgiTextField("E_PARANGE=", H_E_PARANGE, 10),
                        "Angle range", MARGIN);
   pos_t = GgiSetLabel(GgiTextField("E_CENTRE=", H_E_CENTRE, 10), "Position", MARGIN);
   len1t = GgiSetLabel(GgiTextField("E_SAMPLEN1=", H_E_SAMPLEN1, 5),
                      "Maj.ax", MARGIN2);
   len1g = GgiSetLabel(GgiGauge("E_SAMPLEN1=", NULL, 100,
                                 0.0, 100.0), " ", 1);
   (void)GgiSetFormat(len1g, "%.1f");
   len2t   = GgiSetLabel(GgiTextField("E_SAMPLEN2=", H_E_SAMPLEN2, 5),
                         "Min.ax", MARGIN2);
   len2g   = GgiSetLabel(GgiGauge("E_SAMPLEN2=", NULL, 100,
                                  0.0, 100.0), " ", 1);
   (void)GgiSetFormat(len2g, "%.1f");
   rat_t = GgiSetLabel(GgiTextField("E_RATIO=", H_E_RATIO, 10), "Ratio", 0);
   cpl_b = GgiSetLabel(GgiButton("E_COUPLE=", "Couple sample lenghts"),
                                 "COUPLE", 0);
   (void)ScheduleKeyevent(couple, "E_COUPLE=", KEYCHANGE, NULL);
   (void)TriggerKey("E_COUPLE=");
   sam_t = GgiSetLabel(GgiTextField("E_SAMP=", H_E_SAMP, 5),
                        "Sam.sep", MARGIN2);
   sam_g = GgiSetLabel(GgiGauge("E_SAMP=", H_E_SAMP, 100, 0.0, 10.0 ), "", 1);
   (void)GgiSetFormat(sam_g, "%.2f");
   wid_t = GgiSetLabel(GgiTextField("E_SWIDTH=", H_SWIDTH, 5),
                        "Int.wid", MARGIN2);
   wid_g = GgiSetLabel(GgiGauge("E_SWIDTH=", H_SWIDTH, 100, 0.0, 10.0 ), "", 1);
   (void)GgiSetFormat(wid_g, "%.2f");
   sep_t = GgiSetLabel(GgiTextField("E_INTSEP=", H_INTSEP, 5),
                        "Int.sep", MARGIN2);
   sep_g = GgiSetLabel(GgiGauge("E_INTSEP=", H_INTSEP, 100, 0.0, 1.0 ), "", 1);
   (void)GgiSetFormat(sep_g, "%.2f");
      
   GgiSetPosition(xvplot,  0, NULL,   0, NULL);
   GgiSetPosition(info[0], 0, NULL,   0, xvplot);
   GgiSetPosition(ang_t, SEP, xvplot, 0, NULL);
   GgiSetPosition(ang_g, SEP, xvplot, 0, ang_t);
   GgiSetPosition(ang_d,   0, ang_t,  0, NULL);
   GgiSetPosition(para_t,SEP, xvplot, 0, ang_d);
   GgiSetPosition(pos_t, SEP, xvplot, 0, para_t);
   GgiSetPosition(len1t, SEP, xvplot, 0, pos_t);
   GgiSetPosition(len1g,   0, len1t,  0, pos_t);
   GgiSetPosition(len2t, SEP, xvplot, 0, len1t);
   GgiSetPosition(len2g,   0, len2t,  0, len1t);
   GgiSetPosition(rat_t, SEP, xvplot, 0, len2g);
   GgiSetPosition(cpl_b,   0, rat_t,  0, len2g);
   GgiSetPosition(sam_t, SEP, xvplot, 0, rat_t);
   GgiSetPosition(sam_g,   0, sam_t,  0, rat_t);
   GgiSetPosition(wid_t, SEP, xvplot, 0, sam_t);
   GgiSetPosition(wid_g,   0, wid_t,  0, sam_t);
   GgiSetPosition(sep_t, SEP, xvplot, 0, wid_t );
   GgiSetPosition(sep_g,   0, sep_t,  0, wid_t );

/* --------------------------------- line graph ----------------------------- */
   (void)GgiUseShell(grform);
   MINSIZE(xvwidth+PANELWIDTH,0);
   info[1] = GgiLabel(" ");
   xiplot  = GgiPlotField("ELLGRAPH", xvwidth, xiheight);
   lig_l   = GgiLabel("Line graph: ");
   lig_b   = GgiSetLabel(GgiButton("LINEGRAPH=", "Line graphs on/off"),
                       "ON/OFF", 0);
   GgiSetPosition(xiplot,  0, NULL,   0, NULL);
   GgiSetPosition(info[1], 0, NULL,   0, xiplot);
   GgiSetPosition(lig_l, SEP, xiplot, 0, NULL); 
   GgiSetPosition(lig_b, SEP, xiplot, 0, lig_l);
   
   (void)GgiUseShell(NULL);
   (void)ScheduleKeyevent(xslice, "SLICE=", KEYCHANGE, NULL);
}

/* -------------------------------------------------------------------------- */
/*                                 pop_shell                                  */
/* -------------------------------------------------------------------------- */
static void pop_shell(bool newstate)
{
   GgiShowShell(s_ellipse, newstate);
   if (newstate && !initialized) {
      (void)pgopen_c(tofchar("ELLPLOT")); pgclos_c();
      (void)pgopen_c(tofchar("ELLGRAPH")); pgclos_c();
      GgiPlotFrames(xvplot, 1);
      GgiPlotFrames(xiplot, 1);
      initialized = TRUE;
      wkeyf(popkey);
   }
   state = newstate;
   if (!state && selected) wkeyf("%sNO", SELKEY);
}

/* -------------------------------------------------------------------------- */
/*                                 slice                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void slice(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      pop_shell(!state);
      wkey_c(tofchar(key));
   }
}

/* ========================================================================== */
/*                                 Guiellipse                                 */
/* -------------------------------------------------------------------------- */
/*  Guiellipse() creates a pop-up shell for ellipse slices. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern void Guiellipse(char *key)
{
   if (key) {
      initialize(key);
      ScheduleKeyevent(slice, key, KEYCHANGE, NULL);
   } else {
      pop_shell(TRUE);
   }
}

/* ========================================================================== */
/*                                 gui_e_samlen                               */
/* -------------------------------------------------------------------------- */
extern void gui_e_samlen(float length)
{
   (void)GgiSetRange(len1g, 0.0, length);
   (void)GgiSetRange(len2g, 0.0, length);
}

/* ========================================================================== */
/*                                 gui_ell_status                             */
/* -------------------------------------------------------------------------- */
extern void gui_ell_status(int n, char *text)
{
   GgiSetLabel(info[n], text, 0);
}
#<

#>            guispline.c
/* guispline.c
                              COPYRIGHT (c) 2000
                        Kapteyn Astronomical Institute
         University of Groningen  -  9700 AV Groningen, The Netherlands


Author: J.P. Terlouw
*/

#define NAME "Spline slice"
#define SELKEY "_GUI_SPLINE="
#define SELINX SLICE_SPLINE
#define MARGIN 60
#define PANELWIDTH 235
#define SEP 10

#include "stddef.h"
#include "stdio.h"
#include "string.h"
#include "gipsyc.h"
#include "userfio.h"
#include "wkey.h"
#include "pgplot.h"
#include "ggi.h"
#include "guipar.h"
#include "helptext.h"
#include "gui.h"
#include "guispline.h"



#define New(type) ((type *)calloc(1,sizeof(type)))
#define NNew(n,type) ((type *)calloc(n,sizeof(type)))
#define Delete(x)  {free(x); x=NULL;}
#define MINSIZE(x,y) GgiSetPosition(GgiCanvas("canvas",1,1), x, NULL, y, NULL)

static char *filelabels[]={
   "Read spline points",
   "Save spline points",
   "Save XV to set",
   "Save sample",
   "Save plot", NULL};
typedef enum {
   FILE_RPOINTS,
   FILE_SPOINTS,
   FILE_XV,
   FILE_SAMPLE,
   FILE_PLOT} filechoices;

static char *helplabels[]={"Spline slice panel", "_LINE",
                           "User Interface", NULL};
static char *helpdocs[]={"sliceview.dc1#spline", NULL, "ggi.doc"};

static ident s_spline;                        /* slice keywords shell        */
static ident mainform;                        /* active components container */
static ident info[2];                         /* frame labels                */
static ident xvplot, xiplot;                  /* plotters                    */
static bool  state=FALSE;                     /* visibility                  */
static bool  selected=FALSE;                  /* select state                */
static fint  choice=-1;                       /* current slice selection     */
static bool  initialized=FALSE;
static char  popkey[KEYLEN];

/* -------------------------------------------------------------------------- */
/*                                 xslice                                     */
/* -------------------------------------------------------------------------- */
static void xslice(ident id, char *key, int code, void *arg)
{
   choice=-1; 
   (void)userfint(&choice, 1, 2, key, " ");
   wkeyf("%s%s", SELKEY, choice==SELINX?"YES":"NO");
}

/* -------------------------------------------------------------------------- */
/*                                 selself                                    */
/* -------------------------------------------------------------------------- */
static void selself(ident id, char *key, int code, void *arg)
{
   bool previous=selected;
   
   (void)userflog(&selected, 1, 2, key, " ");
   if (tobool(selected)) {
      (void)SuppressKeyevent(xslice, "SLICE=");      
      wkeyf("SLICE=%d", SELINX);
      choice = SELINX;
      GgiActivate(mainform);
   } else {
      GgiDeactivate(mainform);
      if (previous && choice==SELINX) {
         (void)SuppressKeyevent(xslice, "SLICE=");
         wkeyf("SLICE="); 
      }
   }
}

/* -------------------------------------------------------------------------- */
/*                                 handle_menu                                */
/* -------------------------------------------------------------------------- */
static void handle_menu(ident id, char *key, int code, void *arg)
{
   fint choice=-1;
    
   if (userfint(&choice, 1, 2, key, " ")==1) {
      wkeyf("_MENUCONTEXT=%d", MENU_SPLINE);
      switch (choice) {
         case FILE_RPOINTS: {
            ident browser = GgiFileBrowser(ggiIdent, "SPLINEIN=");
            if (!browser) {
               browser = GgiFileBrowser(ggiCreate, "SPLINEIN=",
                            "Spline points input file", NULL);
            }
            break;
         }
         case FILE_SPOINTS: {
            GgiPrompter("SPLINEOUT=", "File to save spline points");
            break;
         }
         case FILE_XV: {
            GgiPrompter("XVOUT=", "Set to save XV slice(s)");
            break;
         }
         case FILE_SAMPLE: {
            GgiPrompter("SAMPOUT=", "File to save sample");
            break;
         }
         case FILE_PLOT: {
            GgiPlotPrompter("HCFILENAME=", "HCDEVICE=",
                            "Spline slice plot.\nPostScript filename:");
            break;
         }
      }
      wkeyf(key);
   }
}
   
/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident closebut, selbut;
   ident topbar, xvform, grform;
   ident file_m, iintp_b, intp_b, help_m;
   ident sam_t, sam_g, wid_t, wid_g, sep_t, sep_g, clr_b, clr_f;
   ident lig_l, lig_b;

   fint xvwidth=XVWIDTH, xvheight=XVHEIGHT, xiheight=XIHEIGHT;

   (void)userfint(&xvwidth,  1, 2, "XVWIDTH=",  " ");
   (void)userfint(&xvheight, 1, 2, "XVHEIGHT=", " ");
   (void)userfint(&xiheight, 1, 2, "XIHEIGHT=", " ");
      
   strcpy(popkey, key);
   s_spline = GgiShell(NAME);
   (void)GgiUseShell(s_spline);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   selbut   = GgiSetLabel(GgiButton(SELKEY, "Select"), "SELECT", 0);
   (void)ScheduleKeyevent(selself, SELKEY, KEYCHANGE, NULL);
   mainform = GgiForm(NAME, 0);
   GgiSetPosition(mainform,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, mainform);
   GgiSetPosition(selbut,   -GgiWidth(selbut)-4, mainform, 0, mainform);

   (void)GgiUseShell(mainform);
   topbar = GgiForm(NAME, 1);
   xvform = GgiForm(NAME, 1);
   grform = GgiForm(NAME, 1);
   GgiSetPosition(topbar, 0, NULL, 0, NULL);
   GgiSetPosition(xvform, 0, NULL, 0, topbar);
   GgiSetPosition(grform, 0, NULL, 0, xvform);


/* --------------------------------- top bar -------------------------------- */
   (void)GgiUseShell(topbar);
   MINSIZE(xvwidth+PANELWIDTH,0);
   file_m = GgiSetLabel(GgiMenu("_SPLINE_FILE=", NULL, filelabels), "FILE", 0);
   (void)ScheduleKeyevent(handle_menu, "_SPLINE_FILE=", KEYCHANGE, NULL);
   iintp_b = GgiSetLabel(GgiButton("PGINTERP=",
                          "Interpolate displayed images"), "INTP", 0);
   intp_b = GgiSetLabel(GgiButton("INTERPOL=", "Interpolate data"), "DINTP", 0);
   help_m = GgiHelpMenu("_HELP_SPLINE=", "HELP", NULL, helplabels, helpdocs);
   GgiSetPosition(file_m,  0, NULL,    0, NULL);
   GgiSetPosition(iintp_b, 0, file_m,  0, NULL);
   GgiSetPosition(intp_b,  0, iintp_b, 0, NULL);
   GgiSetPosition(help_m, xvwidth+PANELWIDTH-GgiWidth(help_m), NULL, 0, NULL);
    
/* --------------------------------- XV plot -------------------------------- */
   (void)GgiUseShell(xvform);
   MINSIZE(xvwidth+PANELWIDTH,0);
   info[0] = GgiLabel(" ");
   xvplot = GgiPlotField("SPLPLOT", xvwidth, xvheight);
   GgiPlotMapColors(xvplot, 0, 16, 16, IMAGECOLORS, -1);

   sam_t = GgiSetLabel(GgiTextField("S_SAMP=", H_S_SAMP, 5), "Sam.sep", MARGIN);
   sam_g = GgiSetLabel(GgiGauge("S_SAMP=", H_S_SAMP, 100, 0.0, 5.0 ), "", 1);
   (void)GgiSetFormat(sam_g, "%.2f");
   
   wid_t = GgiSetLabel(GgiTextField("S_SWIDTH=", H_SWIDTH, 5),
                        "Int.wid", MARGIN);
   wid_g = GgiSetLabel(GgiGauge("S_SWIDTH=", H_SWIDTH, 100, 0.0, 10.0 ), "", 1);
   (void)GgiSetFormat(wid_g, "%.2f");
                                                 
   sep_t = GgiSetLabel(GgiTextField("S_INTSEP=", H_INTSEP, 5),
                        "Int.sep", MARGIN);   
   sep_g = GgiSetLabel(GgiGauge("S_INTSEP=", H_INTSEP, 100, 0.0, 1.0 ), "", 1);
   (void)GgiSetFormat(sep_g, "%.2f");
   
   clr_b = GgiSetLabel(GgiButton("SPLINECLEAR=", "Delete all spline points"),
                       "CLEAR CONTROLS", 130);
   clr_f = GgiSetLabel(GgiButton("CLEARFLAGS=", "Redraw without flag lines"),
                       "CLEAR MARKERS", 130);                       

   GgiSetPosition(xvplot,  0, NULL,     0, NULL);
   GgiSetPosition(info[0], 0, NULL,     0, xvplot);
   GgiSetPosition(sam_t, SEP, xvplot,   0, NULL);
   GgiSetPosition(sam_g,   0, sam_t,    0, NULL); 
   GgiSetPosition(wid_t, SEP, xvplot,   0, sam_t); 
   GgiSetPosition(wid_g,   0,  wid_t,   0, sam_t);
   GgiSetPosition(sep_t, SEP, xvplot,   0, wid_t);   
   GgiSetPosition(sep_g,   0,  sep_t,   0, wid_t); 
   GgiSetPosition(clr_b, SEP, xvplot,  15, sep_t);
   GgiSetPosition(clr_f, SEP, xvplot,   5, clr_b);   
/* --------------------------------- line graph ----------------------------- */
   (void)GgiUseShell(grform);
   MINSIZE(xvwidth+PANELWIDTH,0);
   info[1] = GgiLabel(" ");
   xiplot  = GgiPlotField("SPLGRAPH", xvwidth, xiheight);
   lig_l   = GgiLabel("Line graph: ");
   lig_b   = GgiSetLabel(GgiButton("LINEGRAPH=", "Line graphs on/off"),
                       "ON/OFF", 0);
   GgiSetPosition(xiplot,  0, NULL,   0, NULL);
   GgiSetPosition(info[1], 0, NULL,   0, xiplot);
   GgiSetPosition(lig_l, SEP, xiplot, 0, NULL); 
   GgiSetPosition(lig_b, SEP, xiplot, 0, lig_l);
   
   (void)GgiUseShell(NULL);
   (void)ScheduleKeyevent(xslice, "SLICE=", KEYCHANGE, NULL);
}

/* -------------------------------------------------------------------------- */
/*                                 pop_shell                                  */
/* -------------------------------------------------------------------------- */
static void pop_shell(bool newstate)
{
   GgiShowShell(s_spline, newstate);
   if (newstate && !initialized) {
      (void)pgopen_c(tofchar("SPLPLOT")); pgclos_c();
      (void)pgopen_c(tofchar("SPLGRAPH")); pgclos_c();
      GgiPlotFrames(xvplot, 1);
      GgiPlotFrames(xiplot, 1);
      initialized = TRUE;
      wkeyf(popkey);
   }
   state = newstate;
   if (!state && selected) wkeyf("%sNO", SELKEY);
}

/* -------------------------------------------------------------------------- */
/*                                 slice                                     */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void slice(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      pop_shell(!state);
      wkey_c(tofchar(key));
   }
}

/* ========================================================================== */
/*                                 Guispline                                  */
/* -------------------------------------------------------------------------- */
/*  Guispline() creates a pop-up shell for spline slices. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern void Guispline(char *key)
{
   if (key) {
      initialize(key);
      ScheduleKeyevent(slice, key, KEYCHANGE, NULL);
   } else {
      pop_shell(TRUE);
   }
}

/* ========================================================================== */
/*                                 gui_spl_status                             */
/* -------------------------------------------------------------------------- */
extern void gui_spl_status(int n, char *text)
{
   GgiSetLabel(info[n], text, 0);
}
#<

#>            guicont.c
#define MARGIN 60

#include "stdio.h"
#include "string.h"
#include "stddef.h"
#include "gipsyc.h"
#include "userfio.h"
#include "ggi.h" 
#include "helptext.h" 
#include "guipar.h"

#define NAME "Contours"

static ident s_contours;                      /* Contours keywords shell */
static ident mainform;                        /* active components container */
static char  popkey[KEYLEN];
static bool  state=FALSE;                     /* visibility */

static char *widths[]={
   "1", "2", "3", "4",  "6", "8", "10", "15", "20", NULL
};

static char *styles[]={  
   "1",         "2",      "3",                 "4",      NULL
};
static char *stylenames[]={
   "1: full line", "2: dashed", "3: dot-dash-dot-dash", "4: dotted", NULL
};

/* -------------------------------------------------------------------------- */
/*                                 contspec                                   */
/* -------------------------------------------------------------------------- */
static ident contspec(char *tag, char *labtxt)
{
   ident result=GgiForm(NAME, 1), prev;
   ident levels, colmenu, coltext, widmenu, widtext, stymenu, stytext;
   ident label, draw, ovly;
   char  levkey[KEYLEN], colkey[KEYLEN], widkey[KEYLEN], stykey[KEYLEN];
   char  levdrw[KEYLEN];

   sprintf(levkey, "LEVELS%s=",   tag);
   sprintf(colkey, "LEVCOL%s=",   tag);
   sprintf(widkey, "LEVTHICK%s=", tag);
   sprintf(stykey, "LEVSTYLE%s=", tag);
   sprintf(levdrw, "LEVDRAW%s=",  tag);
   prev = GgiUseShell(result);

   label   = GgiSetLabel(GgiLabel(" "), labtxt, 15);
   levels  = GgiSetLabel(GgiTextField(levkey, H_LEVELS, 20),
                        "Levels:", MARGIN);
   draw = GgiSetLabel(GgiButton(levdrw, H_LEVDRAW), "DRAW",    0);
   GgiSetPosition(draw, 0, levels, 0, NULL);
   if (*tag) {
      char levovl[KEYLEN];
      sprintf(levovl, "LEVOVER%s=", tag);
      ovly = GgiSetLabel(GgiButton(levovl, H_LEVOVER), "OVLY", 0);
      GgiSetPosition(ovly, 0, draw,   0, NULL);
   }
   coltext = GgiSetLabel(GgiTextField(colkey, H_LEVCOL_T, 20),
                        "Colour:", MARGIN);
   colmenu = GgiColorMenu(colkey, H_LEVCOL_M);
   widtext = GgiSetLabel(GgiTextField(widkey, H_LEVTHICK_T, 20),
                        "Width:", MARGIN);
   widmenu = GgiSetLabel(GgiTextMenu(widkey, H_LEVTHICK_M, widths), "WIDTH", 0);
   stytext = GgiSetLabel(GgiTextField(stykey, H_LEVSTYLE_T, 20),
                         "Style:", MARGIN);
   stymenu = GgiSetLabel(GgiTextMenu(stykey, H_LEVSTYLE_M, styles), "STYLE", 0);
   GgiMenuLabels(stymenu, stylenames);
   
   GgiSetPosition(label,   0, NULL,    0, NULL);
   GgiSetPosition(levels,  0, label,   0, NULL);
   GgiSetPosition(coltext, 0, label,   0, levels);
   GgiSetPosition(colmenu, 0, coltext, 0, levels);
   GgiSetPosition(widtext, 0, label,   0, coltext);
   GgiSetPosition(widmenu, 0, widtext, 0, coltext);
   GgiSetPosition(stytext, 0, label,   0, widtext);
   GgiSetPosition(stymenu, 0, stytext, 0, widtext);
   (void)GgiUseShell(prev);
   return result;
}

/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   int   i;
   ident prev;
   ident closebut;
   ident topref=NULL, curbox, label;
      
   strcpy(popkey, key);
   s_contours = GgiShell(NAME);
   prev = GgiUseShell(s_contours);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   mainform = GgiForm(NAME, 1);
   GgiSetPosition(mainform,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, mainform);

/* --------------------------------- main form ------------------------------ */
   (void)GgiUseShell(mainform);
   label = GgiLabel("Set levels and properties for contours.\n\n"
                    "Normal frames:");
   GgiSetPosition(label, 0, NULL, 0, NULL);
   curbox = contspec("", " ");
   GgiSetPosition(curbox, 0, NULL, 0, label);
   label = GgiLabel("Special frames:");
   GgiSetPosition(label, 0, NULL, 10, curbox);
   topref = label;
   for (i=0; i<EXTRAFRAMES; i++) {
      char tag[3], txt[3];
      sprintf(tag, "%d", i);
      sprintf(txt, "%d:", i+1);
      curbox = contspec(tag, txt);
      GgiSetPosition(curbox, 0, NULL, 0, topref);
      topref = curbox;
   }
   (void)GgiUseShell(prev);
}

/* -------------------------------------------------------------------------- */
/*                                 contwin                                    */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void contwin(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_contours, !state);
      state = !state;      
      wkeyf(key);
   }
}

/* ========================================================================== */
/*                                 Guicont                                    */
/* -------------------------------------------------------------------------- */
/*  Guicont() creates a pop-up shell for contours input. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern void Guicont(char *key)
{
   initialize(key);
   ScheduleKeyevent(contwin, key, KEYCHANGE, NULL);
}

#<

#>            guimark.c
#include "stdio.h"
#include "string.h"
#include "stddef.h"
#include "gipsyc.h"
#include "userfio.h"
#include "ggi.h" 
#include "helptext.h"

#define NAME "Markers and Flags"
#define MARGIN 80

static ident s_markers;                         /* Markers keywords shell */
static ident mainform;                        /* active components container */
static char  popkey[KEYLEN];
static bool  state=FALSE;                     /* visibility */

#if 0
static char *widths[]={
   "1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
   "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", NULL
};
#else
static char *widths[]={
   "1", "2", "3", "4",  "6", "8", "10", "15", "20", NULL
};
#endif     

static char *styles[]={
   "1",         "2",      "3",                 "4",      NULL
};
static char *stylenames[]={
   "full line", "dashed", "dot-dash-dot-dash", "dotted", NULL
};

static char *symbols[]={
   "1", "    2",        "3",          "21",       "4",       "25",      "5",
   "6",             "7",        "8",         "9",    "12",        "28",
           "29",      "30",       "31", NULL
};
static char *symbolnames[]={
   "DOT", "PLUS", "ASTERISK", "SMALLCIRCLE", "CIRCLE", "BIGCIRCLE", "CROSS",
   "SQUARE", "TRIANGLE", "CIRCLEPLUS", "CIRCLEDOT", "STAR", "ARROWLEFT",
   "ARROWRIGHT", "ARROWUP", "ARROWDOWN", NULL
};

/* -------------------------------------------------------------------------- */
/*                                 initialize                                 */
/* -------------------------------------------------------------------------- */
/*  Create pop-up shell and its contents; schedule the appropriate handlers.
 */
static void initialize(char *key)
{
   ident prev;
   ident closebut;
   ident marklab, flaglab;
   ident labelcol, flagcol, markwidth, flagstyle, flagwidth, marksym, marksize;
      
   strcpy(popkey, key);
   s_markers = GgiShell(NAME);
   prev = GgiUseShell(s_markers);
   closebut = GgiSetLabel(GgiButton(key, "Close window"), "CLOSE", 0);
   mainform = GgiForm(NAME, 1);
   GgiSetPosition(mainform,    0, NULL, 0, NULL);
   GgiSetPosition(closebut, 0, NULL, 0, mainform);

/* --------------------------------- top bar -------------------------------- */
   (void)GgiUseShell(mainform);
   marklab  = GgiSetLabel(GgiAlignLabel(GgiLabel(" "), ggiRight),
                          "Markers:", MARGIN);
   marksym = GgiSetLabel(GgiTextMenu("MARKSYM=", H_MARK_SYM, symbols),
                         "SYMBOL", 0);
   (void)GgiMenuLabels(marksym, symbolnames);
   markwidth  = GgiSetLabel(GgiTextMenu("MARKWIDTH=", H_MARK_WID, widths),
                            "WIDTH", 0);
   marksize = GgiSetLabel(GgiTextField("MARKSIZE=", H_MARK_SIZ, 4),
                         "Size:", 0);   

   flaglab   = GgiSetLabel(GgiAlignLabel(GgiLabel(" "), ggiRight),
                           "Flags:", MARGIN);
   flagstyle = GgiSetLabel(GgiTextMenu("FLAGSTYLE=", H_FLAG_STY, styles),
                           "STYLE", 0);
   GgiMenuLabels(flagstyle, stylenames);
   flagwidth = GgiSetLabel(GgiTextMenu("FLAGWIDTH=", H_FLAG_WID, widths),
                            "WIDTH", 0);
   
   labelcol = GgiSetLabel(GgiAlignLabel(GgiLabel(" "), ggiRight),
                          "Colour:", MARGIN);
   flagcol  = GgiColorMenu("FLAGCOL=", H_FLAG_COL);

#if 0
   GgiSetPosition(labelcol,   0, NULL,      0, NULL);
   GgiSetPosition(flagcol,    0, labelcol,  0, NULL);
   GgiSetPosition(markwidth,  0, flagcol,   0, NULL);
   GgiSetPosition(flagstyle,  0, markwidth, 0, NULL);   
   GgiSetPosition(marksym,    0, NULL,      0, flagstyle);
   GgiSetPosition(marksize,   0, marksym,   0, flagstyle);      
#else
   GgiSetPosition(marklab,    0, NULL,      0, NULL);
   GgiSetPosition(marksym,    0, marklab,   0, NULL);
   GgiSetPosition(markwidth,  0, marksym,   0, NULL);
   GgiSetPosition(marksize,   0, markwidth, 0, NULL);

   GgiSetPosition(flaglab,    0, NULL,      0, marksym);
   GgiSetPosition(flagstyle,  0, flaglab,   0, marksym);
   GgiSetPosition(flagwidth,  0, marksym,   0, marksym);

   GgiSetPosition(labelcol,   0, NULL,      0, flagstyle);
   GgiSetPosition(flagcol,    0, labelcol,  0, flagstyle);
#endif
   (void)GgiUseShell(prev);
}

/* -------------------------------------------------------------------------- */
/*                                 markwin                                    */
/* -------------------------------------------------------------------------- */
/*  Keyword handler causing the shell to be popped up or down.
 */
static void markwin(ident id, char *key, int code, void *arg)
{
   bool button=FALSE;

   (void)userflog(&button, 1, 2, key, " ");
   if (tobool(button)) {
      GgiShowShell(s_markers, !state);
      state = !state;      
      wkeyf(key);
   }
}

/* ========================================================================== */
/*                                 Guimark                                    */
/* -------------------------------------------------------------------------- */
/*  Guimark() creates a pop-up shell for marker input. The argument 'key'
 *  is the GIPSY keyword (type LOGICAL) which, when set to "YES", will
 *  cause the shell to be popped up or down.
 *  The same keyword is used for the <CLOSE> button in the shell.
 */
extern void Guimark(char *key)
{
   initialize(key);
   ScheduleKeyevent(markwin, key, KEYCHANGE, NULL);
}

#<
