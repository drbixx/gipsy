# UNTRANSLATED (L1): M SHLANS
# UNTRANSLATED (L2): LOGICAL      FOPERR
# HARACTER*80 INPUT, TARGET, LIST, INCDIR
# INCLUDE: NTEGER      LO, LPP
# ALL GETCOM(INPUT,TARGET,LIST,INCDIR,LO,LPP )
# NOTE: WARNING:: READONLY is not ANSI F77
# 
# FORTRAN DIRECTIVE: OPERR=.FALSE.
# UNTRANSLATED (L9): OPEN(UNIT=1,FILE=INPUT,STATUS='OLD',ERR=FILERR)
# INCLUDE: F FOPERR
# Label only: THEN
# UNTRANSLATED (L12): WRITE(*,*) 'Cannot open source'
# ALL EXITF(1)
# EJECT: NDIF
# INCLUDE: F TARGET.EQ.'0'
# Label only: THEN
# UNTRANSLATED (L17): OPEN(UNIT=2,STATUS='SCRATCH')
# EJECT: LSE
# FORTRAN DIRECTIVE: OPERR=.FALSE.
# UNTRANSLATED (L20): OPEN(UNIT=2,FILE=TARGET,STATUS='NEW',ERR=FILERR)
# INCLUDE: F (FOPERR)
# Label only: THEN
# UNTRANSLATED (L23): OPEN(UNIT=2,FILE=TARGET,STATUS='OLD')
# IF
# IF
# INCLUDE: F LIST.EQ.'0'
# Label only: THEN
# UNTRANSLATED (L28): OPEN(UNIT=3,STATUS='SCRATCH')
# EJECT: LSE
# FORTRAN DIRECTIVE: OPERR=.FALSE.
# UNTRANSLATED (L31): OPEN(UNIT=3,FILE=LIST,STATUS='NEW',ERR=FILERR)
# INCLUDE: F (FOPERR)
# Label only: THEN
# UNTRANSLATED (L34): OPEN(UNIT=3,FILE=LIST,STATUS='OLD')
# IF
# IF
# UNTRANSLATED (L37): REWIND 2
# ALL SHELTR(LO,LPP,1,2,3,NERR,4,10,INCDIR)
# INCLUDE: F NERR.EQ.0
# Label only: THEN
# UNTRANSLATED (L41): REWIND 2
# EJECT: LSE
# LOSE(UNIT=2,STATUS='DELETE')
# IF
# NOTE: WARNING: CALL EXIT NOT ANSI F77
# INCLUDE: F (NERR.EQ.0)
# Label only: THEN
# ALL EXITF(0)
# EJECT: LSE
# UNTRANSLATED (L50): WRITE(*,*) NERR, ' ERROR(S)'
# ALL EXITF(1)
# IF
# Label only: STOP
# UNTRANSLATED (L54): PROC FILERR
# FORTRAN DIRECTIVE: OPERR=.TRUE.
# PROC
# EJECT: ND
# NOTE: GET COMMAND LINE ARGUMENTS
# UNTRANSLATED (L59): SUBROUTINE GETCOM(SOURCE,TARGET,LISTER,INCDIR,LO,LPP)
# HARACTER*(*) SOURCE,TARGET,LISTER,INCDIR
# INCLUDE: NTEGER       LO,LPP
# UNTRANSLATED (L62): #!IF  UNIX
# HARACTER*80  ARGV,NAME
# INCLUDE: NTEGER       IARGC,IARG
# NOTE: ARG=IARGC( )
# INCLUDE: ARG=0
# UNTRANSLATED (L67): SOURCE='0'
# UNTRANSLATED (L68): TARGET='1'
# UNTRANSLATED (L69): LISTER='0'
# INCLUDE: NCDIR='0'
# Label only: LO=1
# Label only: LPP=57
# UNTRANSLATED (L73): WHILE (IARG.LE.NARG)
# UNTRANSLATED (L74): #!IF  HPUX
# ALL IGETARG(IARG,ARGV,LEN(ARGV) )
# ALL GETARG(IARG,ARGV )F
# INCLUDE: F (IARG.EQ.0)
# Label only: THEN
# NOTE: AME=ARGV
# EJECT: LSE
# INCLUDE: F (ARGV(1:3).EQ.'-ln')
# Label only: THEN
# Label only: LPP=0
# INCLUDE: =4
# UNTRANSLATED (L85): WHILE (ARGV(I:I).GE.'0'.AND.ARGV(I:I).LE.'9')
# UNTRANSLATED (L86): LPP=10*LPP+ICHAR(ARGV(I:I))-ICHAR('0')
# INCLUDE: =I+1
# WHILE
# EJECT: LSEIF (ARGV(1:2).EQ.'-l')
# Label only: THEN
# UNTRANSLATED (L91): LISTER='1'
# INCLUDE: F (ARGV(3:3).GE.'0'.AND.ARGV(3:3).LE.'3')
# Label only: THEN
# UNTRANSLATED (L94): LO=ICHAR(ARGV(3:3))-ICHAR('0')
# EJECT: NDIF
# EJECT: LSEIF (ARGV.EQ.'-f')
# Label only: THEN
# UNTRANSLATED (L98): TARGET='0'
# EJECT: LSEIF (ARGV(1:2).EQ.'-I')
# Label only: THEN
# INCLUDE: NCDIR=ARGV(3:)
# EJECT: LSEIF (INDEX(ARGV,'.shl').NE.0)
# Label only: THEN
# UNTRANSLATED (L104): SOURCE=ARGV
# EJECT: LSE
# UNTRANSLATED (L106): WRITE(*,*) 'Unknown option on command line'
# ALL EXITF(1)
# EJECT: NDIF
# EJECT: NDIF
# INCLUDE: ARG=IARG+1
# WHILE
# INCLUDE: F (NARG.EQ.0)
# Label only: THEN
# NOTE: =INDEX(NAME,' ')
# UNTRANSLATED (L115): WRITE(*,*) NAME(:N),'source [-I<dir>] [-f] [-l[<lo>] [-ln<lpp>]]'
# ALL EXITF(1)
# EJECT: NDIF
# NOTE: =INDEX(SOURCE,'.shl')
# INCLUDE: F (N.EQ.0)
# Label only: THEN
# UNTRANSLATED (L121): WRITE(*,*) 'No Source file specified!'
# ALL EXITF(1)
# EJECT: LSE
# INCLUDE: F (LISTER.NE.'0')
# Label only: THEN
# UNTRANSLATED (L126): LISTER=SOURCE(:N)//'sls'
# EJECT: NDIF
# INCLUDE: F (TARGET.NE.'0')
# Label only: THEN
# UNTRANSLATED (L130): TARGET=SOURCE(:N)//'f'
# EJECT: NDIF
# EJECT: NDIF	VMS
# HARACTER*256 ARGS
# ALL LIB$GET_FOREIGN(ARGS)
# UNTRANSLATED (L135): LENC=INDEX(ARGS,' ')
# INCLUDE: F (ARGS.EQ.' ')
# Label only: THEN
# UNTRANSLATED (L138): WRITE(*,*) 'SHELTRAN SOURCE.SHL[/LIST][/INCLUDE=<DIR>'//'[/LPP=<N>][/LO=<M>]][/NOFOR]'
# ALL EXITF(1)
# EJECT: LSE
# UNTRANSLATED (L141): TARGET='1'
# UNTRANSLATED (L142): LISTER='0'
# Label only: LO=1
# Label only: LPP=57
# NOTE: L=INDEX(ARGS,'/LIST')
# INCLUDE: F (NL.NE.0)
# Label only: THEN
# UNTRANSLATED (L148): LISTER='1'
# UNTRANSLATED (L149): ARGS(NL:NL+4)=' '
# EJECT: NDIF
# NOTE: L=INDEX(ARGS,'/NOFOR')
# INCLUDE: F (NL.NE.0)
# Label only: THEN
# UNTRANSLATED (L154): TARGET='0'
# UNTRANSLATED (L155): ARGS(NL:NL+5)=' '
# EJECT: NDIF
# NOTE: L=INDEX(ARGS,'/INCLUDE=')
# INCLUDE: F (NL.NE.0)
# Label only: THEN
# UNTRANSLATED (L160): ARGS(NL:NL+8)=' '
# NOTE: L=NL+9
# INCLUDE: =0
# UNTRANSLATED (L163): WHILE (ARGS(NL:NL).NE.'/'.AND.ARGS(NL:NL).NE.' ')
# INCLUDE: =I+1
# INCLUDE: NCDIR(I:I)=ARGS(NL:NL)
# UNTRANSLATED (L166): ARGS(NL:NL)=' '
# NOTE: L=NL+1
# WHILE
# EJECT: NDIF
# NOTE: L=INDEX(ARGS,'/LO=')
# INCLUDE: F (NL.NE.0)
# Label only: THEN
# UNTRANSLATED (L173): ARGS(NL:NL+3)=' '
# NOTE: L=NL+4
# INCLUDE: F (ARGS(NL:NL).GE.'0'.AND.ARGS(NL:NL).LE.'3')
# Label only: THEN
# UNTRANSLATED (L177): LO=ICHAR(ARGS(NL:NL))-ICHAR('0')
# UNTRANSLATED (L178): ARGS(NL:NL)=' '
# EJECT: NDIF
# EJECT: NDIF
# NOTE: L=INDEX(ARGS,'/LPP=')
# INCLUDE: F (NL.NE.0)
# Label only: THEN
# UNTRANSLATED (L184): ARGS(NL:NL+4)=' '
# NOTE: L=NL+5
# Label only: LPP=0
# UNTRANSLATED (L187): WHILE (ARGS(NL:NL).GE.'0'.AND.ARGS(NL:NL).LE.'9')
# UNTRANSLATED (L188): LPP=10*LPP+ICHAR(ARGS(NL:NL))-ICHAR('0')
# UNTRANSLATED (L189): ARGS(NL:NL)=' '
# NOTE: L=NL+1
# WHILE
# EJECT: NDIF
# NOTE: L=INDEX(ARGS,'.SHL')
# INCLUDE: F (NL.NE.0)
# Label only: THEN
# NOTE: E=NL+3
# NOTE: L=NL-1
# UNTRANSLATED (L198): WHILE (NL.GT.0.AND.ARGS(NL:NL).NE.' ')
# NOTE: L=NL-1
# WHILE
# UNTRANSLATED (L201): SOURCE=ARGS(NL+1:NE)
# UNTRANSLATED (L202): ARGS(NL+1:NE)=' '
# EJECT: NDIF
# INCLUDE: F (ARGS.NE.' ')
# Label only: THEN
# UNTRANSLATED (L206): WRITE(*,*) 'Unknown option(s) on command line'
# ALL EXITF(1)
# EJECT: NDIF
# EJECT: NDIF
# NOTE: =INDEX(SOURCE,'.SHL')
# INCLUDE: F (N.EQ.0)
# Label only: THEN
# UNTRANSLATED (L213): WRITE(*,*) 'No Source file specified!'
# ALL EXITF(1)
# EJECT: LSE
# INCLUDE: F (LISTER.NE.'0')
# Label only: THEN
# UNTRANSLATED (L218): LISTER=SOURCE(:N)//'SLS'
# EJECT: NDIF
# INCLUDE: F (TARGET.NE.'0')
# Label only: THEN
# UNTRANSLATED (L222): TARGET=SOURCE(:N)//'F'
# EJECT: NDIF
# EJECT: NDIFF
# Label only: RETURN
# EJECT: ND
# NOTE: 
# NOTE: CONVERT SHELTRAN INTO FORTRAN 77
# UNTRANSLATED (L229): SUBROUTINE SHELTR(N1,N2,N3,N4,N5,N6,INCBEG,INCMAX,INCDIR)
# NOTE: IST OPTIONINES PER PAGENPUT FILE LOGICAL UNITORTRAN OUTPUT FILE LOGICAL
# NOTE: 
# UNTRANSLATED (L232): LOGICAL LNRPRT,CONPRT
# NOTE: PRINT LINE-, CONT. LINE NUMBERS
# UNTRANSLATED (L234): PARAMETER(LNRPRT=.TRUE.,CONPRT=.TRUE.)
# HARACTER*80 INCDIR
# HARACTER*160 INCNAM
# UNTRANSLATED (L237): LOGICAL NEXIT,ENDINP
# HARACTER*1 LINE(80),CPARM(66)
# HARACTER*80 CLINE
# NOTE: CHARACTER LAST USED
# INCLUDE: NTEGER POS
# OMMON /BLINE/LINE
# OMMON /BLIST/POS,LSTOPT,LINEPP,NPRINT
# OMMON /BPARM/NPARM(66)
# OMMON/CHPARM/ CPARM
# OMMON /BPARS/NTYPE,NTARGT,NEXIT,NOUT,LUOUT
# NOTE: 
# OMMON /ERR/ NERROR,NWARN
# INCLUDE: NTEGER SOURC
# NOTE: INDENTATION LEVEL AND STEP
# INCLUDE: NTEGER LEVEL,STEP
# HARACTER*1 BLANK,ZERO
# NOTE: LEGAL CHARACTERS IN LINE-COLUMN 1 (STMT NTYPE 1)
# HARACTER*1 SPCHAR(6),FORMT(7)
# NOTE: CHARACTER TYPE IN LINE-COLUMN 1
# INCLUDE: NTEGER SUBTYPER TO UPPER FUNCTION ( 1 CHAR )
# HARACTER*1  LTU
# EJECT: QUIVALENCE (LINE,CLINE)
# UNTRANSLATED (L259): DATA ENDINP/.FALSE./
# NOTE: CONTROLS PRINTING OF ISN
# UNTRANSLATED (L261): DATA LEVEL/0/,STEP/3/
# UNTRANSLATED (L262): DATA BLANK/' '/,ZERO/'0'/
# UNTRANSLATED (L263): DATA SPCHAR/'C','E','N','*','F','I'/
# UNTRANSLATED (L264): DATA FORMT/'F','O','R','M','A','T','('/ FILE OPTIONS(0,1,2,3)
# UNTRANSLATED (L265): LSTOPT=N1S PER PAGE OF LISTING
# UNTRANSLATED (L266): LINEPP=N2
# NOTE: LUN FOR INPUT SOURCE TEXT FILE
# UNTRANSLATED (L268): SOURC=N3
# NOTE: LUN FOR LISTING OUTPUT FILE
# NOTE: PRINT=N5
# NOTE: LUN FOR FINAL FORTRAN OUTPUT TEXT
# NOTE: TARGT=N4
# NOTE: 
# NOTE: INITIALIZE SOURCE LISTER
# ALL LISTER
# NOTE: INITIALIZE PARSER
# ALL PARSER
# EJECT: 
# NOTE: MAIN LOOP
# NOTE: 
# UNTRANSLATED (L281): WHILE .TRUE.
# NOTE: READ SOURCE LINE
# 100    FORMAT(80A1)
# UNTRANSLATED (L284): READ (SOURC,100,END=ENDSRC) LINE
# INCLUDE: F ENDINP
# Label only: THEN
# Label only: XWHILE
# IFSLATE TAB CHARACTERS
# NOTE: .   (CALL CAN BE REMOVED IF THERE WILL BE NO TABS)
# ALL RTAB(LINE,80)
# NOTE: FIND FIRST NON-BLANK
# UNTRANSLATED (L292): PERFORM NBLPOS
# UNTRANSLATED (L293): SELECT POS
# ASE 1
# UNTRANSLATED (L295): PERFORM SUBTPE
# UNTRANSLATED (L296): SELECT SUBTYP
# NOTE: COMMENT LINE
# ASE 1,4
# NOTE: TYPE=110
# NOTE: EJECT LINE
# ASE 2
# NOTE: TYPE=100
# ALL HEADER
# NOTE: NOTE LINE
# ASE 3
# NOTE: TYPE=100
# ALL PNOTE
# NOTE: COMPILER DIRECTIVE LINE;
# ASE 5
# NOTE: LIST AS COMMENT
# NOTE: TYPE=110
# ALL FCARD
# ASE 6
# NOTE: TYPE=110
# INCLUDE: F SOURC.EQ.N3
# Label only: THEN
# UNTRANSLATED (L317): SOURC=INCBEG
# EJECT: LSEIF SOURC.LT.INCMAX
# Label only: THEN
# UNTRANSLATED (L320): SOURC=SOURC+1
# EJECT: LSE
# NOTE: TYPE=105
# IF
# INCLUDE: F NTYPE.EQ.110
# Label only: THEN
# UNTRANSLATED (L326): PERFORM MAKNAM
# NOTE: WARNING:: READONLY is not ANSI F77
# 
# UNTRANSLATED (L329): OPEN(UNIT=SOURC,FILE=INCNAM,STATUS='OLD',ERR=OPERI)
# IF
# Label only: OTHER
# NOTE: TYPE=102
# UNTRANSLATED (L333): PERFORM FMTSCN
# INCLUDE: F NTYPE.EQ.29
# NOTE: FORMAT STATEMENT
# Label only: THEN
# UNTRANSLATED (L337): PERFORM BLKPOS
# NOTE: FORMAT LABEL TOO LARGE?
# INCLUDE: F POS.EQ.6
# Label only: THEN
# NOTE: TYPE=103
# IF
# IF
# SELECT
# ASE 2,3,4,5
# NOTE: TYPE=102
# UNTRANSLATED (L347): PERFORM FMTSCN
# ASE 6
# NOTE: CONTINUATION LINE?
# INCLUDE: F LINE(6).NE.ZERO
# Label only: THEN
# NOTE: TYPE=3
# EJECT: LSE
# ALL CLASS(NTYPE,POS)
# IF
# Label only: OTHER
# NOTE: CLASSIFY STATEMENT,RETURN TYPE AND CHAR. LAST USED
# ALL CLASS(NTYPE,POS)
# SELECT
# EJECT: 
# INCLUDE: F NTYPE.LT.100
# Label only: THEN
# NOTE: PRINT OF VALID TYPES OTHER THAN 1
# UNTRANSLATED (L364): SELECT NTYPE
# ASE 1
# NOTE: CONTINUATION LINE
# ASE 3
# INCLUDE: F LEVEL.EQ.0
# Label only: THEN
# ALL PRINTC(CONPRT)
# EJECT: LSE
# ALL PRINT(LEVEL,CONPRT)
# IF
# NOTE: IF,WHILE,FOR,SELECT,REPEAT,PROC
# ASE 4,8,11,14,20,23
# ALL PRINT(LEVEL,LNRPRT)
# UNTRANSLATED (L377): LEVEL=LEVEL+STEP
# NOTE: THEN,ELSE,CASE,OTHER,ELSEIF
# ASE 5,6,15,16,31
# UNTRANSLATED (L380): LEVEL=LEVEL-STEP
# ALL PRINT(LEVEL,LNRPRT)
# UNTRANSLATED (L382): LEVEL=LEVEL+STEP
# NOTE: CIF,CWHILE,CFOR,CSELECT,UNTIL,CPROC
# ASE 7,10,13,17,18,24
# UNTRANSLATED (L385): LEVEL=LEVEL-STEP
# ALL PRINT(LEVEL,LNRPRT)
# NOTE: ENTRY,END : RESET LEVEL TO BEGIN-VALUE
# ASE 27,28
# UNTRANSLATED (L389): LEVEL=0
# ALL PRINT(LEVEL,LNRPRT)
# NOTE: FORMAT
# ASE 29
# NOTE: PRINT ISN
# ALL PRINTC(LNRPRT)
# NOTE: FORTRAN,XWHILE,XFOR,XREPEAT,PERFORM
# Label only: OTHER
# ALL PRINT(LEVEL,LNRPRT)
# SELECT
# ALL PARSE
# EJECT: LSEIF NTYPE.GT.100
# Label only: THEN
# ALL PRINTC(.FALSE.)
# UNTRANSLATED (L403): SELECT NTYPE-100
# ASE 1
# ALL ERRMSG('INVALID CASE OR RETURN STATEMENT                  ')
# ASE 2
# ALL ERRMSG('INVALID CHARACTER OR ILLEGAL STATEMENT NUMBER     ')
# ASE 3
# ALL ERRMSG('FORMAT LABEL GREATER THAN 9999                    ')
# ASE 4
# ALL ERRMSG('MORE THAN 7 *-PARAMETERS                          ')
# NOTE: NTYPE=110: COMMENT
# ASE 5
# ALL ERRMSG('INCLUDE FILE MAXIMUM NESTING DEPTH EXCEEDED       ')
# ASE 6
# ALL ERRMSG('INCLUDE FILE OPEN ERROR                           ')
# Label only: OTHER
# SELECT
# IF
# NOTE: NEXT SOURCE STATEMENT,PLEASE
# WHILE
# NOTE: PRINT FINAL MESSAGES
# ALL FINAL
# NOTE: 6=NERROR
# Label only: RETURN
# EJECT: 
# NOTE: TYPE PRE-SELECTION
# UNTRANSLATED (L428): PROC SUBTPE
# UNTRANSLATED (L429): SUBTYP=0
# FORTRAN DIRECTIVE: OR I=1,6
# INCLUDE: F ( LTU( LINE(1) ) .EQ. SPCHAR(I) )
# Label only: THEN
# UNTRANSLATED (L433): SUBTYP=I
# Label only: XFOR
# IF
# FOR
# PROC
# NOTE: 
# NOTE: END OF CURRENT SOURCE FILE
# UNTRANSLATED (L440): PROC ENDSRC
# EJECT: NDINP=SOURC.EQ.N3
# LOSE(UNIT=SOURC)
# INCLUDE: F SOURC.EQ.INCBEG
# Label only: THEN
# UNTRANSLATED (L445): SOURC=N3
# EJECT: LSE
# UNTRANSLATED (L447): SOURC=SOURC-1
# IF
# LINE='* END OF INCLUDE <<<<<<<<<<<<<<<<<'
# PROC
# NOTE: NCLUDE FILE OPEN ERROR
# UNTRANSLATED (L452): PROC OPERI
# INCLUDE: F SOURC.EQ.INCBEG
# Label only: THEN
# UNTRANSLATED (L455): SOURC=N3
# EJECT: LSE
# UNTRANSLATED (L457): SOURC=SOURC-1
# IF
# NOTE: TYPE=106
# PROC
# NOTE: 
# NOTE: FIND FIRST NON-BLANK IN LABEL FIELD
# UNTRANSLATED (L463): PROC NBLPOS
# Label only: POS=0
# Label only: REPEAT
# UNTRANSLATED (L466): POS=POS+1
# UNTRANSLATED (L467): UNTIL LINE(POS).NE.BLANK.OR.POS.EQ.7
# PROC
# NOTE: 
# NOTE: 
# NOTE: FIRST BLANK AFTER START OF LABEL
# UNTRANSLATED (L472): PROC BLKPOS
# Label only: POS=1
# Label only: REPEAT
# UNTRANSLATED (L475): POS=POS+1
# UNTRANSLATED (L476): UNTIL LINE(POS).EQ.BLANK.OR.POS.EQ.6
# PROC
# NOTE: 
# NOTE: 
# NOTE: VERIFY 'FORMAT'
# UNTRANSLATED (L481): PROC FMTSCN
# Label only: J=1
# INCLUDE: =7
# UNTRANSLATED (L484): WHILE I.LE.72
# INCLUDE: F LINE(I).EQ.BLANK
# Label only: THEN
# INCLUDE: =I+1
# EJECT: LSE
# INCLUDE: F ( LTU( LINE(I) ) .EQ. FORMT(J)  )
# Label only: THEN
# INCLUDE: =I+1
# Label only: J=J+1
# INCLUDE: F J.EQ.8
# Label only: THEN
# NOTE: TYPE=29
# Label only: XWHILE
# IF
# EJECT: LSE
# Label only: XWHILE
# IF
# IF
# WHILE
# PROC
# NOTE: CONCATENATES INCLUDE FILENAME
# NOTE: 
# UNTRANSLATED (L506): PROC MAKNAM
# INCLUDE: NCNAM=' '
# UNTRANSLATED (L508): LNAM = 0
# INCLUDE: F INCDIR.NE.'0'
# Label only: THEN
# FORTRAN DIRECTIVE: OR I=1,80
# INCLUDE: F INCDIR(I:I).NE.' '
# Label only: THEN
# UNTRANSLATED (L514): LNAM=LNAM+1
# INCLUDE: NCNAM(LNAM:LNAM)=INCDIR(I:I)
# IF
# FOR
# IF
# FORTRAN DIRECTIVE: OR I=2,80
# INCLUDE: F CLINE(I:I).NE.' '
# Label only: THEN
# UNTRANSLATED (L522): LNAM=LNAM+1
# INCLUDE: NCNAM(LNAM:LNAM)=CLINE(I:I)
# IF
# FOR
# PROC
# EJECT: ND
# NOTE: HANDLES EVERY THING CONCERNING THE SOURCE LISTING.
# NOTE: 
# UNTRANSLATED (L530): SUBROUTINE LISTER
# NOTE: 
# Label only: SAVE
# NOTE: DEFAULTS: LIST OPTION - LINES PER PAGE
# UNTRANSLATED (L534): PARAMETER (LODEF=1,LPPDEF=50)
# HARACTER*1 LINE(80)
# OMMON /BLINE/LINE
# OMMON /BLIST/IPOS(1),LSTOPT,LINEPP,NPRINT
# OMMON /ERR/ ERROR,NWARN
# INCLUDE: NTEGER CHARPL
# NOTE: LINE COUNT START
# INCLUDE: NTEGER START
# NOTE: SOURCE LINE COUNT
# INCLUDE: NTEGER COMCON
# INCLUDE: NTEGER PAGENO,LINENO
# INCLUDE: NTEGER SEQNO,LINTOT,ERROR,ERRTOT,WRNTOT
# INCLUDE: NTEGER POS
# INCLUDE: NTEGER I
# INCLUDE: NTEGER NEL, NELC
# HARACTER*1 BLLINE(72),POINTR,BLANK
# INCLUDE: NTEGER LEV,LEVEL,INIT,LAST,LENG
# NOTE: BLANK LINE
# UNTRANSLATED (L552): LOGICAL NOTE
# UNTRANSLATED (L553): LOGICAL LNRPRT,LNOPRT
# HARACTER*1 TITLSV(66),TITLE(66)
# HARACTER*10 FORSEQ(4),NBRING
# HARACTER*5 SOURCE
# HARACTER*1 OUT(124)
# HARACTER*(*) TEXT
# HARACTER*1 TEXT2(6)
# UNTRANSLATED (L560): DATA SEQNO,LINTOT/0,0/
# UNTRANSLATED (L561): DATA ERRTOT,WRNTOT/0,0/
# UNTRANSLATED (L562): DATA TITLE/66*' '/
# UNTRANSLATED (L563): DATA OUT/124*' '/
# UNTRANSLATED (L564): DATA BLANK/' '/
# UNTRANSLATED (L565): DATA NOTE/.FALSE./
# UNTRANSLATED (L566): DATA START/1/
# UNTRANSLATED (L567): DATA BLLINE/72*' '/
# UNTRANSLATED (L568): DATA POINTR/'^'/
# UNTRANSLATED (L569): DATA FORSEQ/ 'FORT + SEQ', '   FORTRAN', '   FORTRAN', 'SEQUENTIAL'/
# EJECT: 
# 200 FORMAT(' ***ERROR***',10X,A)
# 201 FORMAT(1X)
# 202 FORMAT(' ..WARNING..',10X,6A1,1X,A)
# 203 FORMAT(7X,'*ERROR IN FOLLOWING LINE WITH SOURCE SEQ.NO :',I4,'*')
# 400 FORMAT('0END OF SEGMENT')
# 401 FORMAT('0  OPTIONS IN EFFECT - LINECOUNT=',I2,', LINEWIDTH=',I3, ', ',A,'URCE, ',A,' NUMBERING')
# 406 FORMAT('0',I4,' ERROR(S)',11X,I4,' TARGET STATEMENTS')
# 500 FORMAT('0END OF PROGRAM')
# 600 FORMAT(I4,'  SHELTRAN ERROR(S)')
# 601 FORMAT(I4,' WARNING MESSAGE(S)')
# NOTE: ><  SET INITIAL VALUES
# INCLUDE: F LSTOPT.LT.0.OR.LSTOPT.GT.3
# Label only: THEN
# UNTRANSLATED (L584): LSTOPT=LODEF
# IF
# INCLUDE: F LINEPP.LE.0
# Label only: THEN
# UNTRANSLATED (L588): LINEPP=LPPDEF
# IF
# UNTRANSLATED (L590): SOURCE='   SO'
# HARPL=79
# NOTE: BRING=FORSEQ(LSTOPT+1)
# UNTRANSLATED (L593): SELECT LSTOPT
# ASE 1
# HARPL=131
# ASE 2,3
# Label only: OTHER
# UNTRANSLATED (L598): SOURCE='NO SO'
# SELECT
# FORTRAN DIRECTIVE: OR I=1,66
# UNTRANSLATED (L601): TITLSV(I)=TITLE(I)
# FOR
# UNTRANSLATED (L603): PERFORM BEGIN
# Label only: RETURN
# EJECT: 
# NOTE: ><  ISSUE WARNING MESSAGES
# EJECT: NTRY WARN(TEXT2,TEXT)
# NOTE: CHECK FOR END OF PAGE
# UNTRANSLATED (L609): PERFORM CHECK
# UNTRANSLATED (L610): PERFORM TXTLEN
# UNTRANSLATED (L611): WRITE (NPRINT,202) TEXT2,TEXT(:NEL)
#       WRITE(*,202) TEXT2,TEXT(:NEL)
# NOTE: COUNT WARNINGS
# NOTE: WARN=NWARN+1
# Label only: RETURN
# NOTE: ><  ISSUE ERROR MESSAGES
# NOTE: (    ALSO COUNTS ERRORS)
# EJECT: NTRY ERRMSG(TEXT)
# UNTRANSLATED (L619): POS = IPOS(1)
# INCLUDE: F POS.GE.73
# Label only: THEN
# Label only: POS=72
# IF
# EJECT: RROR = ERROR + 1
# INCLUDE: F LSTOPT.EQ.0
# Label only: THEN
# OMCON=COMCON+4
# NOTE: CHECK FOR END OF PAGE
# UNTRANSLATED (L629): PERFORM CHECK
# UNTRANSLATED (L630): WRITE (NPRINT,203) SEQNO
# NOTE: WRITE SOURCE LINE
# NOTE: EL=NELC(LINE,80)
# UNTRANSLATED (L633): WRITE (NPRINT,'(1X,I4,3X,80(A1:))') LINENO,(LINE(KGB),KGB=1,NEL)
# EJECT: LSE
# OMCON = COMCON + 2
# UNTRANSLATED (L636): PERFORM CHECK
# IF
# INCLUDE: F LSTOPT.NE.1
# Label only: THEN
# NOTE: SET POINTER
# UNTRANSLATED (L641): BLLINE(POS) = POINTR
# NOTE: WRITE POINTER LINE
# NOTE: EL=NELC(BLLINE,72)
# UNTRANSLATED (L644): WRITE(NPRINT,'(8X,72(A1:))') (BLLINE(KGB),KGB=1,NEL)
# NOTE: CLEAR POINTER
# UNTRANSLATED (L646): BLLINE(POS) = BLANK
# EJECT: LSE
# UNTRANSLATED (L648): WRITE (NPRINT,201)
# IF
# NOTE: WRITE ERROR MESSAGE
# UNTRANSLATED (L651): PERFORM TXTLEN
# UNTRANSLATED (L652): WRITE(NPRINT,200) TEXT(:NEL)
#      WRITE(*,200) TEXT(:NEL)
# UNTRANSLATED (L654): WRITE(NPRINT,201)
# Label only: RETURN
# NOTE: 
# NOTE: ><  INCREMENT SOURCE LINE NUMBER
# EJECT: NTRY ICRISN(INCR)
# UNTRANSLATED (L659): LINENO = LINENO + INCR
# Label only: RETURN
# NOTE: 
# NOTE: ><  PRINT SRC LINE; ALIGN & INDENT
# EJECT: NTRY PRINT(LEV,LNRPRT)
# UNTRANSLATED (L664): LNOPRT=LNRPRT
# UNTRANSLATED (L665): SELECT LSTOPT
# ASE 1
# INCLUDE: F LEV.LE.30.AND.LEV.GE.0
# Label only: THEN
# UNTRANSLATED (L669): LEVEL=LEV+7
# EJECT: LSE
# INCLUDE: F LEV.LT.0
# Label only: THEN
# UNTRANSLATED (L673): LEVEL=7
# EJECT: LSE
# UNTRANSLATED (L675): LEVEL=37
# IF
# IF
# UNTRANSLATED (L678): PERFORM FSTLST
# INCLUDE: F LEVEL+LENG.GT.73.AND.NOTE
# Label only: THEN
# OMCON=COMCON+1
# UNTRANSLATED (L682): PERFORM CHECK
# NOTE: EL=NELC(OUT,124)
# UNTRANSLATED (L684): WRITE(NPRINT,'(8X,124(A1:))') (OUT(KGB),KGB=1,NEL)
# UNTRANSLATED (L685): PERFORM BLKOUT
# EJECT: LSE
# UNTRANSLATED (L687): PERFORM CHECK
# IF
# UNTRANSLATED (L689): OUT(6)=LINE(6)
# UNTRANSLATED (L690): PERFORM LONGPR
# ASE 2
# UNTRANSLATED (L692): PERFORM SHRTPR
# ASE 3
# UNTRANSLATED (L694): PERFORM SEQPRT
# Label only: OTHER
# UNTRANSLATED (L696): SEQNO=SEQNO+1
# SELECT
# Label only: RETURN
# NOTE: 
# NOTE: ><  PRINT WITHOUT ALIGN OR INDENT
# EJECT: NTRY PRINTC(LNRPRT)
# UNTRANSLATED (L702): LNOPRT=LNRPRT
# UNTRANSLATED (L703): SELECT LSTOPT
# ASE 1
# UNTRANSLATED (L705): LEVEL=1
# INCLUDE: NIT=1
# UNTRANSLATED (L707): LAST=72
# UNTRANSLATED (L708): PERFORM CHECK
# UNTRANSLATED (L709): PERFORM LONGPR
# ASE 2
# UNTRANSLATED (L711): PERFORM SHRTPR
# ASE 3
# UNTRANSLATED (L713): PERFORM SEQPRT
# Label only: OTHER
# UNTRANSLATED (L715): SEQNO=SEQNO+1
# SELECT
# Label only: RETURN
# NOTE: 
# NOTE: ><  PROCESS NOTE
# EJECT: NTRY PNOTE
# UNTRANSLATED (L721): SELECT LSTOPT
# ASE 1
# INCLUDE: F NOTE
# Label only: THEN
# UNTRANSLATED (L725): PERFORM CHECK
# NOTE: EL=NELC(OUT,124)
# UNTRANSLATED (L727): WRITE(NPRINT,'(8X,124(A1:))') (OUT(KGB),KGB=1,NEL)
# UNTRANSLATED (L728): PERFORM BLKOUT
# IF
# UNTRANSLATED (L730): PERFORM FSTLST
# UNTRANSLATED (L731): PERFORM CC26
# INCLUDE: F LENG.GT.50
# Label only: THEN
# UNTRANSLATED (L734): LAST=INIT+49
# IF
# UNTRANSLATED (L736): LEVEL=75
# UNTRANSLATED (L737): PERFORM FILOUT
# NOTE: OTE=.TRUE.
# ASE 2
# UNTRANSLATED (L740): PERFORM CHECK
# NOTE: EL=NELC(LINE,80)
# UNTRANSLATED (L742): WRITE(NPRINT,'(8X,80(A1:))') (LINE(KGB),KGB=1,NEL)
# ASE 3
# UNTRANSLATED (L744): PERFORM SEQPRT
# Label only: OTHER
# UNTRANSLATED (L746): SEQNO=SEQNO+1
# SELECT
# Label only: RETURN
# NOTE: 
# NOTE: ><  PROCESS EJECT LINE
# EJECT: NTRY HEADER
# UNTRANSLATED (L752): PERFORM FSTLST
# UNTRANSLATED (L753): PERFORM CC26
# INCLUDE: F LENG.NE.0.AND.LSTOPT.NE.0
# Label only: THEN
# FORTRAN DIRECTIVE: OR I=1,66
# UNTRANSLATED (L757): TITLSV(I)=LINE(I+6)
# FOR
# IF
# UNTRANSLATED (L760): SELECT LSTOPT
# ASE 1,2
# NOTE: WRITE PAGE HEADER
# UNTRANSLATED (L763): PERFORM NWPAGE
# ASE 3
# OMCON=COMCON-1
# UNTRANSLATED (L766): PERFORM SEQPRT
# UNTRANSLATED (L767): PERFORM NWPAGE
# Label only: OTHER
# UNTRANSLATED (L769): SEQNO=SEQNO+1
# SELECT
# Label only: RETURN
# NOTE: 
# NOTE: ><  WRITE TRAILER
# EJECT: NTRY TRAIL
# OMCON=COMCON+5+MIN(1,NWARN)
# UNTRANSLATED (L776): PERFORM CHECK
# UNTRANSLATED (L777): WRITE(NPRINT,400)
# UNTRANSLATED (L778): PERFORM STAT
# UNTRANSLATED (L779): LINTOT = LINTOT + LINENO - START
# EJECT: RRTOT = ERRTOT + ERROR
# UNTRANSLATED (L781): WRNTOT = WRNTOT + NWARN
# UNTRANSLATED (L782): PERFORM BEGIN
# Label only: RETURN
# NOTE: 
# NOTE: ><  FINAL ENTRY POINT
# EJECT: NTRY FINAL
# UNTRANSLATED (L787): PERFORM CHECK
# NOTE: PRINT TRAILER
# UNTRANSLATED (L789): WRITE(NPRINT,500)
# NOTE: CHECK LAST STATEMENT IS <END>
# INCLUDE: F LINENO .GT. START
# Label only: THEN
# UNTRANSLATED (L793): WRITE (NPRINT,201)
# NOTE: WRITE ERROR
# UNTRANSLATED (L795): WRITE (NPRINT,200) 'END STATEMENT IS MISSING'
#      WRITE(*,200) 'END STATEMENT IS MISSING'
# UNTRANSLATED (L797): LINTOT=LINTOT+LINENO+1-START
# EJECT: RRTOT = ERRTOT + ERROR + 1
# IF
# UNTRANSLATED (L800): LINENO=LINTOT+START-1
# EJECT: RROR = ERRTOT
# NOTE: WARN = WRNTOT
# NOTE: WRITE SOURCE LIST TRAILER
# UNTRANSLATED (L804): PERFORM STAT
# UNTRANSLATED (L805): SEQNO=0
# UNTRANSLATED (L806): LINTOT=0
# EJECT: RRTOT=0
# NOTE: OTE=.FALSE.
# Label only: RETURN
# EJECT: 
# NOTE: RESET COUNTERS
# UNTRANSLATED (L812): PROC BEGIN
# UNTRANSLATED (L813): PAGENO = 0
# EJECT: RROR = 0
# NOTE: WARN=0
# UNTRANSLATED (L816): LINENO = START
# OMCON=LINEPP
# FORTRAN DIRECTIVE: OR I=1,66
# UNTRANSLATED (L819): TITLSV(I)=TITLE(I)
# FOR
# PROC
# NOTE: 
# NOTE: 
# NOTE: DETERMINE ALIGNMENT POINTERS
# UNTRANSLATED (L825): PROC FSTLST
# INCLUDE: NIT=6
# Label only: REPEAT
# INCLUDE: NIT=INIT+1
# UNTRANSLATED (L829): UNTIL LINE(INIT).NE.BLANK.OR.INIT.EQ.73
# INCLUDE: F INIT.NE.73
# Label only: THEN
# UNTRANSLATED (L832): LAST=73
# Label only: REPEAT
# UNTRANSLATED (L834): LAST=LAST-1
# UNTRANSLATED (L835): UNTIL LINE(LAST).NE.BLANK
# UNTRANSLATED (L836): LENG=LAST-INIT+1
# EJECT: LSE
# INCLUDE: NIT=7
# Label only: LAST=7
# Label only: LENG=0
# IF
# PROC
# NOTE: 
# NOTE: PRINT LONG LINE
# UNTRANSLATED (L845): PROC LONGPR
# UNTRANSLATED (L846): PERFORM FILOUT
# INCLUDE: F LNOPRT
# Label only: THEN
# NOTE: EL=NELC(OUT,124)
# UNTRANSLATED (L850): WRITE (NPRINT,'(1X,I4,3X,124(A1:))') LINENO,(OUT(KGB),KGB=1,NEL)
# EJECT: LSE
# NOTE: EL=NELC(OUT,124)
# UNTRANSLATED (L853): WRITE(NPRINT,'(8X,124(A1:))') (OUT(KGB),KGB=1,NEL)
# IF
# UNTRANSLATED (L855): PERFORM BLKOUT
# NOTE: OTE =.FALSE.
# PROC
# NOTE: 
# NOTE: PRINT SHORT LINE
# UNTRANSLATED (L860): PROC SHRTPR
# UNTRANSLATED (L861): PERFORM CHECK
# INCLUDE: F LNOPRT
# Label only: THEN
# NOTE: EL=NELC(LINE,80)
# UNTRANSLATED (L865): WRITE (NPRINT,'(1X,I4,3X,80(A1:))') LINENO,(LINE(KGB),KGB=1,NEL)
# EJECT: LSE
# NOTE: EL=NELC(LINE,80)
# UNTRANSLATED (L868): WRITE(NPRINT,'(8X,80(A1:))') (LINE(KGB),KGB=1,NEL)
# IF
# PROC
# NOTE: 
# NOTE: SEQUENCED PRINT
# UNTRANSLATED (L873): PROC SEQPRT
# UNTRANSLATED (L874): SEQNO=SEQNO+1
# UNTRANSLATED (L875): PERFORM CHECK
# NOTE: EL=NELC(LINE,80)
# UNTRANSLATED (L877): WRITE (NPRINT,'(1X,I4,3X,80(A1:))') SEQNO,(LINE(KGB),KGB=1,NEL)
# PROC
# NOTE: 
# NOTE: CHECK FOR END OF PAGE
# UNTRANSLATED (L881): PROC CHECK
# OMCON = COMCON + 1
# NOTE: CHECK FOR PAGE OVERFLOW
# INCLUDE: F COMCON .GE. LINEPP
# Label only: THEN
# NOTE: WRITE PAGE HEADER
# UNTRANSLATED (L887): PERFORM NWPAGE
# IF
# PROC
# NOTE: 
# NOTE: Length of TEXT string
# UNTRANSLATED (L892): PROC TXTLEN
# NOTE: EL=LEN(TEXT)
# UNTRANSLATED (L894): WHILE (NEL.GT.0)
# INCLUDE: F (TEXT(NEL:NEL).EQ.' ')
# Label only: THEN
# NOTE: EL=NEL-1
# EJECT: LSE
# Label only: XWHILE
# IF
# WHILE
# PROC
# NOTE: 
# NOTE: NEW PAGE
# UNTRANSLATED (L905): PROC NWPAGE
# OMCON = 0
# UNTRANSLATED (L907): PAGENO = PAGENO + 1
# UNTRANSLATED (L908): WRITE(NPRINT,'(''1VERSION 5.5 (OCT. 88)'',T58,''SHELTRAN-77'',T122,''PAGE'',I4)') PAGENO
# NOTE: EL=NELC(TITLSV,66)
# INCLUDE: F LSTOPT.LE.2
# Label only: THEN
# UNTRANSLATED (L912): WRITE(NPRINT,'(''0TARGET'',7X,66(A1:))') (TITLSV(KGB),KGB=1,NEL)
# UNTRANSLATED (L913): WRITE(NPRINT,'(/'' STM.NO''/)')
# EJECT: LSE
# UNTRANSLATED (L915): WRITE(NPRINT,'(''0SOURCE'',7X,66(A1:))') (TITLSV(KGB),KGB=1,NEL)
# UNTRANSLATED (L916): WRITE(NPRINT,'(/'' SEQ.NO''/)')
# IF
# PROC
# NOTE: 
# NOTE: WRITE SOURCE LIST TRAILER
# UNTRANSLATED (L921): PROC STAT
# NOTE: WRITE OPTIONS
# UNTRANSLATED (L923): WRITE (NPRINT,401) LINEPP,CHARPL,SOURCE,NBRING
# UNTRANSLATED (L924): LINENO=LINENO+1-START
# UNTRANSLATED (L925): WRITE (NPRINT,406) ERROR,LINENO -1
# INCLUDE: F NWARN.GT.0
# Label only: THEN
# UNTRANSLATED (L928): WRITE(NPRINT,601) NWARN
# IF
# PROC
# NOTE: 
# NOTE: FILL OUTPUT BUFFER
# UNTRANSLATED (L933): PROC FILOUT
# FORTRAN DIRECTIVE: OR I=INIT,LAST
# UNTRANSLATED (L935): OUT(LEVEL)=LINE(I)
# UNTRANSLATED (L936): LEVEL=LEVEL+1
# FOR
# PROC
# NOTE: 
# NOTE: CLEAR OUTPUT BUFFER
# UNTRANSLATED (L941): PROC BLKOUT
# FORTRAN DIRECTIVE: OR I=1,124
# UNTRANSLATED (L943): OUT(I)=BLANK
# FOR
# PROC
# NOTE: 
# NOTE: COLUMNS 2 ... 6
# UNTRANSLATED (L948): PROC CC26
# FORTRAN DIRECTIVE: OR I=6,2,-1
# INCLUDE: F LINE(I).NE.BLANK
# Label only: THEN
# INCLUDE: NIT=I
# IF
# FOR
# UNTRANSLATED (L955): LENG=LAST-INIT+1
# PROC
# EJECT: ND
# NOTE: CLASSIFIES SHELTRAN  STATEMENTS BY THEIR FIRST
# NOTE: SOURCE LINE.
# NOTE: 
# UNTRANSLATED (L961): SUBROUTINE CLASS
# NOTE: 
# Label only: SAVE
# HARACTER*1 NCHAR(80) ,CPARM(66)
# OMMON /BLINE/NCHAR
# OMMON /BPARM/NPARM(66)
# OMMON/CHPARM/ CPARM
# OMMON /BLIST/NPOS,LSTOPT,LINEPP,NPRINT
# UNTRANSLATED (L969): LOGICAL NEXIT
# OMMON /BPARS/NTYPE,NTARGT,NEXIT,NOUT,LUOUT
# NOTE: 
# INCLUDE: NTEGER SUM, KGB
# NOTE: TEMPORARY CHARACTER STORE
# HARACTER*1 CHARI
# HARACTER*1 BLANK,OPBRT,CLBRT
# HARACTER*1 COMMA,AMPST,EQUAL
# INCLUDE: NTEGER POSIT(8),DELIM
# HARACTER*1 KW(4,2)R TO UPPER FUNCTION
# HARACTER*1 LTU
# UNTRANSLATED (L980): LOGICAL COMFLG
# UNTRANSLATED (L981): DATA BLANK/' '/,OPBRT/'('/,CLBRT/')'/
# UNTRANSLATED (L982): DATA COMMA/','/
# UNTRANSLATED (L983): DATA AMPST/'*'/,EQUAL/'='/
# UNTRANSLATED (L984): DATA KW/'E','R','R','=','E','N','D','='/
# EJECT: 
# NOTE: POS = 7
# NOTE: TYPE = KEYWD1(NPOS)
# NOTE: SET PARAMETERS TO ZERO
# FORTRAN DIRECTIVE: OR I=1,66
# NOTE: PARM(I) = 0
# FOR
# NOTE: SUPLEMENTARY CHECKS
# UNTRANSLATED (L993): SELECT NTYPE
# NOTE: FIND CASE PARAMETER
# ASE 15
# UNTRANSLATED (L996): SUM = 0
# Label only: J = 1
# FORTRAN DIRECTIVE: OR N = NPOS,72
# NOTE: OBTAIN WORKING CHARACTER
# INCLUDE: N = DELIM (NCHAR(N))
# NOTE: CLASSIFY CHARACTER
# UNTRANSLATED (L1002): SELECT IN
# NOTE: SKIP IF BLANK
# ASE 1
# NOTE: COMMA
# ASE 4
# INCLUDE: F SUM.EQ.0
# Label only: THEN
# NOTE: SET ERROR AND EXIT
# NOTE: TYPE=101
# Label only: XFOR
# EJECT: LSE
# NOTE: STORE PARAMETER
# NOTE: PARM(J) = SUM
# NOTE: START ON NEXT PARAMETER
# UNTRANSLATED (L1016): J = J + 1
# UNTRANSLATED (L1017): SUM = 0
# IF
# NOTE: DIGIT
# ASE 8,9,10,11,12,13,14,15,16,17
# UNTRANSLATED (L1021): SUM = 10 * SUM + IN - 8
# Label only: OTHER
# NOTE: WRONG CHARACTER: ERROR
# NOTE: TYPE = 101
# Label only: XFOR
# SELECT
# FOR
# NOTE: STORE LAST PARAMETER
# NOTE: PARM(J)=SUM
# NOTE: POS = N
# NOTE: FOR; MUST BE FOLLOWED BY '=' AND AT LEAST 1 COMMA
# ASE 11
# Label only: REPEAT
# NOTE: POS=NPOS+1
# HARI=NCHAR(NPOS)
# UNTRANSLATED (L1036): UNTIL CHARI.EQ.EQUAL.OR.CHARI.EQ.OPBRT.OR.NPOS.GE.70
# INCLUDE: F CHARI.EQ.EQUAL.AND.NPOS.LE.70
# Label only: THEN
# Label only: KGB=0
# Label only: REPEAT
# NOTE: POS=NPOS+1
# HARI=NCHAR(NPOS)
# INCLUDE: F CHARI.EQ.OPBRT
# Label only: THEN
# UNTRANSLATED (L1045): KGB=KGB+1
# EJECT: LSEIF CHARI.EQ.CLBRT
# Label only: THEN
# UNTRANSLATED (L1048): KGB=KGB-1
# IF
# UNTRANSLATED (L1050): UNTIL (CHARI.EQ.COMMA.AND.KGB.EQ.0).OR.(NPOS.GE.72)
# INCLUDE: F CHARI.NE.COMMA.OR.KGB.NE.0
# Label only: THEN
# NOTE: TYPE=2
# IF
# EJECT: LSE
# NOTE: TYPE=2
# IF
# NOTE: SCAN I/O PARAMETERS
# ASE 22
# NOTE: 1=0
# NOTE: KW=0
# Label only: REPEAT
# NOTE: KW=NKW+1
# UNTRANSLATED (L1064): PERFORM ENDERR
# INCLUDE: F KWIND.EQ.5
# Label only: THEN
# NOTE: 1=N1+1
# UNTRANSLATED (L1068): POSIT(N1)=NPER
# IF
# UNTRANSLATED (L1070): UNTIL NKW.EQ.2
# NOTE: END= AND ERR= ABSENT?
# INCLUDE: F N1.EQ.0
# Label only: THEN
# NOTE: --> FORTRAN
# NOTE: TYPE=2
# EJECT: LSE
# NOTE: END= AND ERR= KEYWDS OUT OF ORDER?
# INCLUDE: F N1.EQ.2 .AND. POSIT(1).GT.POSIT(2)
# Label only: THEN
# UNTRANSLATED (L1080): POSIT(3)=POSIT(1)
# UNTRANSLATED (L1081): POSIT(1)=POSIT(2)
# UNTRANSLATED (L1082): POSIT(2)=POSIT(3)
# IF
# NOTE: --> FILL ARRAY NPARM TO BE USED BY THE PARSER
# UNTRANSLATED (L1085): PERFORM PRMFIL
# IF
# NOTE: CALL;IS THERE A '*' ,OTHERWISE FORTRAN
# ASE 30
# NOTE: 1=0
# OMFLG=.TRUE.
# Label only: REPEAT
# NOTE: POS=NPOS+1
# HARI = NCHAR(NPOS)
# UNTRANSLATED (L1094): UNTIL CHARI.EQ.OPBRT.OR.NPOS.GE.70
# NOTE: SCAN FOR SUCCESSIVE '*'S
# Label only: REPEAT
# NOTE: POS=NPOS+1
# HARI = NCHAR(NPOS)
# INCLUDE: F CHARI.EQ.AMPST.AND.NPOS.LE.70
# Label only: THEN
# NOTE: IS '*' PRECEDED BY '(' OR ','
# INCLUDE: F COMFLG
# Label only: THEN
# NOTE: SET LOOP COUNTER FOR PROCEDURE PRMFIL
# NOTE: 1=N1+1
# NOTE: STORE POSITION OF '*'
# UNTRANSLATED (L1107): POSIT(N1)=NPOS
# OMFLG=.FALSE.
# IF
# EJECT: LSE
# INCLUDE: F CHARI.NE.BLANK.AND.COMFLG
# Label only: THEN
# OMFLG=.FALSE.
# EJECT: LSE
# INCLUDE: F CHARI.EQ.COMMA
# Label only: THEN
# NOTE: SET COMMA-FLAG
# OMFLG=.TRUE.
# IF
# IF
# IF
# UNTRANSLATED (L1122): UNTIL N1.EQ.8.OR.NPOS.GE.70
# UNTRANSLATED (L1123): SELECT N1
# NOTE: CALL WITH '*'
# ASE 1,2,3,4,5,6,7
# UNTRANSLATED (L1126): PERFORM PRMFIL
# NOTE: IN FURTHER PROCESSING THERE IS NO DIFFERENCE
# NOTE: BETWEEN READ AND CALL WITH SHELTRAN PARAMETERS
# NOTE: TYPE=22
# NOTE: ONLY 7 '*' PARAMETERS ARE ALLOWED
# ASE 8
# NOTE: SET ERROR-TYPE FOR ERROR-MESSAGE
# NOTE: TYPE=104
# Label only: OTHER
# NOTE: TYPE=2
# SELECT
# Label only: OTHER
# SELECT
# NOTE: STATEMENT CLASSIFIED
# Label only: RETURN
# NOTE: 
# NOTE: DETERMINE POSITION OF END= AND ERR=
# UNTRANSLATED (L1143): PROC ENDERR
# UNTRANSLATED (L1144): KWIND=1
# NOTE: PER=NPOS
# Label only: REPEAT
# NOTE: PER=NPER+1
# INCLUDE: F NCHAR(NPER).EQ.OPBRT
# NOTE: SKIP PARENTHESIZED CONTRUCTS
# Label only: THEN
# UNTRANSLATED (L1151): KWIND=1
# Label only: REPEAT
# NOTE: PER=NPER+1
# UNTRANSLATED (L1154): UNTIL NCHAR(NPER).EQ.CLBRT.OR.NPER.GE.70
# EJECT: LSE
# NOTE: BLANKS ARE INSIGNIFICANT
# INCLUDE: F NCHAR(NPER).NE.BLANK
# Label only: THEN
# INCLUDE: F ( LTU( NCHAR(NPER) ) .EQ. KW(KWIND,NKW) )
# Label only: THEN
# UNTRANSLATED (L1161): KWIND=KWIND+1
# EJECT: LSE
# UNTRANSLATED (L1163): KWIND=1
# IF
# IF
# IF
# UNTRANSLATED (L1167): UNTIL KWIND.EQ.5.OR.NPER.GE.70
# PROC
# NOTE: 
# NOTE: FILL ARRAY NPARM, TO BE USED BY THE PARSER
# UNTRANSLATED (L1171): PROC PRMFIL
# INCLUDE: = 8
# FORTRAN DIRECTIVE: OR N=1,N1
# UNTRANSLATED (L1174): J=(N-1)*9
# INCLUDE: =I-1
# NOTE: SET BEGIN POINTER
# NOTE: PARM(J+2)=I
# NOTE: SET END POINTER
# NOTE: PARM(J+3)=POSIT(N)
# INCLUDE: =POSIT(N)+1
# NOTE: SAVE POINTER FOR PROC NAME COPY
# UNTRANSLATED (L1182): L = I - 4
# NOTE: LOOKUP KIND
# UNTRANSLATED (L1184): M = KEYWD2(I)
# NOTE: SET KIND
# NOTE: PARM(J+1)=M
# INCLUDE: F M.EQ.6
# NOTE: PROCEDURE NAME
# Label only: THEN
# NOTE: COPY PROC NAME
# Label only: K = 4
# UNTRANSLATED (L1192): WHILE K .LE. 34
# INCLUDE: F K .LT. I - L - 1
# Label only: THEN
# NOTE: DO NOT COPY BLANKS
# HARI = LTU( NCHAR(K+L) )
# INCLUDE: F CHARI.NE.BLANK
# Label only: THEN
# PARM(J+K)=CHARI
# EJECT: LSE
# UNTRANSLATED (L1201): K = K - 1
# UNTRANSLATED (L1202): L = L + 1
# IF
# EJECT: LSE
# NOTE: TRAIL WITH BLANKS
# PARM(J+K)=BLANK
# IF
# UNTRANSLATED (L1208): K = K + 1
# WHILE
# IF
# FOR
# Label only: J=J+9
# NOTE: PARM(J+1)=0
# NOTE: PARM(J+2)=I-1
# NOTE: SET END POINTER
# NOTE: PARM(J+3)=72
# NOTE: POS = I
# PROC
# EJECT: ND
# NOTE: CLASSIFY STRING OF CHARACTERS AS ONE OF A SET OF
# NOTE: KEYWORDS
# NOTE: 
# FORTRAN DIRECTIVE: UNCTION KEYWD1(POS)
# NOTE: 
# HARACTER*1 NCHAR(80)
# OMMON /BLINE/NCHAR
# HARACTER*1 CHARI
# HARACTER*1 BLANK,OPBRT,CLBRT,EQUAL,COMMA
# INCLUDE: NTEGER POS
# HARACTER*1 TREE(156)
# INCLUDE: NTEGER MATCH(156),FAIL(156)R TO UPPER FUNCTION
# HARACTER*1 LTU
# UNTRANSLATED (L1233): DATA BLANK/' '/,OPBRT/'('/,CLBRT/')'/,EQUAL/'='/,COMMA/','/
# EJECT: 1   2   3   4   5   6   7   8   9  10
# NOTE: TREE
# UNTRANSLATED (L1236): 0DATA  TREE  / 'I','F','T','H','E','N','E','L','S','E',              'N','T','R','Y','D',' ','A','L','L','S',              'E','I','F','W','H','I','L','E','P','R',              'O','C','F','O','R','S','E','L','E','C',              'T','P','E','R','F','O','R','M','R','O',              'C','W','H','I','L','E','F','O','R',' ',              ' ',' ','(','S','E','L','E','C','T','T',              'O','P','R','E','P','E','A','T','T','U',              'R','N','A','D','X','W','H','I','L','E',              'F','O','R','R','E','P','E','A','T','U',              'N','T','I','L','O','T','H','E','R',' ',              'B','A','C','K','S','P','A','C','E','(',              'C','L','O','S','E','(','P','E','N','(',              'F','I','L','E','(','N','Q','U','I','R',              'E','(','R','I','T','E','(','W','I','N',              'D','(','I','F','I','F'/
# NOTE: MATCH POINTERS
# UNTRANSLATED (L1238): 0DATA  MATCH /   2,110,  4,  5,  6, -5,  8,  9, 10,155,               12, 13, 14,-27,131,000, 18, 19,-30, 21,              -15, 23, -7, 25, 26, 27, 28,-10, 30, 31,               32,-24, 34, 35,-13, 37, 38, 39, 40, 41,              -17, 43, 44, 45, 46, 47, 48,-21, 50, 51,              -23, 53, 54, 55, 56, 60, 58, 59,-11, -8,              -14,-18,-22, 65, 66, 67, 68, 69, 61, 71,               72,-26, 74, 75, 76, 77, 78,-20, 80, 81,               82,-25, 84, 63, 86, 87, 88, 89, 90, -9,               92, 93,-12, 95, 96, 97, 98, 99,-19,101,              102,103,104, 62,106,107,108,109,-16, -4,              112,113,114,115,116,117,118,119,120,-22,              122,123,124,125,126,-22,128,129,130,-22,              132,133,134,135,-22,137,138,139,140,141,              142,-22,144,145,146,147,-22,149,150,151,              152,-22,154, -7,156,-31/
# NOTE: FAIL POINTERS
# UNTRANSLATED (L1240): 0DATA  FAIL  /   3,136,  7, -2, -2, -2,121, 11, -2, -2,               -2, 15, -2, -2, -2,000, 22, 20, -2, -2,               -2, 24, -2, 29, -2, -2, -2, -2, 33, -2,               -2, -2, 36, -2, -2, -2, -2, -2, -2, -2,               -2, 52, 49, -2, -2, -2, -2, -2, -2, -2,               -2, 57,143, -2, -2, -2, 64, -2, -2, -2,               -2, -2, -2, 73, 70, -2, -2, -2, -2, -2,               -2, -2, 85, -2, 79, -2, -2, -2, 83, -2,               -2, -2,148, -2,100, 91, -2, -2, -2, -2,               94, -2, -2, -2, -2, -2, -2, -2, -2,105,               -2, -2, -2, -2,111,127, -2, -2, -2, -2,               -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,               42, 17, -2, -2, -2, -2, -2, -2, -2, -2,              153, -2, -2, -2, -2, -2, -2, -2, -2, -2,               -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,               -2, -2,-28, -2, -6, -2/
# EJECT: 
# NOTE: 
# NOTE: ................................................................
# NOTE: 
# NOTE: SHELTRAN KEYWORDS**************
# NOTE: *                                                                     *
# NOTE: *    SORTS STATEMENTS INTO  31 CLASSES                                *
# NOTE: *                                                                     *
# NOTE: *    TYPE CODES -                                                     *
# NOTE: *                                                                     *
# NOTE: 01 COMMENT  2 FORTRAN    3 CONTINUATION  4 IF
# NOTE: 05 THEN     6 ELSE       7 CIF           8 WHILE
# NOTE: 09 XWHILE  10 CWHILE    11 FOR          12 XFOR
# NOTE: 13 CFOR    14 SELECT    15 CASE         16 OTHER
# NOTE: 17 CSELECT 18 UNTIL     19 XREPEAT      20 REPEAT
# NOTE: 21 PERFORM 22 READ      23 PROC         24 CPROC
# NOTE: 25 RETURN  26 STOP      27 ENTRY        28 END
# NOTE: 29 FORMAT  30 CALL      22 OPEN(        22 ENDFILE(
# NOTE: 22 INQUIRE 22 WRITE     22 CLOSE(       22 BACKSPACE(
# NOTE: 22 REWIND(  7 ENDIF     31 ELSEIF=101 ERROR
# NOTE: *                                                                     *
# EJECT: 
# NOTE: K E Y W O R D        CLASS   ENTRY
# NOTE: 
# NOTE: I F                    4       1
# NOTE: . N Q U I R E (       22     136
# NOTE: T H E N                5       3
# NOTE: E L S E                6       7
# NOTE: . . . . I F           31     153
# NOTE: . N T R Y             27      11
# NOTE: . . D                 28      15
# NOTE: . . . F I L E (       22     131
# NOTE: . . . I F              7     155
# NOTE: C L O S E (           22     121
# NOTE: . A L L               30      17
# NOTE: . . S E               15      20
# NOTE: . I F                  7      22
# NOTE: . W H I L E           10      24
# NOTE: . P R O C             24      29
# NOTE: . F O R               13      33
# NOTE: . S E L E C T         17      36
# NOTE: P E R F O R M         21      42
# NOTE: . R O C               23      49
# NOTE: W H I L E              8      52
# NOTE: . R I T E (           22     143
# NOTE: F O R                 11      57
# NOTE: S E L E C T           14      64
# NOTE: . T O P               26      70
# NOTE: R E P E A T           20      73
# NOTE: . . T U R N           25      79
# NOTE: . . W I N D (         22     148
# NOTE: . . A D (             22      83
# NOTE: X W H I L E            9      85
# NOTE: . F O R               12      91
# NOTE: . R E P E A T         19      94
# NOTE: U N T I L             18     100
# NOTE: O T H E R             16     105
# NOTE: . P E N (             22     127
# NOTE: B A C K S P A C E (   22     111
# NOTE: 
# EJECT: 
# Label only: J = 1
# INCLUDE: = POS
# NOTE: SCAN UNTIL END OF LINE
# UNTRANSLATED (L1305): WHILE  I .LE. 72
# HARI = LTU( NCHAR(I) )
# NOTE: CLASSIFY CHARACTER,
# INCLUDE: F CHARI.EQ.TREE(J)
# Label only: THEN
# NOTE: MATCH, TAKE NEXT CHARACTER,
# UNTRANSLATED (L1311): J = MATCH(J)
# INCLUDE: = I + 1
# EJECT: LSE
# NOTE: SKIP BLANKS
# INCLUDE: F CHARI.EQ.BLANK
# Label only: THEN
# INCLUDE: = I + 1
# EJECT: LSE
# NOTE: NO MATCH,  TRY AGAIN
# UNTRANSLATED (L1320): J = FAIL(J)
# IF
# IF
# NOTE: IF END OF TREE,
# INCLUDE: F  J .LE. 0
# Label only: THEN
# NOTE: RETURN CLASS VALUE AND STOP
# UNTRANSLATED (L1327): KEYWD1=-J
# Label only: XWHILE
# IF
# WHILE
# NOTE: IF AT END OF LINE WHILE END OF
# NOTE: TREE NOT YET BEEN REACHED,
# INCLUDE: F  J .GE. 0
# Label only: THEN
# INCLUDE: F J.EQ.1.AND.NCHAR(6).EQ.BLANK
# Label only: THEN
# NOTE: BLANK LINE; TREAT AS COMMENT
# UNTRANSLATED (L1338): KEYWD1=110
# EJECT: LSE
# NOTE: SCAN REMAINDER OF FAIL POINTERS
# UNTRANSLATED (L1341): WHILE J.GT.0
# NOTE: UNTIL STMT CLASSIFIED
# UNTRANSLATED (L1343): J=FAIL(J)
# WHILE
# UNTRANSLATED (L1345): KEYWD1=-J
# IF
# IF
# NOTE: 
# NOTE: 
# UNTRANSLATED (L1350): SELECT KEYWD1
# NOTE: THEN,ELSE,CIF,XWHILE,CWHILE,XFOR,CFOR,OTHER,
# ASE 5,6,7,9,10,12,13,16,17,19,20,24,25,28
# NOTE: CSELECT,XREPEAT,REPEAT,CPROC,RETURN,END,
# UNTRANSLATED (L1354): WHILE I.LE.72
# NOTE: ENDIF.
# HARI = NCHAR(I)
# INCLUDE: F CHARI.EQ.BLANK
# Label only: THEN
# INCLUDE: =I+1
# EJECT: LSE
# INCLUDE: F KEYWD1.EQ.25.AND.CHARI.NE.OPBRT.AND.CHARI.NE.EQUAL
# Label only: THEN
# NOTE: RETURN NOT FOLLOWED BY'='OR'(': ILLEGAL STMT
# UNTRANSLATED (L1364): KEYWD1=101
# EJECT: LSE
# NOTE: ASSUME FORTRAN STMT IF NOT FOLLOWED BY BLANKS
# UNTRANSLATED (L1367): KEYWD1=2
# IF
# Label only: XWHILE
# IF
# WHILE
# NOTE: CASE,PERFORM,PROC,STOP,ENTRY
# ASE 15,21,23,26,27
# INCLUDE: F I.LE.72
# Label only: THEN
# FORTRAN DIRECTIVE: OR J=I,72
# HARI=NCHAR(J)
# INCLUDE: F CHARI.EQ.EQUAL
# Label only: THEN
# UNTRANSLATED (L1380): KEYWD1=2
# Label only: XFOR
# IF
# FOR
# EJECT: LSE
# NOTE: CASE,PERFORM AND PROC MUST BE FOLLOWED BY AT LEAST
# INCLUDE: F KEYWD1.LE.23
# NOTE: ONE CHARACTER
# Label only: THEN
# UNTRANSLATED (L1389): KEYWD1=2
# IF
# IF
# NOTE: 2       4  8     14     18    22    30   11
# NOTE: FORTRAN,IF,WHILE,SELECT,UNTIL,READ(,CALL,FOR
# NOTE: 22      22      22     22     22    22
# NOTE: INQUIRE,ENDFILE,CLOSE(,WRITE(,OPEN(,BACKSPACE(
# NOTE: 31
# NOTE: ELSEIF
# Label only: OTHER
# SELECT
# NOTE: 
# NOTE: RETURN NEXT SCAN POSITION
# UNTRANSLATED (L1402): POS = I
# Label only: RETURN
# EJECT: ND
# NOTE: CLASSIFY STRING OF CHARACTERS AS ONE OF A SET OF
# NOTE: KEYWORDS AFTER END=,ERR= (I/O) OR * (CALL)
# FORTRAN DIRECTIVE: UNCTION KEYWD2(POS)
# NOTE: 
# HARACTER*1 NCHAR(80)
# OMMON /BLINE/NCHAR
# HARACTER*1 CHARI
# HARACTER*1 BLANK,OPBRT,CLBRT,EQUAL,COMMA
# INCLUDE: NTEGER POS
# HARACTER*1 TREE(35)
# INCLUDE: NTEGER MATCH(35),FAIL(35)R TO UPPER FUNCTION
# HARACTER*1 LTU
# UNTRANSLATED (L1417): DATA BLANK/' '/,OPBRT/'('/,CLBRT/')'/,EQUAL/'='/,COMMA/','/
# EJECT: 1   2   3   4   5   6   7   8   9  10
# NOTE: TREE
# UNTRANSLATED (L1420): DATA  TREE  / 'X','F','O','R',',',')','W','H','I','L',              'E',',',')','R','E','T','U','R','N',',',              ')','S','T','O','P',',',')','R','E','P',              'E','A','T',',',')'/
# NOTE: MATCH POINTERS
# UNTRANSLATED (L1422): DATA  MATCH /   2,  3,  4,  5, -3, -3,  8,  9, 10, 11,               12, -4, -4, 15, 16, 17, 18, 19, 20, -1,               -1, 23, 24, 25, 26, -2, -2, 29, 30, 31,               32, 33, 34, -5, -5/
# NOTE: FAIL POINTERS
# UNTRANSLATED (L1424): DATA  FAIL  /  14,  7, -6, -6,  6, -6, 28, -6, -6, -6,               -6, 13, -6, 22, -6, -6, -6, -6, -6, 21,               -6, -6, -6, -6, -6, 27, -6, -6, -6, -6,               -6, -6, -6, 35, -6/
# NOTE: IN THE FOLLOWING TABLE * STANDS FOR ',' OR ')'
# NOTE: 
# NOTE: K E Y W O R D    CLASS  ENTRY
# NOTE: 
# NOTE: X F O R *         3       1
# NOTE: . W H I L E *     4       7
# NOTE: . R E P E A T *   5      28
# NOTE: R E T U R N *     1      14
# NOTE: S T O P *         2      22
# NOTE: 
# EJECT: 
# Label only: J = 1
# INCLUDE: = POS
# NOTE: SCAN UNTIL END OF LINE
# UNTRANSLATED (L1439): WHILE  I .LE. 72
# HARI = LTU( NCHAR(I) )
# NOTE: SKIP BLANKS
# INCLUDE: F CHARI.EQ.BLANK
# Label only: THEN
# INCLUDE: = I + 1
# EJECT: LSE
# NOTE: CLASSIFY CHARACTER,
# INCLUDE: F CHARI.EQ.TREE(J)
# Label only: THEN
# NOTE: MATCH, TAKE NEXT CHARACTER,
# UNTRANSLATED (L1450): J = MATCH(J)
# INCLUDE: = I + 1
# EJECT: LSE
# NOTE: NO MATCH,  TRY AGAIN
# UNTRANSLATED (L1454): J = FAIL(J)
# IF
# NOTE: IF END OF TREE,
# INCLUDE: F  J .LE. 0
# Label only: THEN
# NOTE: RETURN CLASS VALUE AND STOP
# UNTRANSLATED (L1460): KEYWD2=-J
# Label only: XWHILE
# IF
# IF
# WHILE
# NOTE: IF AT END OF LINE WHILE END OF
# NOTE: TREE NOT YET BEEN REACHED,
# INCLUDE: F  J .GE. 0
# Label only: THEN
# NOTE: ASSUME PROCEDURE NAME
# UNTRANSLATED (L1470): KEYWD2=6
# IF
# NOTE: 
# NOTE: 
# NOTE: IF NO KEYWORD FOUND, CONTINUE
# INCLUDE: F  J .EQ. -6
# Label only: THEN
# NOTE: SCAN UNTIL , OR )
# UNTRANSLATED (L1478): WHILE  I .LE. 72
# HARI = NCHAR(I)
# INCLUDE: = I + 1
# INCLUDE: F CHARI.EQ.COMMA .OR. CHARI.EQ.CLBRT
# Label only: THEN
# Label only: XWHILE
# IF
# WHILE
# IF
# NOTE: 
# NOTE: RETURN NEXT SCAN POSITION
# UNTRANSLATED (L1489): POS = I
# Label only: RETURN
# EJECT: ND
# NOTE: DELIM
# NOTE: CLASSIFY CHARACTER AS ONE OF A SET OF DELIMITERS
# NOTE: 
# INCLUDE: NTEGER FUNCTION  DELIM (CHARI)
# NOTE: 
# NOTE: 
# HARACTER*1 IDELIM(17),CHARI
# UNTRANSLATED (L1499): DATA       IDELIM  / ' ','(',')',',','=','/',' ',                     '0','1','2','3','4','5','6','7','8','9' /
# UNTRANSLATED (L1500): DELIM = 0
# NOTE: LOOP OVER ARRAY OF DELIMITERS
# FORTRAN DIRECTIVE: OR  I = 1,17
# INCLUDE: F CHARI.EQ.IDELIM(I)
# Label only: THEN
# NOTE: RETURN INDEX AS FUNCTION VALUE
# UNTRANSLATED (L1506): DELIM = I
# Label only: XFOR
# IF
# FOR
# Label only: RETURN
# EJECT: ND
# NOTE: PARSER
# NOTE: CHECKS THE SYNTAX OF SHELTRAN SOURCE,AND GENERATES
# NOTE: FORTRAN 77 STATEMENTS FOR IT.
# NOTE: THE PARSER IS A FINITE STATE MACHINE
# NOTE: 
# UNTRANSLATED (L1517): SUBROUTINE PARSER
# Label only: SAVE
# NOTE: 
# NOTE: NUMBER OF TYPES -- NUMBER OF POSSIBLE STATES
# NOTE: -- STACK DEPTH
# UNTRANSLATED (L1522): PARAMETER (NTYPES=30,NSTATE=17,NSTACK=32)
# UNTRANSLATED (L1523): LOGICAL NEXIT
# HARACTER*1 LINE(80),CPARM(66)
# OMMON /BLINE/LINE
# OMMON /BPARM/NPARM(66)
# OMMON/CHPARM/ CPARM
# INCLUDE: NTEGER TYPE
# OMMON /BPARS/TYPE,NTARGT,NEXIT,NOUT,LUOUT
# NOTE: EXIT FLAG
# UNTRANSLATED (L1531): LOGICAL RETFL
# UNTRANSLATED (L1532): LOGICAL STPFL
# NOTE: 
# INCLUDE: NTEGER LAB(7)
# NOTE: STATE INDICATOR
# INCLUDE: NTEGER   STATE
# NOTE: STATE STACK POINTER
# INCLUDE: NTEGER   STPTR
# NOTE: STATE STACK
# INCLUDE: NTEGER   STSTK(NSTACK)
# NOTE: STATE ACTION TABLE
# INCLUDE: NTEGER ACTAB(NSTATE,NTYPES)
# INCLUDE: NTEGER PART1(NSTATE,15),PART2(NSTATE,NTYPES-15)
# EJECT: QUIVALENCE (ACTAB(1,1),PART1(1,1))
# EJECT: QUIVALENCE (ACTAB(1,16),PART2(1,1))
# UNTRANSLATED (L1546): DATA RETFL/.TRUE./,STPFL/.TRUE./
# UNTRANSLATED (L1547): DATA STATE/1/,STPTR/0/
# NOTE: 
# NOTE: 
# UNTRANSLATED (L1550): DATA PART1/
#          1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
# 
# NOTE: FORTRAN LINE    7,48,48, 7,48, 7,33, 7,37, 7, 7, 7,28,39, 7, 7,34
# NOTE: CONTINUATION LINE    9,48,48, 9,48, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
# NOTE: IF   29,48,48,29,48,29,33,29,37,29,29,29,28,39,29,29,34,
# NOTE: THEN    0,48,48, 0,48, 0,33, 0,37, 0, 0, 0,28,30, 0, 0,34,
# NOTE: ELSE    0,48,20, 0,48, 0,33, 0,37, 0, 0, 0,28,39,31, 0,34,
# NOTE: CIF    0,48,20, 0,48, 0,33, 0,37, 0, 0, 0,28,39,32,32,34,
# NOTE: WHILE   19,48,48,19,48,19,33,19,37,19,19,19,28,39,19,19,34,
# NOTE: XWHILE    3,48,48, 0,48, 3,33, 3,37, 3, 3, 3,28,39, 3, 3,34,
# NOTE: CWHILE    0,48,20, 0,48, 0,33,21,37, 0, 0, 0,28,39, 0, 0,34,
# NOTE: FOR   17,48,48,17,48,17,33,17,37,17,17,17,28,39,17,17,34,
# NOTE: XFOR    4,48,48, 0,48, 4,33, 4,37, 4, 4, 4,28,39, 4, 4,34,
# NOTE: CFOR    0,48,20, 0,48,18,33, 0,37, 0, 0, 0,28,39, 0, 0,34,
# NOTE: SELECT   22,48,48,22,48,22,33,22,37,22,22,22,28,39,22,22,34,
# NOTE: CASE    0,48,20, 0,48, 0,33, 0,13,23, 0, 0,28,39, 0, 0,34,
# NOTE: OTHER    0,48,20, 0,48, 0,33, 0,37,24, 0, 0,28,39, 0, 0,34/
# EJECT: 
# UNTRANSLATED (L1569): DATA PART2/
#          1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
# 
# NOTE: CSELECT    0,48,20, 0,48, 0,33, 0,37, 0,25, 0,28,39, 0, 0,34,
# NOTE: UNTIL    0,48,20, 0,48, 0,33, 0,37, 0, 0,27,28,39, 0, 0,34,
# NOTE: XREPEAT    6,48,48, 0,48, 6,33, 6,37, 6, 6, 6,28,39, 6, 6,34,
# NOTE: REPEAT   26,48,48,26,48,26,33,26,37,26,26,26,28,39,26,26,34,
# NOTE: PERFORM    1,48,48, 1,48, 1,33, 1,37, 1, 1, 1,28,39, 1, 1,34,
# NOTE: I/O STATEMENT    2,48,48, 2,48, 2,33, 2,37, 2, 2, 2,28,39, 2, 2,34
# NOTE: PROC   12,14,48,40,14, 0,33, 0,37, 0, 0, 0,28,39, 0, 0,34,
# NOTE: CPROC    0,48,48,15,48, 0,33, 0,37, 0, 0, 0,28,39, 0, 0,34,
# NOTE: RETURN   11,48,48, 0,48, 5,33, 5,37, 5, 5, 5,28,39, 5, 5,34,
# NOTE: STOP   11,48,48, 0,48, 5,33, 5,37, 5, 5, 5,28,39, 5, 5,34,
# NOTE: ENTRY   12,10,48,40,48, 0,33, 0,37, 0, 0, 0,28,39, 0, 0,34,
# NOTE: END   12,16,20,40,16,41,33,42,37,43,44,45,28,39,46,46,34,
# NOTE: FORMAT    7, 7, 0, 7, 7, 7,33, 7,37, 7, 7, 7,28,39, 7, 7,34,
# NOTE: 'SPECIAL'    0, 1, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
# NOTE: ELSEIF    0,48,20, 0,48, 0,33, 0,37, 0, 0, 0,28,39,35, 0,34/
# NOTE: 
# NOTE: 
# NOTE: EXIT=.FALSE.
# Label only: RETURN
# EJECT: 
# EJECT: NTRY PARSE
# NOTE: 
# NOTE: 
# UNTRANSLATED (L1595): WHILE .TRUE.
# UNTRANSLATED (L1596): SELECT ACTAB(STATE,TYPE-1)
# ASE 1
# NOTE: ***   PERFORM   STATEMENT
# ALL PFORM
# Label only: XWHILE
# ASE 2
# NOTE: ***   READ      STATEMENT
# UNTRANSLATED (L1603): PERFORM DOREAD
# UNTRANSLATED (L1604): PERFORM STACK
# UNTRANSLATED (L1605): STATE = 17
# Label only: XWHILE
# ASE 3
# NOTE: ***   XWHILE    STATEMENT
# UNTRANSLATED (L1609): PERFORM STACK
# UNTRANSLATED (L1610): STATE = 3
# ALL LEAVE
# Label only: XWHILE
# ASE 4
# NOTE: ***   XFOR      STATEMENT
# UNTRANSLATED (L1615): PERFORM STACK
# UNTRANSLATED (L1616): STATE = 3
# ALL DOEXIT
# Label only: XWHILE
# ASE 5
# NOTE: ***   RETURN    STATEMENT
# NOTE: ***   STOP      STATEMENT
# UNTRANSLATED (L1622): PERFORM STACK
# UNTRANSLATED (L1623): STATE = 3
# ALL CARD
# Label only: XWHILE
# ASE 6
# NOTE: ***  XREPEAT    STATEMENT
# UNTRANSLATED (L1628): PERFORM STACK
# UNTRANSLATED (L1629): STATE = 3
# ALL XUNTIL
# Label only: XWHILE
# ASE 7
# NOTE: ***   FORTRAN   STATEMENT
# ALL CARD
# Label only: XWHILE
# ASE 9
# NOTE: CONTINUATION LINE
# ALL CCARD
# Label only: XWHILE
# ASE 10
# NOTE: ***   ENTRY     STATEMENT
# UNTRANSLATED (L1642): STATE = 1
# ALL CARD
# NOTE: CLEAR EXIT FLAG
# NOTE: EXIT = .FALSE.
# Label only: XWHILE
# ASE 11
# NOTE: ***   RETURN    STATEMENT
# NOTE: ***   STOP      STATEMENT
# UNTRANSLATED (L1650): STATE = 2
# ALL CARD
# Label only: XWHILE
# ASE 12
# NOTE: ***   END AT WRONG PLACE
# NOTE: ERROR HANDLING
# ALL ERRMSG('STOP OR RETURN ARE MISSING                        ')
# UNTRANSLATED (L1657): STATE = 2
# ASE 13
# NOTE: ***   STATEMENT  AFTER SELECT
# UNTRANSLATED (L1660): STATE = 10
# ALL CONSEL
# Label only: XWHILE
# ASE 14
# NOTE: ***   PROC      STATEMENT
# UNTRANSLATED (L1665): STATE = 4
# ALL PROC
# Label only: XWHILE
# ASE 15
# NOTE: ***   CPROC      STATEMENT
# UNTRANSLATED (L1670): STATE = 5
# ALL PEND
# Label only: XWHILE
# ASE 16
# NOTE: ***   END       STATEMENT
# UNTRANSLATED (L1675): PERFORM END
# Label only: XWHILE
# ASE 17
# NOTE: ***   FOR       STATEMENT
# UNTRANSLATED (L1679): PERFORM STACK
# UNTRANSLATED (L1680): STATE = 6
# ALL FOR
# Label only: XWHILE
# ASE 18
# NOTE: ***   CFOR      STATEMENT
# UNTRANSLATED (L1685): PERFORM UNSTK
# ALL NEXT
# Label only: XWHILE
# ASE 19
# NOTE: ***   WHILE     STATEMENT
# UNTRANSLATED (L1690): PERFORM STACK
# UNTRANSLATED (L1691): STATE = 7
# ALL DOWHI
# Label only: XWHILE
# ASE 20
# NOTE: ***   AFTER XFOR,XWHILE,RETURN, STOP
# NOTE: OR XREPEAT
# UNTRANSLATED (L1697): PERFORM UNSTK
# NOTE: SET EXIT FLAG
# NOTE: EXIT = .TRUE.
# ASE 21
# NOTE: ***   CWHILE    STATEMENT
# UNTRANSLATED (L1702): PERFORM UNSTK
# ALL REP EAT
# Label only: XWHILE
# ASE 22
# NOTE: ***   SELECT    STATEMENT
# UNTRANSLATED (L1707): PERFORM STACK
# UNTRANSLATED (L1708): STATE = 9
# ALL DOSEL
# Label only: XWHILE
# ASE 23
# NOTE: ***   CASE      STATEMENT
# ALL DOCASE
# NOTE: CLEAR EXIT FLAG
# NOTE: EXIT = .FALSE.
# Label only: XWHILE
# ASE 24
# NOTE: ***   OTHER     STATEMENT
# UNTRANSLATED (L1719): STATE = 11
# ALL OTHER
# NOTE: CLEAR EXIT FLAG
# NOTE: EXIT = .FALSE.
# Label only: XWHILE
# ASE 25
# NOTE: ***   CSELECT    STATEMENT
# UNTRANSLATED (L1726): PERFORM UNSTK
# ALL REVERT
# Label only: XWHILE
# ASE 26
# NOTE: ***  REPEAT STATEMENT
# UNTRANSLATED (L1731): PERFORM STACK
# UNTRANSLATED (L1732): STATE = 12
# ALL C UNTIL
# Label only: XWHILE
# ASE 27
# NOTE: ***  UNTIL STATEMENT
# UNTRANSLATED (L1737): STATE = 13
# ALL DO UNTL
# Label only: XWHILE
# ASE 28
# NOTE: ***  STATEMENT AFTER UNTIL
# UNTRANSLATED (L1742): PERFORM UNSTK
# ALL CO UNTL
# ASE 29
# NOTE: ***   IF        STATEMENT
# UNTRANSLATED (L1746): PERFORM STACK
# UNTRANSLATED (L1747): STATE = 14
# ALL DOIF
# Label only: XWHILE
# ASE 30
# NOTE: ***   THEN      STATEMENT
# UNTRANSLATED (L1752): STATE = 15
# ALL THEN
# Label only: XWHILE
# ASE 31
# NOTE: ***   ELSE      STATEMENT
# UNTRANSLATED (L1757): STATE = 16
# ALL ELSE
# NOTE: CLEAR EXIT FLAG
# NOTE: EXIT = .FALSE.
# Label only: XWHILE
# ASE 32
# NOTE: ***   CIF       STATEMENT
# UNTRANSLATED (L1764): PERFORM UNSTK
# ALL FIN
# Label only: XWHILE
# ASE 33
# NOTE: ***   STATEMENT AFTER WHILE
# UNTRANSLATED (L1769): STATE = 8
# ALL CWHILE
# NOTE: ***   FIRST STATEMENT AFTER READ
# ASE 34
# UNTRANSLATED (L1773): PERFORM UNSTK
# ALL COREAD
# NOTE: ***   ELSEIF STATEMENT
# ASE 35
# UNTRANSLATED (L1777): STATE=14
# ALL ELSEIF
# NOTE: EXIT=.FALSE.
# Label only: XWHILE
# NOTE: ***   ERROR HANDLING
# NOTE: & ERROR RECOVERING
# ASE 37
# ALL ERRMSG('SELECT REJECTED, NOT FOLLOWED BY CASE             ')
# ALL REVERT
# UNTRANSLATED (L1786): PERFORM UNSTK
# ASE 39
# ALL ERRMSG('IF REJECTED, NOT FOLLOWED BY THEN                 ')
# ALL FIN
# UNTRANSLATED (L1790): PERFORM UNSTK
# ASE 40
# ALL ERRMSG('CPROC IS MISSING                                  ')
# UNTRANSLATED (L1793): STATE = 5
# ALL PEND
# ASE 41
# ALL ERRMSG('CFOR IS MISSING                                   ')
# UNTRANSLATED (L1797): PERFORM UNSTK
# ALL NEXT
# ASE 42
# ALL ERRMSG('CWHILE IS MISSING                                 ')
# UNTRANSLATED (L1801): PERFORM UNSTK
# ALL REP EAT
# ASE 43
# UNTRANSLATED (L1804): STATE = 11
# ALL ERRMSG('OTHER IS MISSING                                  ')
# ALL OTHER
# NOTE: EXIT = .FALSE.
# ASE 44
# ALL ERRMSG('CSELECT IS MISSING                                ')
# UNTRANSLATED (L1810): PERFORM UNSTK
# ALL REVERT
# ASE 45
# ALL ERRMSG('UNTIL IS MISSING                                  ')
# UNTRANSLATED (L1814): PERFORM UNSTK
# ALL CO UNTL
# ASE 46
# ALL ERRMSG('CIF IS MISSING                                    ')
# UNTRANSLATED (L1818): PERFORM UNSTK
# ALL FIN
# ASE 48
# ALL ERRMSG('STATEMENT CANNOT BE REACHED                       ')
# UNTRANSLATED (L1822): STATE=STATE-ACTAB(STATE,29)
# Label only: XWHILE
# Label only: OTHER
# NOTE: ***  ERROR
# UNTRANSLATED (L1826): STATE=STATE-ACTAB(STATE,29)
# ALL ERRMSG('ILLEGAL IN THIS CONTEXT                           ')
# Label only: XWHILE
# SELECT
# WHILE
# Label only: RETURN
# EJECT: 
# UNTRANSLATED (L1833): PROC STACK
# UNTRANSLATED (L1834): STPTR = STPTR + 1
# NOTE: CHECK STACK OVERFLOW
# INCLUDE: F STPTR .GT. NSTACK
# Label only: THEN
# ALL ERRMSG('NESTING TOO DEEP; FATAL ERROR                     ')
# ALL ABORT
# IF
# NOTE: ASSIGN NEW STATE
# UNTRANSLATED (L1842): STSTK(STPTR) = STATE
# PROC
# NOTE: 
# NOTE: UNSTACK STATE
# UNTRANSLATED (L1846): PROC UNSTK
# NOTE: ASSIGN NEW STATE
# UNTRANSLATED (L1848): STATE = STSTK(STPTR)
# UNTRANSLATED (L1849): STPTR = STPTR - 1
# NOTE: CLEAR EXIT FLAG
# NOTE: EXIT = .FALSE.
# PROC
# NOTE: 
# NOTE: END STATEMENT HANDLING
# UNTRANSLATED (L1855): PROC END
# UNTRANSLATED (L1856): STATE = 1
# NOTE: CLEAR THE MACHINES
# ALL CCLEAR
# ALL LCLEAR
# ALL PCLEAR
# ALL UCLEAR
# ALL WCLEAR
# NOTE: CLEAR EXIT FLAG
# NOTE: EXIT = .FALSE.
# UNTRANSLATED (L1865): RETFL = .TRUE.
# UNTRANSLATED (L1866): STPFL = .TRUE.
# UNTRANSLATED (L1867): STPTR=0
# NOTE: PASS STATEMENT TO OUTPUT
# ALL CARD
# NOTE: WRITE SEGMENT TRAILER
# ALL TRAIL
# PROC
# EJECT: 
# NOTE: LABEL IN I/O STMT OR CALL
# UNTRANSLATED (L1875): PROC DOREAD
# NOTE: 
# NOTE: MAP OF NPARM
# NOTE: ------------
# NOTE: NPARM(1)        KIND
# NOTE: NPARM(2)        7
# NOTE: NPARM(3)        POSITION OF '=' OR '*'  OR 72
# NOTE: CPARM(4-9)      PROC NAME
# NOTE: NPARM(10)       KIND
# NOTE: NPARM(11)       POSITION OF ',' OR ')'
# NOTE: NPARM(12)       POSITION OF '=' OR '*'  OR 72
# NOTE: CPARM(13-18)    PROC NAME
# NOTE: ETC.
# NOTE: NPARM(64)       0
# NOTE: NPARM(65)       POSITION OF ',' OR ')'
# NOTE: NPARM(66)       72
# NOTE: 
# NOTE: KIND INDICATION
# NOTE: 0     NO EXIT PARAMETER
# NOTE: 1     RETURN
# NOTE: 2     STOP
# NOTE: 3     XFOR
# NOTE: 4     XWHILE
# NOTE: 5     XREPEAT
# NOTE: 6     PROC NAME
# NOTE: 
# Label only: J = 1
# Label only: JJ=1
# UNTRANSLATED (L1903): WHILE NPARM(JJ).GT.0
# UNTRANSLATED (L1904): SELECT NPARM(JJ)
# NOTE: RETURN
# ASE 1
# NOTE: ASSIGN LABEL
# UNTRANSLATED (L1908): LAB(J) = 10 000
# NOTE: GENERATE RETURN
# INCLUDE: F RETFL
# Label only: THEN
# UNTRANSLATED (L1912): RETFL = .FALSE.
# UNTRANSLATED (L1913): K=LAB(J)
# Label only: L=K+1
# ALL GOTO(L)
# ALL RETRN(K)
# ALL LABEL(L)
# IF
# NOTE: STOP
# ASE 2
# NOTE: ASSIGN LABEL
# UNTRANSLATED (L1922): LAB(J) = 10 002
# NOTE: GENERATE STOP
# INCLUDE: F STPFL
# Label only: THEN
# UNTRANSLATED (L1926): STPFL = .FALSE.
# UNTRANSLATED (L1927): K=LAB(J)
# Label only: L=K+1
# ALL GOTO(L)
# ALL STP(K)
# ALL LABEL(L)
# IF
# NOTE: XFOR
# ASE 3
# NOTE: ASSIGN LABEL
# ALL LREAD(LAB(J))
# NOTE: XWHILE
# ASE 4
# NOTE: ASSIGN LABEL
# ALL WREAD(LAB(J))
# NOTE: XREPEAT
# ASE 5
# NOTE: ASSIGN LABEL
# ALL UREAD(LAB(J))
# NOTE: PROC NAME
# ASE 6
# NOTE: ASSIGN LABEL
# ALL PREAD(CPARM(JJ+3),LAB(J))
# Label only: OTHER
# SELECT
# UNTRANSLATED (L1951): J = J + 1
# UNTRANSLATED (L1952): JJ=JJ+9
# WHILE
# NOTE: GENERATE STATEMENT
# Label only: J = 1
# Label only: JJ=1
# UNTRANSLATED (L1957): WHILE NPARM(JJ).GT.0
# UNTRANSLATED (L1958): PERFORM GEREAD
# NOTE: WRITE LABEL
# ALL REDLB(LAB(J))
# UNTRANSLATED (L1961): J = J + 1
# UNTRANSLATED (L1962): JJ=JJ+9
# WHILE
# NOTE: TAIL OF STATEMENT
# UNTRANSLATED (L1965): PERFORM GEREAD
# PROC
# NOTE: 
# NOTE: 
# UNTRANSLATED (L1969): PROC GEREAD
# NOTE: COPY PARAMETERS
# UNTRANSLATED (L1971): K = J - 1
# UNTRANSLATED (L1972): L=NPARM(JJ+1)
# UNTRANSLATED (L1973): M=NPARM(JJ+2)
# NOTE: GENERATE PART OF I/O STATEMENT OR CALL
# ALL REDTX(K,L,M)
# PROC
# EJECT: ND
# NOTE: 
# NOTE: WRITE A LINE FOR SUBSEQUENT INPUT TO FORTRAN
# NOTE: COMPILER
# NOTE: 
# UNTRANSLATED (L1982): SUBROUTINE WRITER
# NOTE: INCREMENT FOR COMMENT & CONTINUATION
# UNTRANSLATED (L1984): PARAMETER (INCCOM=1,INCCON=1)
# NOTE: 
# UNTRANSLATED (L1986): LOGICAL NEXIT
# HARACTER*1 LINE(80)
# OMMON /BLINE/LINE
# OMMON/BPARS/NTYP,NTARGT,NEXIT,NOUT,LUOUT
# HARACTER*1 NAME(6)
# UNTRANSLATED (L1991): DIMENSION LABL(*)
# INCLUDE: NTEGER     I,KGB,NEL,NELC
# Label only: RETURN
# EJECT: 
# NOTE: ><  WRITE COMMENT OR CONT. LINE
# EJECT: NTRY CCARD
# NOTE: EL=NELC(LINE,80)
# UNTRANSLATED (L1998): WRITE(NTARGT,'(80(A1:))') (LINE(KGB),KGB=1,NEL)
# ALL ICRISN(INCCON)
# Label only: RETURN
# NOTE: 
# NOTE: ><  WRITE FORTRAN LINE
# EJECT: NTRY  CARD
# NOTE: EL=NELC(LINE,80)
# UNTRANSLATED (L2005): WRITE(NTARGT,'(80(A1:))') (LINE(KGB),KGB=1,NEL)
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  WRITE DIRECTLY TO TARGET FILE
# EJECT: NTRY FCARD
# NOTE: EL=NELC(LINE(2),79)
# UNTRANSLATED (L2012): WRITE(NTARGT,'(80(A1:))') (LINE(KGB+1),KGB=1,NEL)
# ALL ICRISN(INCCOM)
# Label only: RETURN
# NOTE: 
# NOTE: ><        IF(.NOT.(
# EJECT: NTRY IFNOT
# UNTRANSLATED (L2018): WRITE(NTARGT,'(5X,A)')             ' IF(.NOT.('
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><        GOTO .....
# EJECT: NTRY GOTO(L)
# INCLUDE: F .NOT. NEXIT
# Label only: THEN
# UNTRANSLATED (L2026): WRITE(NTARGT,'(5X,A,I5)')          ' GOTO ',L
# ALL ICRISN(1)
# IF
# Label only: RETURN
# NOTE: 
# NOTE: ><  ..... CONTINUE
# EJECT: NTRY  LABEL (L)
# UNTRANSLATED (L2033): WRITE(NTARGT,'(I5,A)')           L,' CONTINUE'
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  ..... RETURN
# EJECT: NTRY RETRN(L)
# UNTRANSLATED (L2039): WRITE(NTARGT,'(I5,A)')           L,' RETURN'
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  ..... STOP
# EJECT: NTRY STP(L)
# UNTRANSLATED (L2045): WRITE(NTARGT,'(I5,A)')           L,' STOP'
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  ASSIGN STATEMENT
# EJECT: NTRY ASSGN (L,NAME)
# UNTRANSLATED (L2051): WRITE(NTARGT,'(5X,A,I5,A,6A1)')    ' ASSIGN ',L,' TO ',NAME
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  ASSIGNED GOTO
# EJECT: NTRY AGOTO(NAME)
# UNTRANSLATED (L2057): WRITE(NTARGT,'(5X,A,6A1)')       ' GOTO ',NAME
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  COMPUTED GOTO
# EJECT: NTRY CGOTO(N,LABL)
# UNTRANSLATED (L2063): WRITE(NTARGT,'(5X,A)')                ' GOTO('
# NOTE: UM=N
# UNTRANSLATED (L2065): PERFORM LABELS
# UNTRANSLATED (L2066): WRITE(NTARGT,'(5X,A)')           '-), IZZZSE'
# ALL ICRISN(1+INCCON)
# Label only: RETURN
# NOTE: 
# NOTE: ><  TERMINATE GOTO  (AFTER 'IFNOT')
# EJECT: NTRY CLGOTO(L)
# UNTRANSLATED (L2072): WRITE(NTARGT,'(5X,A,I5)')          '-))GOTO ',L
# ALL ICRISN(INCCON)
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: ><  REMAINDER OF STMT AS CONT. LINE
# EJECT: NTRY TXT(K)
# NOTE: EL=NELC(LINE(K),73-K)
# UNTRANSLATED (L2080): WRITE(NTARGT,'(5X,A,80(A1:))') '-',(LINE(I+K-1),I=1,NEL)
# ALL ICRISN(INCCON)
# Label only: RETURN
# NOTE: 
# NOTE: ><  PART OF I/O STMT WITH EXITS
# EJECT: NTRY REDTX(L,K,K1)
# NOTE: EL=K1-K+1
# UNTRANSLATED (L2087): WRITE(NTARGT,'(5X,I1.0,80(A1:))') L,(LINE(I),I=K,K1)
# INCLUDE: F L.EQ.0
# Label only: THEN
# ALL ICRISN(1)
# EJECT: LSE
# ALL ICRISN(INCCON)
# IF
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: ><  EXIT LABEL OF I/O STMT
# EJECT: NTRY  REDLB (L)
# UNTRANSLATED (L2099): WRITE(NTARGT,'(5X,A,I5)')       '-',L
# ALL ICRISN(INCCON)
# Label only: RETURN
# NOTE: 
# NOTE: ><  DO LOOP
# EJECT: NTRY  DOLP  (L,K)
# NOTE: EL=NELC(LINE(K),68-K)
# UNTRANSLATED (L2106): WRITE(NTARGT,'(5X,A,I5,80(A1:))') ' DO ',L,(LINE(I+K-1),I=1,NEL)
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  BLOCK IF
# EJECT: NTRY BLKIF
# UNTRANSLATED (L2112): WRITE(NTARGT,'(5X,A)')             ' IF('
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  THEN
# EJECT: NTRY BLKTHN
# UNTRANSLATED (L2118): WRITE(NTARGT,'(5X,A)')             '-)THEN'
# ALL ICRISN(INCCON)
# Label only: RETURN
# NOTE: 
# NOTE: ><  ELSE
# EJECT: NTRY BLKELS
# UNTRANSLATED (L2124): WRITE(NTARGT,'(5X,A)')             ' ELSE'
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  ENDIF
# EJECT: NTRY BLKCIF
# UNTRANSLATED (L2130): WRITE(NTARGT,'(5X,A)')             ' ENDIF'
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: ><  ELSEIF
# EJECT: NTRY BLKEIF
# UNTRANSLATED (L2136): WRITE(NTARGT,'(5X,A)')            ' ELSEIF('
# ALL ICRISN(1)
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: WRITE STMT LABELS FOR CGOTO
# UNTRANSLATED (L2142): PROC LABELS
# UNTRANSLATED (L2143): WRITE(NTARGT,1) (LABL(I),I=1,NUM)
# 1 FORMAT((5X,'-',11(I5,:,',')))
# ALL ICRISN(((NUM-1)/11+1)*INCCON)
# PROC
# EJECT: ND
# NOTE: IFER
# NOTE: 
# NOTE: HANDLES EVERY THING CONCERNING THE
# NOTE: IF-THEN-ELSEIF-ELSE-CIF CONSTRUCT
# NOTE: 
# UNTRANSLATED (L2153): SUBROUTINE IFER
# NOTE: 
# HARACTER*1 LINE(80)
# OMMON /BLINE/LINER TO UPPER FUNCTION
# HARACTER*1 LTU
# Label only: RETURN
# EJECT: 
# NOTE: 
# NOTE: ><  IF STATEMENT
# EJECT: NTRY DOIF
# ALL BLKIF
# UNTRANSLATED (L2164): PERFORM CONDIT
# Label only: RETURN
# NOTE: 
# NOTE: ><  THEN STATEMENT
# EJECT: NTRY THEN
# ALL BLKTHN
# Label only: RETURN
# NOTE: 
# NOTE: ><  ELSEIF STATEMENT
# EJECT: NTRY ELSEIF
# ALL BLKEIF
# UNTRANSLATED (L2175): PERFORM CONDIT
# Label only: RETURN
# NOTE: 
# NOTE: ><  ELSE STATEMENT
# EJECT: NTRY ELSE
# ALL BLKELS
# Label only: RETURN
# NOTE: 
# NOTE: ><  CIF OR ENDIF STATEMENT
# EJECT: NTRY FIN
# ALL BLKCIF
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: WRITE (FIRST LINE OF) CONDITION
# UNTRANSLATED (L2190): PROC CONDIT
# INCLUDE: =7
# Label only: REPEAT
# INCLUDE: = I + 1
# UNTRANSLATED (L2194): UNTIL ( LTU( LINE(I) ) .EQ. 'F' )
# INCLUDE: =I+1
# ALL TXT(I)
# PROC
# EJECT: ND
# NOTE: WHILER
# NOTE: HANDLES EVERY THING CONCERNING THE WHILE CONSTRUCT
# NOTE: 
# UNTRANSLATED (L2202): SUBROUTINE WHILER
# Label only: SAVE
# NOTE: 
# HARACTER*1 LINE(80)
# OMMON /BLINE/LINE
# NOTE: WHILE STACK POINTER
# INCLUDE: NTEGER  WHISTP
# NOTE: WHILE STACK
# INCLUDE: NTEGER  WHISTK(32)
# NOTE: LABEL NUMBER COUNT
# INCLUDE: NTEGER  NXTLAB
# INCLUDE: NTEGER I
# NOTE: CHARACTER FOR COMPARISON
# HARACTER*1 ER TO UPPER FUNCTION
# HARACTER*1 LTU
# UNTRANSLATED (L2217): DATA WHISTP /0/,NXTLAB /15000/,I /10099/
# UNTRANSLATED (L2218): DATA E /'E'/
# Label only: RETURN
# EJECT: 
# NOTE: ><  WHILE STATEMENT
# EJECT: NTRY DOWHI
# NOTE: STACK LABEL
# UNTRANSLATED (L2224): WHISTP = WHISTP + 1
# UNTRANSLATED (L2225): WHISTK(WHISTP) = NXTLAB
# NOTE: GENERATE'<LABEL> CONTINUE'
# ALL  LABEL(NXTLAB)
# NOTE: XTLAB = NXTLAB + 1
# ALL BLKIF
# INCLUDE: =10
# Label only: REPEAT
# INCLUDE: = I + 1
# UNTRANSLATED (L2233): UNTIL ( LTU( LINE(I) ) .EQ. E )
# INCLUDE: =I+1
# ALL TXT(I)
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: ><  PRODUCE OBJECT LINE
# NOTE: AT END OF WHILE STATEMENT
# EJECT: NTRY CWHILE
# ALL BLKTHN
# NOTE: XTLAB = NXTLAB + 1
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: ><  XWHILE STATEMENT
# EJECT: NTRY LEAVE
# UNTRANSLATED (L2249): PERFORM NLEAVE
# NOTE: GENERATE 'GO TO <LABEL+1>'
# ALL GOTO(I)
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: ><  XWHILE IN I/O STMT OR CALL
# EJECT: NTRY WREAD(LAB)
# UNTRANSLATED (L2257): PERFORM NLEAVE
# NOTE: COPY LABEL
# UNTRANSLATED (L2259): LAB = I
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: ><  CWHILE STATEMENT
# EJECT: NTRY REPEAT
# INCLUDE: = WHISTK(WHISTP)
# ALL GOTO(I)
# INCLUDE: = I + 1
# ALL BLKCIF
# ALL LABEL(I)
# NOTE: UNSTACK WHILE
# UNTRANSLATED (L2271): WHISTP = WHISTP - 1
# Label only: RETURN
# NOTE: 
# NOTE: 
# NOTE: ><  CLEAR WHILE HANDLER
# EJECT: NTRY WCLEAR
# UNTRANSLATED (L2277): WHISTP = 0
# NOTE: RESET LABEL COUNT
# NOTE: XTLAB = 15000
# Label only: RETURN
# EJECT: 
# UNTRANSLATED (L2282): PROC NLEAVE
# INCLUDE: F WHISTP .LE. 0
# Label only: THEN
# ALL ERRMSG('NO WHILE CONSTRUCT TO LEAVE                       ')
# EJECT: LSE
# INCLUDE: = WHISTK(WHISTP) + 1
# IF
# PROC
# EJECT: ND
# NOTE: CASER
# NOTE: HANDLES EVERYTHING CONCERNING SELECT CONSTRUCTS
# NOTE: 
# UNTRANSLATED (L2294): SUBROUTINE CASER
# Label only: SAVE
# NOTE: NUMBER OF CASE LABELS
# UNTRANSLATED (L2297): PARAMETER (NCASL=500)
# NOTE: STACK SIZE
# UNTRANSLATED (L2299): PARAMETER (NSELCA=33)
# NOTE: 
# HARACTER*1 LINE(80)
# OMMON /BLINE/LINE
# OMMON /BPARM/NCASV(66)
# NOTE: LABEL COUNT
# INCLUDE: NTEGER   NXTLAB
# NOTE: SELECT STACK POINTER
# INCLUDE: NTEGER  SELPTR
# NOTE: CASE LABEL LIST START STACK
# INCLUDE: NTEGER  SELCAS(NSELCA)
# NOTE: CASE LABEL LIST
# INCLUDE: NTEGER  CASLAB(NCASL)
# NOTE: NR OF CASE LABEL LIST ENTRIES
# INCLUDE: NTEGER  LABMAX
# NOTE: FIRST CASE LABEL LIST ENTRY
# INCLUDE: NTEGER  FIRSTC
# NOTE: LAST CASE LABEL LIST ENTRY + 1
# INCLUDE: NTEGER LASTC
# NOTE: THIS CASE LABEL LIST ENTRY
# INCLUDE: NTEGER  CASENT
# NOTE: CASE VALUE MAX
# INCLUDE: NTEGER  VALMAX
# NOTE: OTHER LABEL
# INCLUDE: NTEGER  OTHERL
# NOTE: CSELECT LABEL
# INCLUDE: NTEGER  REVERL
# HARACTER*1 BLANK
# HARACTER*1 EQUAL
# NOTE: CHARACTER FOR COMPARISON
# HARACTER*1 T
# HARACTER*1 SELVAR(6)R TO UPPER FUNCTION
# HARACTER*1 LTU
# UNTRANSLATED (L2332): DATA NXTLAB /14000/,SELPTR /1/
# UNTRANSLATED (L2333): DATA SELCAS/NSELCA*1/,LABMAX /NCASL/,VALMAX /198/
# UNTRANSLATED (L2334): DATA FIRSTC /1/,LASTC /1/
# UNTRANSLATED (L2335): DATA EQUAL /'='/,T /'T'/,BLANK /' '/
# UNTRANSLATED (L2336): DATA SELVAR /'I','Z','Z','Z','S','E'/
# Label only: RETURN
# EJECT: 
# NOTE: ><  'SELECT' STATEMENT
# EJECT: NTRY DOSEL
# NOTE: GENERATE 'IZZZSE=...'
# INCLUDE: =11
# Label only: REPEAT
# INCLUDE: = I + 1
# UNTRANSLATED (L2345): UNTIL ( LTU( LINE(I) ) .EQ. T )
# FORTRAN DIRECTIVE: OR J=7,I
# UNTRANSLATED (L2347): LINE(J)=BLANK
# FOR
# FORTRAN DIRECTIVE: OR J=1,6
# UNTRANSLATED (L2350): LINE(J+6)=SELVAR(J)
# FOR
# UNTRANSLATED (L2352): LINE(I + 1) = EQUAL
# ALL CARD
# NOTE: ASSIGN OTHER LABEL
# UNTRANSLATED (L2355): OTHERL = NXTLAB
# UNTRANSLATED (L2356): REVERL = OTHERL + 1
# NOTE: XTLAB = NXTLAB + 3
# NOTE: STACK CASE LABEL LIST START
# UNTRANSLATED (L2359): SELPTR = SELPTR + 1
# UNTRANSLATED (L2360): SELCAS(SELPTR) = LASTC
# NOTE: STACK OTHER LABEL
# ASLAB(LASTC) = OTHERL
# FORTRAN DIRECTIVE: IRSTC = LASTC
# UNTRANSLATED (L2364): LASTC = LASTC + 1
# Label only: RETURN
# NOTE: END OF CONTINUATIONS
# NOTE: 
# NOTE: 
# EJECT: NTRY CONSEL
# NOTE: GENERATE 'GO TO <SELECT>'
# ALL GOTO(OTHERL+2)
# NOTE: HANDLE CASE
# UNTRANSLATED (L2373): PERFORM NEWCAS
# Label only: RETURN
# NOTE: 
# NOTE: ><  'CASE' STATEMENT
# EJECT: NTRY DOCASE
# NOTE: GENERATE 'GO TO <CSELECT>'
# ALL GOTO(REVERL)
# NOTE: HANDLE CASE
# UNTRANSLATED (L2381): PERFORM NEWCAS
# Label only: RETURN
# NOTE: 
# NOTE: ><  'OTHER' STATEMENT
# EJECT: NTRY OTHER
# NOTE: GENERATE 'GO TO <CSELECT>'
# ALL GOTO(REVERL)
# INCLUDE: = LASTC - FIRSTC - 1
# ALL LABEL(OTHERL+2)
# NOTE: CHECK FOR EMPTY CASE LABEL LIST
# INCLUDE: F I .GT. 0
# Label only: THEN
# NOTE: GENERATE 'GO TO(-,-,-,-)'
# ALL CGOTO(I,CASLAB(FIRSTC+1))
# IF
# NOTE: GENERATE '<OTHER> CONTINUE'
# ALL LABEL(OTHERL)
# Label only: RETURN
# NOTE: 
# NOTE: ><  'CSELECT' STATEMENT
# EJECT: NTRY REVERT
# NOTE: GENERATE '<CSELECT> CONTINUE'
# ALL LABEL(REVERL)
# NOTE: UNSTACK LAST ENTRY
# UNTRANSLATED (L2405): LASTC = SELCAS(SELPTR)
# NOTE: UNSTACK SELECT
# UNTRANSLATED (L2407): SELPTR = SELPTR - 1
# NOTE: RESET START ENTRY
# FORTRAN DIRECTIVE: IRSTC = SELCAS(SELPTR)
# NOTE: RESET OTHER LABEL
# UNTRANSLATED (L2411): OTHERL = CASLAB(FIRSTC)
# NOTE: RESET CSELECT LABEL
# UNTRANSLATED (L2413): REVERL = OTHERL + 1
# Label only: RETURN
# NOTE: 
# NOTE: ><  RESET CASE HANDLER
# EJECT: NTRY CCLEAR
# FORTRAN DIRECTIVE: OR I = 1 , SELPTR
# UNTRANSLATED (L2419): SELCAS(I) = 1
# FOR
# UNTRANSLATED (L2421): SELPTR = 1
# FORTRAN DIRECTIVE: IRSTC = 1
# UNTRANSLATED (L2423): LASTC = 1
# NOTE: RESET GENERATION SWITCH
# NOTE: RESET LABEL COUNT
# NOTE: XTLAB = 14000
# Label only: RETURN
# EJECT: 
# UNTRANSLATED (L2429): PROC NEWCAS
# Label only: J = 1
# NOTE: FOR EACH NEW CASE VALUE
# UNTRANSLATED (L2432): WHILE NCASV(J) .GT. 0
# NOTE: ASSIGN ENTRY IN CASE LABEL LIST
# ASENT = FIRSTC + NCASV(J)
# NOTE: CHECK RANGE EXTENSION
# INCLUDE: F CASENT .GE. LASTC
# Label only: THEN
# NOTE: CHECK CASE VALUE RANGE
# INCLUDE: F NCASV(J) .GT. VALMAX
# Label only: THEN
# ALL ERRMSG('CASE VALUE GREATER THAN 198                       ')
# Label only: XWHILE
# IF
# NOTE: CHECK ROOM IN CASE LABEL LIST
# INCLUDE: F CASENT .GE. LABMAX
# Label only: THEN
# ALL ERRMSG('TOO MANY NESTED CASES; FATAL ERROR                ')
# ALL ABORT
# IF
# NOTE: INIT CASE LABELS WITH OTHER
# FORTRAN DIRECTIVE: OR I = LASTC , CASENT
# ASLAB(I) = OTHERL
# FOR
# NOTE: INCREMENT LAST CASE POINTER
# UNTRANSLATED (L2455): LASTC = CASENT + 1
# EJECT: LSE
# NOTE: CHECK DOUBLE CASE VALUE
# INCLUDE: F CASLAB(CASENT) .NE. OTHERL
# Label only: THEN
# ALL ERRMSG('DUPLICATE CASE VALUE                              ')
# Label only: XWHILE
# IF
# IF
# NOTE: INIT CASE LABEL ENTRY
# ASLAB(CASENT) = NXTLAB
# UNTRANSLATED (L2466): J = J + 1
# WHILE
# NOTE: GENERATE '<CASE LABEL>CONTINUE'
# ALL  LABEL(NXTLAB)
# NOTE: XTLAB = NXTLAB + 1
# PROC
# EJECT: ND
# NOTE: UNTLER
# NOTE: HANDLES EVERYTHING CONCERNING THE REPEAT CONSTRUCT
# NOTE: 
# UNTRANSLATED (L2476): SUBROUTINE UNTILR
# NOTE: 
# Label only: SAVE
# HARACTER*1 LINE(80)
# OMMON /BLINE/LINE
# NOTE: STACK POINTER
# INCLUDE: NTEGER UNTSTP
# NOTE: LABEL STACK
# INCLUDE: NTEGER UNTSTK(32)
# NOTE: LABEL COUNTER
# INCLUDE: NTEGER NXTLAB
# INCLUDE: NTEGER I
# NOTE: COMPARISON CHARACTER
# HARACTER*1 LR TO UPPER FUNCTION
# HARACTER*1 LTU
# UNTRANSLATED (L2491): DATA UNTSTP /0/,NXTLAB /16000/,I /10099/
# UNTRANSLATED (L2492): DATA L /'L'/
# Label only: RETURN
# EJECT: 
# NOTE: ><  REPEAT  STATEMENT
# EJECT: NTRY C UNTIL
# NOTE: STACK LABEL
# UNTRANSLATED (L2498): UNTSTP = UNTSTP + 1
# UNTRANSLATED (L2499): UNTSTK(UNTSTP) = NXTLAB
# NOTE: GENERATE '<LABEL>CONTINUE'
# ALL LABEL(NXTLAB)
# NOTE: XTLAB = NXTLAB + 2
# Label only: RETURN
# NOTE: 
# NOTE: ><  XREPEAT STATEMENT
# EJECT: NTRY XUNTIL
# UNTRANSLATED (L2507): PERFORM NXUNTL
# NOTE: GENERATE 'GOTO <LABEL+1>'
# ALL GOTO(I)
# Label only: RETURN
# NOTE: 
# NOTE: ><  XREPEAT IN I/O STMT OR CALL
# EJECT: NTRY UREAD(LAB)
# NOTE: OUTPUT LABEL FOR I/O STMT OR CALL
# UNTRANSLATED (L2515): PERFORM NXUNTL
# NOTE: COPY LABEL
# UNTRANSLATED (L2517): LAB = I
# Label only: RETURN
# NOTE: 
# NOTE: ><  UNTIL STATEMENT
# EJECT: NTRY DO UNTL
# ALL IFNOT
# INCLUDE: =10
# Label only: REPEAT
# INCLUDE: = I + 1
# UNTRANSLATED (L2526): UNTIL ( LTU( LINE(I) ) .EQ. L )
# INCLUDE: =I+1
# NOTE: PRODUCE OBJECT LINE
# ALL TXT(I)
# Label only: RETURN
# NOTE: 
# NOTE: ><  STATEMENT AFTER UNTIL
# EJECT: NTRY CO UNTL
# INCLUDE: =UNTSTK(UNTSTP)
# ALL CLGOTO(I)
# NOTE: GENERATE '<LABEL+1> CONTINUE'
# ALL LABEL(I+1)
# NOTE: UNSTACK UNTIL
# UNTRANSLATED (L2539): UNTSTP = UNTSTP - 1
# Label only: RETURN
# NOTE: 
# NOTE: ><  CLEAR UNTIL HANDLER
# EJECT: NTRY UCLEAR
# UNTRANSLATED (L2544): UNTSTP = 0
# NOTE: RESET LABEL COUNT
# NOTE: XTLAB = 16000
# Label only: RETURN
# EJECT: 
# NOTE: GET EXIT LABEL WHEN PRESENT
# UNTRANSLATED (L2550): PROC NXUNTL
# INCLUDE: F UNTSTP .LE. 0
# Label only: THEN
# ALL ERRMSG('NO REPEAT CONSTRUCT TO LEAVE                      ')
# EJECT: LSE
# INCLUDE: = UNTSTK(UNTSTP) + 1
# IF
# PROC
# EJECT: ND
# NOTE: LOOPER
# NOTE: 
# NOTE: HANDLES EVERYTHING CONCERNING THE FOR-CFOR
# NOTE: STRUCTURE
# NOTE: 
# UNTRANSLATED (L2564): SUBROUTINE LOOPER
# Label only: SAVE
# NOTE: 
# HARACTER*1 LINE(80)
# OMMON /BLINE/LINE
# NOTE: FOR STACK POINTER
# INCLUDE: NTEGER FORPTR
# NOTE: FOR STACK
# INCLUDE: NTEGER FORSTK(32)
# NOTE: R
# HARACTER*1 R
# NOTE: LABEL NUMBER COUNT
# INCLUDE: NTEGER NXTLAB
# INCLUDE: NTEGER IR TO UPPER FUNCTION
# HARACTER*1 LTU
# UNTRANSLATED (L2579): DATA FORPTR /0/,R /'R'/
# UNTRANSLATED (L2580): DATA NXTLAB /13000/,I /10099/
# Label only: RETURN
# EJECT: 
# NOTE: ><  FOR STATEMENT
# EJECT: NTRY FOR
# NOTE: GET AND STACK LABEL
# FORTRAN DIRECTIVE: ORPTR = FORPTR + 1
# FORTRAN DIRECTIVE: ORSTK(FORPTR) = NXTLAB
# NOTE: LOOKUP POSITION OF R IN FOR
# Label only: J=8
# Label only: REPEAT
# UNTRANSLATED (L2591): J = J + 1
# UNTRANSLATED (L2592): UNTIL ( LTU( LINE(J) ) .EQ. R )
# UNTRANSLATED (L2593): J = J + 1
# NOTE: GENERATE 'DO <CFOR> -----'
# ALL DOLP(NXTLAB,J)
# NOTE: RESERVE XFOR LABEL
# NOTE: XTLAB = NXTLAB + 2
# Label only: RETURN
# NOTE: 
# NOTE: ><  XFOR STATEMENT
# EJECT: NTRY DOEXIT
# UNTRANSLATED (L2602): PERFORM NEXIT
# NOTE: GENERATE 'GO TO <XFOR>'
# ALL  GOTO(I)
# Label only: RETURN
# NOTE: 
# NOTE: ><  XFOR IN I/O STMT OR CALL
# EJECT: NTRY LREAD(LAB)
# NOTE: OUTPUT LABEL FOR I/O STMT OR CALL
# UNTRANSLATED (L2610): PERFORM NEXIT
# NOTE: COPY LABEL
# UNTRANSLATED (L2612): LAB = I
# Label only: RETURN
# NOTE: 
# NOTE: ><  CFOR STATEMENT
# EJECT: NTRY NEXT
# INCLUDE: = FORSTK(FORPTR)
# NOTE: GENERATE '<CFOR> CONTINUE'
# ALL  LABEL(I)
# INCLUDE: = I + 1
# NOTE: GENERATE '<XFOR> CONTINUE'
# ALL  LABEL(I)
# NOTE: UNSTACK
# FORTRAN DIRECTIVE: ORPTR = FORPTR - 1
# Label only: RETURN
# NOTE: 
# NOTE: ><  CLEAR FOR-CFOR HANDLER
# EJECT: NTRY LCLEAR
# FORTRAN DIRECTIVE: ORPTR = 0
# NOTE: RESET LABEL COUNT
# NOTE: XTLAB = 13000
# Label only: RETURN
# NOTE: 
# NOTE: ><  OBTAIN NESTING DEPTH
# EJECT: NTRY FORDEP(ID)
# INCLUDE: D=FORPTR
# Label only: RETURN
# EJECT: 
# UNTRANSLATED (L2639): PROC NEXIT
# INCLUDE: F FORPTR .LE. 0
# Label only: THEN
# ALL ERRMSG('NO FOR CONSTRUCT TO LEAVE                         ')
# EJECT: LSE
# INCLUDE: = FORSTK(FORPTR) + 1
# IF
# PROC
# EJECT: ND
# NOTE: PROCER
# NOTE: 
# NOTE: HANDLES EVERYTHING  CONCERNING PROCEDURES
# NOTE: 
# UNTRANSLATED (L2652): SUBROUTINE PROCER
# Label only: SAVE
# NOTE: MAX. NUMBER OF PROCS (MUST BE .LE. 99)
# UNTRANSLATED (L2655): PARAMETER (MAXPRC=99)
# NOTE: 
# HARACTER*1 LINE(80)
# OMMON /BLINE/LINE
# NOTE: LABEL COUNT
# INCLUDE: NTEGER NXTLAB
# NOTE: TEMP'PROC'NAME IDENTIFIER
# HARACTER*1 PROD(31) ,PARM(31)
# NOTE: PROC LIST POINTER (LOOK UP)
# INCLUDE: NTEGER   PROPTR
# NOTE: PROC LIST POINTER (END STMNT)
# INCLUDE: NTEGER   PROPRT
# NOTE: LAST PROC LIST ENTRY POINTER
# INCLUDE: NTEGER   LASTPR
# NOTE: CURRENT PROC LIST ENTRY POINTER
# INCLUDE: NTEGER   THISPR,IREV
# NOTE: CURRENT PROC POINTER
# INCLUDE: NTEGER  CURPRC
# NOTE: PROC NAME
# HARACTER*1 PRONAM(31,MAXPRC)
# NOTE: PROC LABEL
# INCLUDE: NTEGER PROLAB(MAXPRC)
# NOTE: NUMBER OF REFERENCES
# INCLUDE: NTEGER NOFREF(MAXPRC)
# NOTE: CHARACTERS FOR NAME COPY
# HARACTER*1 XAR
# HARACTER*1 DIGIT(0:9)
# HARACTER*1 M,C,BLANK
# HARACTER*1 INAME(6)
# INCLUDE: NTEGER SAVEP,SAVE(7),PLAB
# NOTE: LOWER TO UPPER FUNCTION
# HARACTER*1 LTU
# UNTRANSLATED (L2687): LOGICAL OKAY
# INCLUDE: NTEGER KGB
# UNTRANSLATED (L2689): DATA SAVEP /0/,SAVE /7*0/
# UNTRANSLATED (L2690): DATA NXTLAB /17000/,PROD /31*' '/
# UNTRANSLATED (L2691): DATA PROPTR /0/,PROPRT /0/,LASTPR /1/
# UNTRANSLATED (L2692): DATA PROLAB /MAXPRC*0/,NOFREF /MAXPRC*0/
# UNTRANSLATED (L2693): DATA INAME /'I','Z','Z','Z',' ',' '/
# UNTRANSLATED (L2694): DATA DIGIT/'0','1','2','3','4','5','6','7','8','9'/
# UNTRANSLATED (L2695): DATA M/'M'/,C/'C'/,BLANK/' '/
# Label only: RETURN
# EJECT: 
# NOTE: 
# NOTE: ><  HANDLE PERFORM
# EJECT: NTRY PFORM
# NOTE: GET PROC NAME
# UNTRANSLATED (L2702): XAR = M
# UNTRANSLATED (L2703): PERFORM COPY
# NOTE: ADD NAME TO PROC LIST,GET LABEL
# UNTRANSLATED (L2705): PERFORM ADPROC
# NOTE: GENERATE 'ASSIGN <L> TO <PROC>'
# INCLUDE: NAME(5)=DIGIT(THISPR/10)
# INCLUDE: NAME(6)=DIGIT(MOD(THISPR,10))
# ALL ASSGN(NXTLAB,INAME)
# NOTE: GENERATE 'GO TO <PROC-LABEL>'
# ALL  GOTO(IREV)
# NOTE: GENERATE '<L> CONTINUE'
# ALL  LABEL(NXTLAB)
# NOTE: INCREMENT LABEL
# UNTRANSLATED (L2715): PERFORM PUTLAB
# NOTE: CHECK WHETHER IN FOR LOOP
# ALL FORDEP(K)RNING DISABLED *****
# *        IF K.GT.0
# *        THEN
# *          CALL WARN(PRONAM(1,THISPR),
# *     - ': PERFORM IN FOR-LOOP CAUSES NON-STANDARD FORTRAN ')
# *        CIF
# Label only: RETURN
# NOTE: 
# NOTE: ><  OPEN PROC DEFINITION
# EJECT: NTRY PROC
# NOTE: GET PROC NAME
# UNTRANSLATED (L2728): XAR = C
# UNTRANSLATED (L2729): PERFORM COPY
# NOTE: ADD NAME TO PROC LIST,GET LABEL
# UNTRANSLATED (L2731): PERFORM ADPROC
# NOTE: GEN '<PROC-LABEL> CONTINUE'
# ALL  LABEL(IREV)
# NOTE: MARK PROC 'DEFINED'
# UNTRANSLATED (L2735): PROLAB(THISPR) = - PROLAB(THISPR)
# NOTE: SAVE CURRENT PROC POINTER
# URPRC = THISPR
# Label only: RETURN
# NOTE: 
# NOTE: ><  CLOSE PROC DEFINITION
# EJECT: NTRY PEND
# NOTE: RESTORE CURRENT PROC POINTER
# UNTRANSLATED (L2743): THISPR = CURPRC
# NOTE: WRITE RETURN GOTO
# UNTRANSLATED (L2745): PERFORM GETLAB
# Label only: RETURN
# NOTE: 
# NOTE: ><  PROC IN I/O STMT OR CALL
# EJECT: NTRY PREAD(PARM,PLAB)
# NOTE: COPY PROC NAME
# FORTRAN DIRECTIVE: OR K = 1 , 31
# UNTRANSLATED (L2752): PROD(K) = PARM(K)
# FOR
# NOTE: ADD PROC TO DICTIONARY
# UNTRANSLATED (L2755): PERFORM ADPROC
# NOTE: COPY PROC LABEL
# UNTRANSLATED (L2757): PLAB = IREV
# NOTE: GENERATE 'ASSIGN <L> TO <PROC>'
# INCLUDE: NAME(5)=DIGIT(THISPR/10)
# INCLUDE: NAME(6)=DIGIT(MOD(THISPR,10))
# ALL ASSGN(NXTLAB,INAME)
# NOTE: SAVE RETURN LABEL
# UNTRANSLATED (L2763): SAVEP = SAVEP + 1
# UNTRANSLATED (L2764): SAVE(SAVEP) = NXTLAB
# UNTRANSLATED (L2765): PERFORM PUTLAB
# Label only: RETURN
# NOTE: 
# NOTE: FIRST STATEMENT AFTER I/O STMT OR CALL
# EJECT: NTRY COREAD
# NOTE: GENERATE CONTINUE STATEMENTS
# UNTRANSLATED (L2771): WHILE SAVEP .GT. 0
# ALL  LABEL(SAVE(SAVEP))
# UNTRANSLATED (L2773): SAVEP = SAVEP - 1
# WHILE
# Label only: RETURN
# NOTE: 
# NOTE: ><  CLEAR PROC HANDLER
# EJECT: NTRY PCLEAR
# NOTE: GENERATE STUBS FOR LEFT PROC'S
# UNTRANSLATED (L2780): PROPRT=1
# UNTRANSLATED (L2781): WHILE PROPRT.LE.LASTPR
# NOTE: IF NO PROC DEFINED
# INCLUDE: F PROLAB(PROPRT) .GT. 0 .AND. PROPRT .LT. LASTPR
# NOTE: GENERATE STUB
# Label only: THEN
# NOTE: GENERATE '<PROC LABEL>CONTINUE'
# ALL LABEL(PROLAB(PROPRT))
# NOTE: WRITE RETURN LABEL LIST
# UNTRANSLATED (L2789): THISPR = PROPRT
# UNTRANSLATED (L2790): PERFORM GETLAB
# ALL WARN(PRONAM(1,PROPRT),'IS NOT DEFINED                                    ')
# IF
# NOTE: CLEAR LIST
# UNTRANSLATED (L2794): PROLAB(PROPRT) = 0
# UNTRANSLATED (L2795): PROPRT=PROPRT+1
# WHILE
# NOTE: RESET POINTERS
# NOTE: XTLAB=17000
# NOTE: RESET LAST PROC COUNT
# UNTRANSLATED (L2800): LASTPR = 1
# Label only: RETURN
# EJECT: 
# NOTE: ADD NAME TO PROC LIST,GET LABEL
# UNTRANSLATED (L2804): PROC ADPROC
# NOTE: FOR EACH LIST ENTRY
# FORTRAN DIRECTIVE: OR  PROPTR = 1 , LASTPR
# NOTE: IF NOT FOUND
# INCLUDE: F PROPTR .EQ. LASTPR
# Label only: THEN
# INCLUDE: F LASTPR.GT.MAXPRC
# Label only: THEN
# ALL ERRMSG('TOO MANY PROCS                                    ')
# ALL ABORT
# IF
# NOTE: GET LABEL
# INCLUDE: REV = NXTLAB
# NOTE: XTLAB = NXTLAB + 1
# NOTE: CREATE NEW ENTRY
# FORTRAN DIRECTIVE: OR  K = 1 , 31
# UNTRANSLATED (L2820): PRONAM(K,PROPTR) = PROD(K)
# FOR
# UNTRANSLATED (L2822): PROLAB(PROPTR) = IREV
# NOTE: INCREMENT LAST ENTRY COUNT
# UNTRANSLATED (L2824): LASTPR = LASTPR + 1
# UNTRANSLATED (L2825): THISPR = PROPTR
# Label only: XFOR
# EJECT: LSE
# NOTE: LOOK FOR MATCH
# UNTRANSLATED (L2829): OKAY=.TRUE.
# FORTRAN DIRECTIVE: OR KGB=1,31
# UNTRANSLATED (L2831): OKAY=(OKAY.AND.(PRONAM(KGB,PROPTR).EQ.PROD(KGB)))
# FOR
# INCLUDE: F (OKAY)
# Label only: THEN
# NOTE: IF MATCH THEN COPY LABEL
# INCLUDE: REV = IABS(PROLAB(PROPTR))
# NOTE: CHECK WHETHER
# INCLUDE: F PROLAB(PROPTR) .LT. 0
# NOTE: PROC IS ALREADY DEFINED
# Label only: THEN
# ALL ERRMSG('PROC REFERENCED AFTER ITS DEFINITION              ')
# IF
# UNTRANSLATED (L2843): THISPR = PROPTR
# Label only: XFOR
# IF
# IF
# FOR
# PROC
# NOTE: 
# NOTE: 
# NOTE: COUNT REFS AND INCREMENT LABEL
# UNTRANSLATED (L2852): PROC PUTLAB
# NOTE: OFREF(THISPR) = NOFREF(THISPR) + 1
# NOTE: XTLAB = NXTLAB + 1
# PROC
# NOTE: 
# NOTE: 
# NOTE: WRITE RETURN GOTO
# UNTRANSLATED (L2859): PROC GETLAB
# INCLUDE: REV = NOFREF(THISPR)
# NOTE: IF NO REFERENCES
# INCLUDE: F IREV .LE. 0
# Label only: THEN
# NOTE: THEN GIVE WARNING
# ALL WARN(PRONAM(1,THISPR),'IS NOT REFERENCED                                 ')
# EJECT: LSE
# NOTE: GENERATE 'GOTO IZZZ..'
# INCLUDE: NAME(5)=DIGIT(THISPR/10)
# INCLUDE: NAME(6)=DIGIT(MOD(THISPR,10))
# ALL AGOTO(INAME)
# IF
# NOTE: OFREF(THISPR) = 0
# PROC
# NOTE: 
# NOTE: 
# NOTE: COPY PROC NAME
# UNTRANSLATED (L2877): PROC COPY
# Label only: J=9
# NOTE: LOCATE FIRST POSITION
# Label only: REPEAT
# Label only: J=J+1
# UNTRANSLATED (L2882): UNTIL ( LTU( LINE(J) ) .EQ. XAR )
# Label only: J=J+1
# NOTE: BLANK FIELD
# FORTRAN DIRECTIVE: OR I = 1 , 31
# UNTRANSLATED (L2886): PROD(I) = BLANK
# FOR
# INCLUDE: = 0
# NOTE: COPY CHARACTERS
# FORTRAN DIRECTIVE: OR K=J,72
# NOTE: WHEN NOT BLANK
# INCLUDE: F LINE(K).NE.BLANK
# Label only: THEN
# INCLUDE: = I + 1
# INCLUDE: F I .GT. 31
# Label only: THEN
# ALL ERRMSG('PROC NAME TOO LONG                                ')
# Label only: XFOR
# EJECT: LSE
# UNTRANSLATED (L2900): PROD(I) = LTU(LINE(K))
# IF
# IF
# FOR
# PROC
# EJECT: ND
# EJECT: 
# NOTE: SLATE TAB CHARACTERS TO BLANKS
# NOTE: CAN BE AN EMPTY SUBROUTINE IF TABS DO NOT OCCUR
# NOTE: 
# UNTRANSLATED (L2910): SUBROUTINE RTAB(LINE,NCH)
# HARACTER*1 TAB,BLANK
# NOTE: ITAB IS INTERNAL CHARACTER VALUE OF TAB
# UNTRANSLATED (L2913): PARAMETER (LB=80,ITAB=9,NTAB=8,BLANK=' ')
# HARACTER*1 LINE(NCH),TBUF(LB)
# NOTE: CONVERT INTERNAL CHAR.VALUE TO TYPE CHARACTER*1
# ALL CVIC(ITAB,TAB)
# INCLUDE: F NCH.GT.LB
# Label only: THEN
# NOTE: CANNOT HAPPEN WHEN CALLED FROM SHELTR
# UNTRANSLATED (L2920): STOP 4711
# EJECT: LSE
# INCLUDE: I=0
# INCLUDE: O=0
# Label only: REPEAT
# INCLUDE: I=II+1
# INCLUDE: F LINE(II).EQ.TAB
# Label only: THEN
# NOTE: SP=NTAB-MOD(IO,NTAB)
# FORTRAN DIRECTIVE: OR I=1,NSP
# INCLUDE: O=IO+1
# UNTRANSLATED (L2931): TBUF(IO)=BLANK
# INCLUDE: F IO.EQ.NCH
# Label only: THEN
# UNTRANSLATED (L2934): XREPEAT
# IF
# FOR
# EJECT: LSE
# INCLUDE: O=IO+1
# UNTRANSLATED (L2939): TBUF(IO)=LINE(II)
# IF
# UNTRANSLATED (L2941): UNTIL IO.EQ.NCH
# FORTRAN DIRECTIVE: OR I=1,NCH
# UNTRANSLATED (L2943): LINE(I)=TBUF(I)
# FOR
# IF
# Label only: RETURN
# EJECT: ND
# NOTE: CONVERT INTERNAL TO CHARACTER
# UNTRANSLATED (L2949): SUBROUTINE CVIC(I,C)
# INCLUDE: NTEGER I
# HARACTER*1 C
# =CHAR(I)
# Label only: RETURN
# EJECT: ND
# NOTE: FATAL TRANSLATION HANDLER
# UNTRANSLATED (L2956): SUBROUTINE ABORT
# UNTRANSLATED (L2957): STOP 999
# EJECT: ND
# NOTE: CONVERT A LOWERCASE CHARACTER TO IT'S UPPERCASE EQUIVALENT
# HARACTER*1 FUNCTION LTU( CH )
# HARACTER*1  CH
# INCLUDE: POS = INDEX('abcdefghijklmnopqrstuvwxyz',CH)
# UNTRANSLATED (L2963): SELECT IPOS
# ASE 1
# UNTRANSLATED (L2965): LTU = 'A'
# ASE 2
# UNTRANSLATED (L2967): LTU = 'B'
# ASE 3
# UNTRANSLATED (L2969): LTU = 'C'
# ASE 4
# UNTRANSLATED (L2971): LTU = 'D'
# ASE 5
# UNTRANSLATED (L2973): LTU = 'E'
# ASE 6
# UNTRANSLATED (L2975): LTU = 'F'
# ASE 7
# UNTRANSLATED (L2977): LTU = 'G'
# ASE 8
# UNTRANSLATED (L2979): LTU = 'H'
# ASE 9
# UNTRANSLATED (L2981): LTU = 'I'
# ASE 10
# UNTRANSLATED (L2983): LTU = 'J'
# ASE 11
# UNTRANSLATED (L2985): LTU = 'K'
# ASE 12
# UNTRANSLATED (L2987): LTU = 'L'
# ASE 13
# UNTRANSLATED (L2989): LTU = 'M'
# ASE 14
# UNTRANSLATED (L2991): LTU = 'N'
# ASE 15
# UNTRANSLATED (L2993): LTU = 'O'
# ASE 16
# UNTRANSLATED (L2995): LTU = 'P'
# ASE 17
# UNTRANSLATED (L2997): LTU = 'Q'
# ASE 18
# UNTRANSLATED (L2999): LTU = 'R'
# ASE 19
# UNTRANSLATED (L3001): LTU = 'S'
# ASE 20
# UNTRANSLATED (L3003): LTU = 'T'
# ASE 21
# UNTRANSLATED (L3005): LTU = 'U'
# ASE 22
# UNTRANSLATED (L3007): LTU = 'V'
# ASE 23
# UNTRANSLATED (L3009): LTU = 'W'
# ASE 24
# UNTRANSLATED (L3011): LTU = 'X'
# ASE 25
# UNTRANSLATED (L3013): LTU = 'Y'
# ASE 26
# UNTRANSLATED (L3015): LTU = 'Z'
# Label only: OTHER
# Label only: LTU=CH
# SELECT
# Label only: RETURN
# EJECT: ND
# EJECT: SHLTRN - Function NELC
# INCLUDE: NTEGER FUNCTION NELC(A,N)
# HARACTER*1 A(*)
# INCLUDE: NTEGER     N,NEL
# NOTE: EL=N
# UNTRANSLATED (L3026): WHILE (NEL.GT.0)
# INCLUDE: F (A(NEL).EQ.' ')
# Label only: THEN
# NOTE: EL=NEL-1
# EJECT: LSE
# Label only: XWHILE
# IF
# WHILE
# NOTE: ELC=NEL
# Label only: RETURN
# EJECT: ND
